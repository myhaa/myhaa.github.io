<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HBase.md</title>
      <link href="/2020/06/11/hbase/"/>
      <url>/2020/06/11/hbase/</url>
      
        <content type="html"><![CDATA[<h1 id="HBase基础"><a href="#HBase基础" class="headerlink" title="HBase基础"></a>HBase基础</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><pre class="line-numbers language-lang-markdown"><code class="language-lang-markdown">    HBase是一个开源的非关系型分布式数据库（NoSQL），它参考了谷歌的BigTable建模，实现的编程语言为 Java。它是Apache软件基金会的Hadoop项目的一部分，运行于HDFS文件系统之上，为 Hadoop 提供类似于BigTable 规模的服务。因此，它可以对稀疏文件提供极高的容错率。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h1><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><ul><li>single-node</li><li>standalone</li></ul><h2 id="2-操作"><a href="#2-操作" class="headerlink" title="2. 操作"></a>2. 操作</h2><h3 id="2-1-启动"><a href="#2-1-启动" class="headerlink" title="2.1 启动"></a>2.1 启动</h3><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">$ ./bin/hbase shellhbase(main):001:0><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-2-建表"><a href="#2-2-建表" class="headerlink" title="2.2 建表"></a>2.2 建表</h3><ul><li>必须指定表名<code>test</code>和列名<code>cf</code></li></ul><pre class="line-numbers language-lang-hbase"><code class="language-lang-hbase">hbase(main):001:0> create 'test', 'cf'0 row(s) in 0.4170 seconds=> Hbase::Table - test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-列出表信息"><a href="#2-3-列出表信息" class="headerlink" title="2.3 列出表信息"></a>2.3 列出表信息</h3><pre class="line-numbers language-lang-hbase"><code class="language-lang-hbase">hbase(main):002:0> list 'test'TABLEtest1 row(s) in 0.0180 seconds=> ["test"]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-hbase"><code class="language-lang-hbase">hbase(main):003:0> describe 'test'Table test is ENABLEDtestCOLUMN FAMILIES DESCRIPTION{NAME => 'cf', VERSIONS => '1', EVICT_BLOCKS_ON_CLOSE => 'false', NEW_VERSION_BEHAVIOR => 'false', KEEP_DELETED_CELLS => 'FALSE', CACHE_DATA_ON_WRITE => 'false', DATA_BLOCK_ENCODING => 'NONE', TTL => 'FOREVER', MIN_VERSIONS => '0', REPLICATION_SCOPE => '0', BLOOMFILTER => 'ROW', CACHE_INDEX_ON_WRITE => 'false', IN_MEMORY => 'false', CACHE_BLOOMS_ON_WRITE => 'false', PREFETCH_BLOCKS_ON_OPEN => 'false', COMPRESSION => 'NONE', BLOCKCACHE => 'true', BLOCKSIZE => '65536'}1 row(s)Took 0.9998 seconds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> AI/数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据科学 </tag>
            
            <tag> HBase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FTRL</title>
      <link href="/2020/06/04/ftrl/"/>
      <url>/2020/06/04/ftrl/</url>
      
        <content type="html"><![CDATA[<h1 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h1><h2 id="Title"><a href="#Title" class="headerlink" title="Title"></a>Title</h2><pre class="line-numbers language-lang-markdown"><code class="language-lang-markdown">    Follow-the-Regularized-Leader and Mirror Descent: Equivalence Theorems and L1 Regularization<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>【原文】</p><pre class="line-numbers language-lang-markdown"><code class="language-lang-markdown">    We prove that many mirror descent algorithms for online convex optimization (such as online gradient descent) have an equivalent interpretation as follow-the-regularizedleader (FTRL) algorithms. This observation makes the relationships between many commonly used algorithms explicit, and provides theoretical insight on previous experimental observations. In particular, even though the FOBOS composite mirror descent algorithm handles L1 regularization explicitly, it has been observed that the FTRL-style Regularized Dual Averaging (RDA) algorithm is even more e ective at producing sparsity. Our results demonstrate that the key di erence between these algorithms is how they handle the cumulative L1 penalty. While FOBOS handles the L1 term exactly on any given update, we show that it is e ectively using subgradient approximations to the L1 penalty from previous rounds, leading to less sparsity than RDA, which handles the cumulative penalty in closed form. The FTRL-Proximal algorithm, which we introduce, can be seen as a hybrid of these two algorithms, and signi cantly outperforms both on a large, realworld dataset.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>【译文】</p><pre class="line-numbers language-lang-markdown"><code class="language-lang-markdown">    我们证明了许多用于在线凸优化的镜像下降算法（例如在线梯度下降）具有与follow-the-regularizedleader (FTRL)算法等效的解释。该观察使许多常用算法之间的关系变得明确，并提供了对先前实验观察的理论见解。尤其是，即使FOBOS复合镜像下降算法可以明确处理L1正则化，也已经观察到FTRL样式的正则平均化（RDA）算法在产生稀疏性方面更为有效。我们的结果表明，这些算法之间的关键区别在于它们如何处理累积的L1损失。尽管FOBOS可以在任何给定的更新中精确地处理L1项，但我们证明它有效地使用了前几轮对L1罚分的次梯度近似，导致稀疏性低于RDA，后者以封闭形式处理累积罚分。我们介绍的FTRL-Proximal算法可以看作是这两种算法的混合体，在大型的真实数据集上均远胜过两者。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h2><p>【原文】</p><p><img src="/2020/06/04/ftrl/image-20200605145145754.png" alt="image-20200605145145754"></p><p><img src="/2020/06/04/ftrl/image-20200605145210366.png" alt="image-20200605145210366"></p><p>【译文】</p><p>​    我们考虑了在线凸优化的问题及其在在线学习中的应用。 在每一轮中，$t=1,…,T$，我们选择一个点$x_t\in R^n$。 然后揭示了凸损失函数$f_t$以及损失$f_t(x_t)$。在这项工作中，我们研究了在线凸优化的两个最重要且成功的低regret算法家族之间的关系。 从表面上看，诸如Regularized Dual Averaging [Xiao，2009]之类的正规化领导算法与FOBOS [Duchi and Singer，2009]等梯度下降（更普遍的是镜像下降）风格的算法似乎有所不同。 但是，这里我们表明，在二次稳定正则化的情况下，算法之间基本上只有两个区别：</p><p>【原文】</p><p><img src="/2020/06/04/ftrl/image-20200605150118526.png" alt="image-20200605150118526"></p><p>【译文】</p><ul><li>它们如何选择将额外的强凸性用于保证低regret：RDA将正则化集中在原点，而FOBOS将正则化集中在当前可行点。</li><li>它们如何处理任意的非光滑正则化函数。这包括投影到可行集的机制以及如何处理L1正则化。</li></ul><p><img src="/2020/06/04/ftrl/image-20200605150139243.png" alt="image-20200605150139243"></p><p>【译文】</p><p>​    为了使这些区别更精确，同时也说明这些家族实际上是密切相关的，我们考虑第三种算法，FTRL-Proximal。当省略非光滑项时，该算法实际上与FOBOS是相同的。另一方面，其更新与对偶平均的更新基本相同，只是增加的强凸性以当前可行点为中心(见表1)。</p><p>【表1】</p><p><img src="/2020/06/04/ftrl/image-20200605152908088.png" alt="image-20200605152908088"></p><p>【原文】</p><p><img src="/2020/06/04/ftrl/image-20200605150155117.png" alt="image-20200605150155117"></p><p>【译文】</p><p>​    先前的工作已通过实验表明，采用L1正则化进行对偶平均比引入FOBOS更有效地引入稀疏性[Xiao,2009,Duchi et al.,2010a]。我们的等价定理对此提供了理论上的解释：RDA考虑了第t轮的累积L1惩罚$ t\lambda ||x||_1 $，FOBOS（当使用等价定理视为全局优化时）考虑$\phi_{1:t-1}*x+\lambda||x||_1$，其中$\phi_s$是确定的$\lambda||x_s||_1$的次梯度近似（我们用$\phi_{1:t-1}$代表$\sum_{s=1}^{t-1}{\phi_s}$，并根据需要将表示法扩展为矩阵和函数的和）。</p><p>【原文】</p><p><img src="/2020/06/04/ftrl/image-20200605150209723.png" alt="image-20200605150209723"></p><p><img src="/2020/06/04/ftrl/image-20200605150311078.png" alt="image-20200605150311078"></p><p>【译文】</p><p>​    在第2节中，我们考虑了镜像下降和遵循正则化领导的一般公式，并证明了与两者有关的定理。 在第3节中，我们将通过实验比较FOBOS，RDA和FTRL-Proximal。 FTRL-Proximal算法在稀疏性方面的行为与RDA非常相似，认为是L1罚则的累积次梯度近似导致FOBOS稀疏性降低。<br>​    近年来，在线梯度下降和随机梯度下降（其批次模拟）已证明自己是用于大规模机器学习的出色算法。 在最简单的情况下，FTLR-Proximal是相同的，但是当需要L1或其他不平滑的正则化时，FTRL-Proximal的性能明显优于FOBOS，并且也可以优于RDA。 由于FTRL-Proximal和RDA的实现仅需要几行代码，因此我们建议您尝试两者并在实践中选择性能最佳的代码。</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>【原文】</p><p><img src="/2020/06/04/ftrl/image-20200605162626080.png" alt="image-20200605162626080"></p><p>【译文】</p><p>​    我们首先建立符号并更正式地介绍我们考虑的算法。 虽然我们的定理适用于这些算法的更通用版本，但在这里我们集中于我们在实验中使用的特定实例。我们考虑损失函数$f_t(x)=l_t(x)+\Phi(x)$，其中$\Phi(x)$（通常不平滑）是固定的正则化函数。在典型的在线学习环境中，给定一个样本$(\theta_t,y_t)$，$\theta_t \in R^n$是特征向量，$y_t \in \{-1,1\}$是label，我们得到$l_t(x)=loss(\theta_tx,y_t)$。例如，对逻辑回归来说用的是log-loss，$loss(\theta_tx,y_t)=log(1+\exp(-y_t\theta_tx))$。对线性函数我们使用标准规约法，令$g_t=\nabla{l_t(x_t)}$。我们考虑的所有算法都支持复合更新（显示考虑$\Phi$而不是通过梯度$\nabla{f_t(x_t)}$以及可自适应选择的正半定学习率矩阵Q（将这些矩阵解释为学习率将在第2节中有说明））</p><p>【原文】</p><p><img src="/2020/06/04/ftrl/image-20200611093316088.png" alt="image-20200611093316088"><img src="/2020/06/04/ftrl/image-20200611093355502.png" alt="image-20200611093355502"></p><p>【译文】</p><p>​    我们考虑的第一个算法是来自梯度下降家族的<code>FOBOS</code>，如下：</p><script type="math/tex; mode=display">x_{t+1}=\arg_x \min {g_t*x+t\lambda||x||_1+\frac{1}{2}\sum_{s=1}^{t}{||Q_{1:t}^{1/2}(x-x_t)||_2^2}}</script><p>​    我们隐式地将该算法表述为一种优化，但也可以给出一种梯度下降式的封闭形式更新[Duchi和Singer, 2009]。Duchi等人将该算法描述为一种特殊的复合物镜下降(COMID)算法[2010b]。</p><p>​    Xiao[2009]的正则对偶平均算法（<code>RDA</code>）如下：</p><script type="math/tex; mode=display">x_{t+1}=\arg_x \min {g_{1:t}*x+t\lambda||x||_1+\frac{1}{2}\sum_{s=1}^{t}{||Q_s^{1/2}(x-0)||_2^2}}</script><p>​    对比<code>FOBOS</code>，<code>RDA</code>是用累积梯度$g_{1:t}$，而不仅仅是$g_t$。我们将在定理4证明当$\lambda=0$以及$l_t$不是强凸时，该算法（<code>RDA</code>）实际上等价于在线自适应梯度下降法（<code>AOGD</code>）[Bartlett et al., 2007]</p><p>【原文】</p><p><img src="/2020/06/04/ftrl/image-20200622094912113.png" alt="image-20200622094912113"></p><p>【译文】</p><p>​    FTRL-Proximal算法如下：</p><script type="math/tex; mode=display">x_{t+1}=\arg_x \min {g_{1:t}*x+t\lambda||x||_1+\frac{1}{2}\sum_{s=1}^{t}{||Q_s^{1/2}(x-x_s)||_2^2}}</script><p>​    该算法在 [McMahan and Streeter, 2010]的论文中有介绍，但是没有支持显示的$\Phi$，而[McMahan, 2011]证明了处理固定$\Phi$函数的更一般算法的遗憾界</p><p>​    我们的主要贡献之一就是展示了这四种算法之间的紧密联系;表1总结了定理2和定理4的关键结果，以使与RDA和FTRL-Proximal的关系显式的形式编写了AOGD和FOBOS。</p><p>【原文】</p><p><img src="/2020/06/04/ftrl/image-20200702143901089.png" alt="image-20200702143901089"></p><p>【译文】</p><p>​    在我们的分析中，我们将用任意凸函数$R_t$和$\hat{R_t}$来代替上面出现的$\frac{1}{2}||Q_t^{1/2}x||_2^2$和$\frac{1}{2}||Q_t^{1/2}(x-x_t)||_2^2$，同时用任意凸函数$\Phi(x)$代替$\lambda||x||_1$。对这些算法，矩阵$Q_t$被自适应的选择。我们在实验中使用<code>per-coordinate adaptation</code>例如$Q_t$是形如$Q_{1:t}=diag(\hat{\sigma_{t,1}},…,\hat{\sigma_{t,n}})$的对角矩阵，其中$\hat{\sigma_{t,i}}=\frac{1}{\gamma}\sqrt{\sum_{s=1}^t{g_{t,i}^2}}$，详情请见<code>McMahan and Streeter [2010] and Duchi et al. [2010a]</code>。由于所有算法都受益于这种方法，因此即使在大多数情况下以标量学习率引入它们，我们也使用原始算法的更熟悉的名称。 是学习率比例参数，我们在实验中对其进行了调整。</p><p>【原文】</p><p><img src="/2020/06/04/ftrl/image-20200702163652233.png" alt="image-20200702163652233"></p><p>【译文】</p><p><strong>高效的实施度：</strong>所有这些算法都可以有效实施，因为$g_t$的更新能在$O(K)$时间内完成，其中$K$非零。FTRL-Proximal和RDA可以通过存储每个属性的两个积分值，一个二次项和一个线性项来实现（对角学习率）。 当需要$x_{t,i}$时，可以用封闭形式的懒惰式求解（例如参见<code>[Xiao，2009]</code>）。</p><p>对FOBOS来说，更新中$\lambda||x||_1$的存在意味着所有系数$x_{t.i}$（即使在$g_{t,i}=0$时也）需要更新。然而，但是，通过存储$g_{t,i}$不为零的最后一轮的索引<code>t</code>，L1 的一部分更新是懒惰的<code>[Duchi and Singer，2009]</code>。</p><p>【原文】</p><p><img src="/2020/06/04/ftrl/image-20200703161502635.png" alt="image-20200703161502635"></p><p>【译文】</p><p><strong>可行集：</strong> 在某些应用中，我们可能只用来自受限凸可行集$F \sub R^n$的点，例如，图中两个节点之间的路径集。由于我们考虑的所有算法都支持复合更新，因此可以通过选择在$F$上的指标函数$\Phi_F$来选择$\Phi$来完成更新，也就是$\Phi_F(x)=0 , if(x \in F),else(\infty)$。可以直接证明$\arg\min_{x\in R^n}{g_{1:t}x+R_{1:t}(x)+\Phi_F(x)}$等价于$\arg\min_{x\in F}{g_{1:t}x+R_{1:t}(x)}$，并且我们无需明确讨论$F$，而是考虑任意扩展的凸函数，就可以推广特定可行集的结果<code>[McMahanand Streeter, 2010]</code></p><p>【原文】</p><p><img src="/2020/06/04/ftrl/image-20200703171520426.png" alt="image-20200703171520426"></p><p><img src="/2020/06/04/ftrl/image-20200703171600989.png" alt="image-20200703171600989"></p><p>【译文】</p><p>​    我们记$x,y\in R^n$的内积为$x^Ty,or,xy$。$x_{t,i}\in R$表示时间$t$的第$i$个变量。$B$是半正定矩阵，有$||B^{1/2}x||_2^2=x^TBx$。除非另有说明，否则假定凸函数是域$R^n$和范围$R^n\cup\{\infty\}$的扩展。对凸函数$f$，$\partial{f}$表示$f$在$x$上的导数。通过定义，对所有$y$，有$f(y)\ge f(x)+g^T(y-x)$，其中$g\in \partial f(x)$。当$f$可导时，记$\nabla f(x)$为$f$在$x$的导数。这种情况下，$\partial f(x) = \{\nabla f(x)\}$。除非特别指定，不然所有的$mins$和$argmins$都是在$R^n$上。我们经常使用以下标准结果，总结如下：</p><p>【原文】</p><p><img src="/2020/06/04/ftrl/image-20200706145943582.png" alt="image-20200706145943582"></p><p>【译文】</p><p><strong>定理1：</strong>令$R:R^n \rightarrow R$是具有连续一阶偏导数的强凸函数以及令$\Psi:R^n \rightarrow R\cup \{\infty\}$是任意凸函数。定义$g(x)=R(x)+\Psi(x)$。则，存在一个如下等式的唯一对$(x^*,\phi^*)$：</p><script type="math/tex; mode=display">\phi^*\in \partial{\Psi(x^*)} \\x^*=\arg_x\min{R(x)+\phi^*x}\leftrightarrow \nabla R(x^*)+\phi^*=0</script><p>且$x^*$是$g$的唯一最小值。</p><p>【证明】</p><p><img src="/2020/06/04/ftrl/image-20200706152306207.png" alt="image-20200706152306207"></p><p>【译文】</p><p>​    由于$R$是强凸的，所以$g$也是强凸的。则$g$拥有唯一最小值$x^*$。令$r=\nabla R$，则存在$\phi^* \in \partial \Psi(x^*)$使得$r(x^*)+\phi^*=0$（因为这是$0\in \partial g(x^*)$的必要充分条件）。且$x^*=\arg_x\min{R(x)+\phi^*x}$（因为$r(x^*)+\phi^*$是其在$x^*$处的梯度）。假定有另外一组$(x^1,\phi^1)$满足这个定理，即$r(x^{1})+\phi^{1}=0$以及$0 \in \partial g(x^1)$，且$x^1$是$g$的唯一最小值。由于最小值是唯一的，则$x^1=x^*,\phi^1=-r(x^*)=\phi^*$。</p><h2 id="2-MIRROR-DESCENT-FOLLOWS-THE-LEADER"><a href="#2-MIRROR-DESCENT-FOLLOWS-THE-LEADER" class="headerlink" title="2 MIRROR DESCENT FOLLOWS THE LEADER"></a>2 MIRROR DESCENT FOLLOWS THE LEADER</h2><p>【原文】</p><p><img src="/2020/06/04/ftrl/image-20200706155201563.png" alt="image-20200706155201563"></p><p>【译文】</p><p>​    在本节中，我们考虑了镜像下降算法（最简单的示例是在线梯度下降）和FTRL算法之间的关系。令$f_t(x)=g_tx+\Psi(x)$，其中$g_t \in \partial l_t(x_t)$。令$R_1$强凸，所有$R_t$凸。 除非另有说明，否则我们假设$\min_xR_1(x)= 0$，并假设$x = 0$是唯一的最小值。</p><h3 id="FTRL"><a href="#FTRL" class="headerlink" title="FTRL"></a>FTRL</h3><p>【原文】</p><p><img src="/2020/06/04/ftrl/image-20200706160046298.png" alt="image-20200706160046298"></p><p><img src="/2020/06/04/ftrl/image-20200706160105113.png" alt="image-20200706160105113"></p><p><img src="/2020/06/04/ftrl/image-20200706160119257.png" alt="image-20200706160119257"></p><p>【译文】</p><p><strong>FTRL：</strong>最简单的遵循正规领导算法如下：</p><script type="math/tex; mode=display">x_{t+1}=\arg_x\min{g_{1:t}x+\frac{\sigma_{1:t}}{2}||x||_2^2}</script><p>对$t=1$，我们通常取$x_1=0$。我们可以将$\frac{1}{2}||x||_2^2$替换成任意强凸函数$R$，如下：</p><script type="math/tex; mode=display">x_{t+1}=\arg_x\min{g_{1:t}x+\sigma_{1:t}R(x)}</script><p>我们可以为每个$t$独立选择$\sigma_{1:t}$，但是需要它是非减的，因此将其写成每轮增量$\sigma_t \ge 0$的总和是合理的。更一般的更新如下：</p><script type="math/tex; mode=display">x_{t+1}=\arg_x\min{g_{1:t}x+R_{1:t}(x)}</script><p>在每个回合上添加一个额外的凸函数$R_t$。 令$R_t(x)=\sigma_tR(x)$恢复先前的公式(6)。</p><p>​    当$\arg_{x\in R^n}\min{R_t(x)=0}$，我们称函数$R_t$为<strong>origin-centered</strong>。我们还可以定义$FTRL^1$的<strong>proximal</strong>版本，将其他正则化放在当前点而不是原点的中心。在这节，我们保留$R_t$的定义并写出其<strong>origin-centered</strong>函数$\tilde{R}_t(x)=R_t(x-x_t)$。请注意，仅需要$\tilde{R}_t$来选择$x_{t+1}$，并且此时$x_t$是算法已知的，从而确保算法在计算$x_{t+1}$时仅需要访问第一个t损失函数（根据需要）。 一般更新如下：</p><script type="math/tex; mode=display">x_{t+1}=\arg_x\min{g_{1:t}x+\tilde{R}_{1:t}(x)}</script><p>最简单的情形如下：</p><script type="math/tex; mode=display">x_{t+1}=\arg_x\min{g_{1:t}x+\sum_{s=1}^t{\frac{\sigma_s}{2}||x-x_s||_2^2}}</script><h3 id="Mirror-Descent"><a href="#Mirror-Descent" class="headerlink" title="Mirror Descent"></a>Mirror Descent</h3><p>【原文】</p><p><img src="/2020/06/04/ftrl/image-20200706173107216.png" alt="image-20200706173107216"></p><p>【译文】</p><p><strong>Mirror Descent：</strong>最简单的mirror descent版本是以同一步长$\eta$的梯度下降算法，如下：</p><script type="math/tex; mode=display">x_{t+1}=x_t-\eta g_t = -\eta g_{1:t}</script><p>为了得到低惩罚，$T$必须事先知道，以便可以相应的选择$\eta$。但是，由于有一个关于在点$x_{t+1}$上的$g_{1:t}$和$\eta$的封闭形式解决方案，我们将此归纳为一个“revisionist”算法，该算法在每一轮中都扮演着这样的观点：如果在第1到$t-1$轮中使用了步长$\eta_t$，则具有恒定步长的梯度下降将发挥作用。也就是$x_{t+1}=-\eta_tg_{1:t}$。当$R_t(x)=\frac{\sigma_t}{2}||x||_2^2$且$\eta_t=\frac{1}{\sigma_{1:t}}$，这等价于FTRL。</p><p>​    更一般的，我们将对梯度下降算法更感兴趣，该算法使用的自适应步长至少（取决于）轮数$t$。 在每个回合中使用可变步长$t$进行梯度下降如下：</p><script type="math/tex; mode=display">x_{t+1}=x_t-\eta_t g_t</script><p>【原文】</p><p><img src="/2020/06/04/ftrl/image-20200707143210278.png" alt="image-20200707143210278"></p><p>【译文】</p><p>​    这种更新的直觉来自于它可以被重写为如下：</p><script type="math/tex; mode=display">x_{t+1}=\arg_x\min{g_tx+\frac{1}{2\eta_t}||x-x_t||_2^2}</script><p>这个版本抓住了这样一个概念(在线学习术语)，即我们不想过多地改变我们的假设$x_t$(因为害怕对我们已经看到的例子做出错误的预测)，但我们确实想朝着减少我们最近看到的例子的假设损失的方向前进(这是由线性函数$g_t$近似得出的)。</p><p>【原文】</p><p><img src="/2020/06/04/ftrl/image-20200707144406205.png" alt="image-20200707144406205"></p><p>【译文】</p><p>​    镜像下降算法利用了这种直觉，用任意的Bregman离散收敛替换了$L_2$平方惩罚。对于可微的，严格凸的，响应的Bregman散度为：</p><script type="math/tex; mode=display">\Beta_R(x,y)=R(x)-(R(y)+\nabla R(y)*(x-y))</script><p>对任意的$x,y\in R^n$，我们得到以下更新：</p><script type="math/tex; mode=display">x_{t+1}=\arg_x\min{g_tx+\frac{1}{\eta_t}\Beta_R(x,x_t)}</script><p>或者更明确地（通过将（14）的梯度设置为0）：</p><script type="math/tex; mode=display">x_{t+1}=r^{-1}(r(x_t)-\eta_tg_t)</script><p>其中$r=\nabla R$。令$R(x)=\frac{1}{2}||x||_2^2$以使$\Beta_R(x, x_t)=\frac{1}{2}||x-x_t||_2^2$恢复公式（13）的算法。看到这种情况的一种方式是注意在这种情况下$r(x)=r^{-1}(x)=x$。</p><p>【原文】</p><p><img src="/2020/06/04/ftrl/image-20200707151519532.png" alt="image-20200707151519532"></p><p><img src="/2020/06/04/ftrl/image-20200707160925823.png" alt="image-20200707160925823"></p><p>【译文】</p><p>​    我们可以通过在每一轮的Bergman散度中加入一个新的强凸函数$R_t$来进一步推广它。也就是说，让：</p><script type="math/tex; mode=display">\Beta_{1:t}(x,y)=\sum_{s=1}^t{\Beta_{R_s}(x,y)}</script><p>所以更新变成：</p><script type="math/tex; mode=display">x_{t+1}=\arg_x\min{g_tx+\Beta_{1:t}(x,x_t)}</script><p>或等价于$x_{t+1}=(r_{1:t})^{-1}(r_{1:t}(x_t)-g_t)$，其中$r_{1:t}=\sum_{s=1}^t{\nabla R_t}=\nabla R_{1:t}$以及$(r_{1:t})^{-1}$是$r_{1:t}$的反函数。步长$\eta_t$隐藏编码在$R_t$的选择中。</p><p>​    COMID将$\Psi$函数加入每一轮迭代：$f_t(x)=g_tx+\Psi(x)$。然后更新如下：</p><script type="math/tex; mode=display">x_{t+1}=\arg_x\min{\eta g_tx+\Beta(x,x_t)+\eta \Psi(x)}</script><p>可以推广成如下：</p><script type="math/tex; mode=display">x_{t+1}=\arg_x\min{g_tx+\Psi(x)+\Beta_{1:t}(x,x_t)}</script><p>其中学习率$\eta$被定义在$R_1,…,R_t$。如果选择$\Psi$作为凸集上的指标函数，则COMID可通过贪婪投影将标准下降到镜面下降。</p><h3 id="2-1-An-Equivalence-Theorem-for-Proximal-Regularization"><a href="#2-1-An-Equivalence-Theorem-for-Proximal-Regularization" class="headerlink" title="2.1 An Equivalence Theorem for Proximal Regularization"></a>2.1 An Equivalence Theorem for Proximal Regularization</h3><p>【原文】</p><p><img src="/2020/06/04/ftrl/image-20200707161708239.png" alt="image-20200707161708239"></p><p>【译文】</p><p>​    在定理2中，我们表明镜像下降算法可以被视为FTRL算法。</p><p><strong>定理2：</strong>令$R_t$是一组可微分的原点中心凸函数（$\nabla R_t(0)=0$），$R_1$是强凸的，且令$\Psi$是任意凸函数。令$x_1=\hat{x}_1=0$。对一组损失函数$f_t(x)=g_tx+\Psi(x)$，在一组点上的复合目标镜像梯度算法如下：</p><script type="math/tex; mode=display">\hat{x}_{t+1}=\arg_x\min{g_t+\Psi(x)+\tilde{\Beta}_{1:t}(x,\hat{x}_t)}</script><p>其中$\tilde{R}_t(x)=R_t(x-\hat{x}_t)$，以及$\tilde{\Beta}_t=\Beta_{\tilde{R}_t}$，所以$\tilde{\Beta}_{1:t}$是关于$\tilde{R}_1+··+ \tilde{R}_t$的Bregman散度。考虑在另外一组点$x_t$上的FTRL算法，</p><script type="math/tex; mode=display">x_{t+1}=\arg_x\min{(g_{1:t}+\phi_{1:t-1})x+\tilde{R}_{1:t}(x)+\Psi(x)}</script><p>其中$\phi_t\in\partial{\Psi(x_{t+1})}$以致于$g_{1:t}+\phi_{1:t-1}+\nabla{\tilde{R}_{1:t}(x_{t+1})}+\phi_t=0$。那么，这些算法是等价的，即对所有$t&gt;0$，有$x_t=\hat{x}_t$。</p><p>【原文】</p><p><img src="/2020/06/04/ftrl/image-20200707172308338.png" alt="image-20200707172308338"></p><p>【译文】</p><p>​    镜像下降定理中使用的Bregman散度是关于近端函数$\tilde{R}_{1:t}$，而通常(如方程(17))这些函数将不依赖于之前的点发挥。我们将证明当$R_t(x)=\frac{1}{2}||Q_t^{1/2}x||_2^2$时，这些问题将不存在。考虑任意$\Psi$函数也会使定理陈述有些复杂。以下推论回避了这些复杂性，以陈述简单的直接等价结果</p><p><strong>推论3：</strong>令$f_t(x)=g_tx$。然后，以下算法发挥相同的作用：</p><ul><li>使用半正定学习速率$Q_t$的梯度下降算法：<script type="math/tex; mode=display">x_{t+1}=x_t-Q_{1:t}^{-1}{g_t}</script></li></ul><ul><li>FTRL算法</li></ul><script type="math/tex; mode=display">x_{t+1}=\arg_x\min{g_{1:t}x+\tilde{R}_{1:t}(x)}\\\tilde{R}_t(x)=\frac{1}{2}||Q_t^{1/2}(x-x_t)||_2^2</script><hr><h1 id="工程实现"><a href="#工程实现" class="headerlink" title="工程实现"></a>工程实现</h1>]]></content>
      
      
      <categories>
          
          <category> AI/数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据科学 </tag>
            
            <tag> 读书笔记 </tag>
            
            <tag> Optimization Method </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>google-MapReduce</title>
      <link href="/2020/06/03/google-mapreduce/"/>
      <url>/2020/06/03/google-mapreduce/</url>
      
        <content type="html"><![CDATA[<h1 id="Title"><a href="#Title" class="headerlink" title="Title"></a>Title</h1><p><img src="/2020/06/03/google-mapreduce/image-20200603093104618.png" alt="image-20200603093104618"></p><p>【译文】</p><ul><li>MapReduce：大型集群上的简化数据处理</li></ul><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>【原文】</p><pre class="line-numbers language-lang-markdown"><code class="language-lang-markdown">    MapReduce is a programming model and an associated implementation for processing and generating large data sets. Users specify a map function that processes a key/value pair to generate a set of intermediate key/value pairs, and a reduce function that merges all intermediate values associated with the same intermediate key. Many real world tasks are expressible in this model, as shown in the paper.    Programs written in this functional style are automatically parallelized and executed on a large cluster of commodity machines. The run-time system takes care of the details of partitioning the input data, scheduling the program’s execution across a set of machines, handling machine failures, and managing the required inter-machine communication. This allows programmers without any experience with parallel and distributed systems to easily utilize the resources of a large distributed system.    Our implementation of MapReduce runs on a large cluster of commodity machines and is highly scalable: a typical MapReduce computation processes many terabytes of data on thousands of machines. Programmers find the system easy to use: hundreds of MapReduce programs have been implemented and upwards of one thousand MapReduce jobs are executed on Google’s clusters every day.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【译文】</p><pre class="line-numbers language-lang-markdown"><code class="language-lang-markdown">    MapReduce是用于处理和生成大数据集的编程模型（相关的实现）。 用户指定key\value对以生成一组中间key\value对的map函数，以及指定归纳与同一中间key\value关联的所有中间key\value的reduce函数。 如本文所示，许多现实世界的任务在这种模型中都是可以表达的。    用这种函数式编写的程序会自动并行化，并在大型计算机集群上执行。运行时系统负责对输入数据进行分区、安排跨机器的程序执行、处理机器故障和管理所需的机器间通信等细节。这使得没有任何并行和分布式系统经验的程序员可以轻松地利用大型分布式系统的资源。    我们的MapReduce实现运行在大量的普通机器上，并且具有高度的可伸缩性:典型的MapReduce计算在数千台机器上处理许多TB级的数据。程序员发现这个系统很容易使用:已经实现了数百个MapReduce程序，每天在谷歌集群上执行的MapReduce任务都超过1000个。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【重点】</p><ul><li>MapReduce是用于处理和生成大数据集的编程模型（相关的实现）</li><li>包含map函数和reduce函数，使用key\value对</li><li>高度的可伸缩性</li></ul><h2 id="1、Introduction"><a href="#1、Introduction" class="headerlink" title="1、Introduction"></a>1、Introduction</h2><p>【原文】</p><pre class="line-numbers language-lang-markdown"><code class="language-lang-markdown">    Over the past five years, the authors and many others at Google have implemented hundreds of special-purpose computations that process large amounts of raw data, such as crawled documents, web request logs, etc., to compute various kinds of derived data, such as inverted indices, various representations of the graph structure of web documents, summaries of the number of pages crawled per host, the set of most frequent queries in a given day, etc. Most such computations are conceptually straightforward. However, the input data is usually large and the computations have to be distributed across hundreds or thousands of machines in order to finish in a reasonable amount of time. The issues of how to parallelize the computation, distribute the data, and handle failures conspire to obscure the original simple computation with large amounts of complex code to deal with these issues.    As a reaction to this complexity, we designed a new abstraction that allows us to express the simple computations we were trying to perform but hides the messy details of parallelization, fault-tolerance, data distribution and load balancing in a library. Our abstraction is inspired by the map and reduce primitives present in Lisp and many other functional languages. We realized that most of our computations involved applying a map operation to each logical “record” in our input in order to compute a set of intermediate key/value pairs, and then applying a reduce operation to all the values that shared the same key, in order to combine the derived data appropriately. Our use of a functional model with userspecified map and reduce operations allows us to parallelize large computations easily and to use re-execution as the primary mechanism for fault tolerance.    The major contributions of this work are a simple and powerful interface that enables automatic parallelization and distribution of large-scale computations, combined with an implementation of this interface that achieves high performance on large clusters of commodity PCs.    Section 2 describes the basic programming model and gives several examples. Section 3 describes an implementation of the MapReduce interface tailored towards our cluster-based computing environment. Section 4 describes several refinements of the programming model that we have found useful. Section 5 has performance measurements of our implementation for a variety of tasks. Section 6 explores the use of MapReduce within Google including our experiences in using it as the basis for a rewrite of our production indexing system. Section 7 discusses related and future work.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【译文】</p><pre class="line-numbers language-lang-markdown"><code class="language-lang-markdown">    在过去的五年中，Google的作者和许多其他人已经实现了数百种特殊用途的计算，这些计算处理大量的原始数据（例如抓取的文档，Web请求日志等），以计算各种派生数据，例如：作为反向索引，Web文档的图形结构的各种表示形式，每个主机爬取的网页摘要，给定一天中最频繁的查询集等。大多数此类计算在概念上都很简单。 但是，输入数据通常很大，并且必须在数百或数千台计算机上分布计算，才能在合理的时间内完成计算。 如何并行化计算，分配数据和处理故障的问题，用大量复杂的代码来处理这些问题，使原来简单的计算变得模糊不清。    为了应对这种复杂性，我们设计了一个新的抽象，该抽象使我们能够表达我们试图执行的简单计算，但在库中隐藏了并行化，容错，数据分发和负载平衡的混乱细节。 Lisp和许多其他功能语言中的map和reduce原语启发了我们的抽象。 我们意识到，大多数计算都涉及对输入中的每个逻辑“记录”应用映射操作，以便计算一组key/value键/值对，然后对共享同一key的所有值应用归约操作，适当地组合得出的数据。我们使用具有用户指定的映射和归约运算的功能模型，使我们能够轻松地并行进行大型计算，并将重新执行用作容错的主要机制。    这项工作的主要贡献是一个简单而强大的界面，该界面可实现大规模计算的自动并行化和分配，并结合了该界面的实现，可在大型商用PC集群上实现高性能。    第2节描述了基本的编程模型，并给出了一些示例。 第3节介绍了针对我们基于集群的计算环境量身定制的MapReduce接口的实现。 第4节描述了一些有用的编程模型改进。 第5节对我们执行各种任务的性能进行了度量。 第6节探讨了MapReduce在Google中的用法，包括我们使用它作为重写生产索引系统基础的经验。 第7节讨论相关和未来的工作。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Google Three Papers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据科学 </tag>
            
            <tag> Hadoop </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flask</title>
      <link href="/2020/05/18/flask/"/>
      <url>/2020/05/18/flask/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.w3cschool.cn/flask/" target="_blank" rel="noopener">参考链接</a></p><p><a href="https://www.yiibai.com/flask" target="_blank" rel="noopener">参考链接2</a>——比较靠谱</p>]]></content>
      
      
      <categories>
          
          <category> AI/数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据科学 </tag>
            
            <tag> web服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>金字塔原理读书笔记</title>
      <link href="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/"/>
      <url>/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="第一篇：表达的逻辑"><a href="#第一篇：表达的逻辑" class="headerlink" title="第一篇：表达的逻辑"></a>第一篇：表达的逻辑</h1><ul><li>口头沟通能力</li><li>培训讲课能力</li><li>演讲能力</li><li>书面沟通能力</li><li>写作能力</li></ul><h2 id="第1章：为什么要用金字塔结构"><a href="#第1章：为什么要用金字塔结构" class="headerlink" title="第1章：为什么要用金字塔结构"></a>第1章：为什么要用金字塔结构</h2><p><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/eg1.jpg" alt="例子1"></p><h3 id="人类思维的基本规律"><a href="#人类思维的基本规律" class="headerlink" title="人类思维的基本规律"></a>人类思维的基本规律</h3><ul><li>大脑自动将信息归纳到金字塔结构的各组中，以便于理解和记忆</li><li>预先归纳到金字塔结构中的沟通内容，都更容易被人理解和记忆</li><li>应该有意将沟通内容组织成金字塔结构，包括口头和书面表达</li><li>==大脑的两个需求——只有金字塔结构满足==<ul><li>一次记忆不超过7个思想、概念或项目</li><li>自动寻找分析文章逻辑关系</li></ul></li></ul><h2 id="第2章：金字塔内部结构"><a href="#第2章：金字塔内部结构" class="headerlink" title="第2章：金字塔内部结构"></a>第2章：金字塔内部结构</h2><h3 id="纵向关系"><a href="#纵向关系" class="headerlink" title="纵向关系"></a>纵向关系</h3><h3 id="横向关系"><a href="#横向关系" class="headerlink" title="横向关系"></a>横向关系</h3><p>$\beta$</p><h3 id="单一思想统领的金字塔结构"><a href="#单一思想统领的金字塔结构" class="headerlink" title="单一思想统领的金字塔结构"></a>单一思想统领的金字塔结构</h3><p><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/eg2.jpg" alt="例子2"></p><h2 id="第3章：如何构建金字塔"><a href="#第3章：如何构建金字塔" class="headerlink" title="第3章：如何构建金字塔"></a>第3章：如何构建金字塔</h2><h3 id="归类分组，将思想组织成金字塔"><a href="#归类分组，将思想组织成金字塔" class="headerlink" title="归类分组，将思想组织成金字塔"></a>归类分组，将思想组织成金字塔</h3><h3 id="自上而下表达，结论先行"><a href="#自上而下表达，结论先行" class="headerlink" title="自上而下表达，结论先行"></a>自上而下表达，结论先行</h3><h3 id="自下而上思考，总结概括"><a href="#自下而上思考，总结概括" class="headerlink" title="自下而上思考，总结概括"></a>自下而上思考，总结概括</h3><h3 id="初学者注意事项"><a href="#初学者注意事项" class="headerlink" title="初学者注意事项"></a>初学者注意事项</h3><h3 id="梳理思想"><a href="#梳理思想" class="headerlink" title="梳理思想"></a>梳理思想</h3><ul><li>不要一坐下来就开始将思想往金字塔结构里面套</li><li>而是应该先梳理你想要表达的思想</li><li>为了吸引读者的全部注意力，你必须在做好回答问题的准备之前，==避免引起读者的疑问==；也必须在引起读者疑问之前，避免先给出对该问题的答案</li></ul><h5 id="金字塔思想的关联方式"><a href="#金字塔思想的关联方式" class="headerlink" title="金字塔思想的关联方式"></a>金字塔思想的关联方式</h5><h6 id="纵向：文章中任一层次上的思想必须是其下一层次思想的概括"><a href="#纵向：文章中任一层次上的思想必须是其下一层次思想的概括" class="headerlink" title="纵向：文章中任一层次上的思想必须是其下一层次思想的概括"></a>纵向：文章中任一层次上的思想必须是其下一层次思想的概括</h6><ul><li>向上</li><li>向下</li></ul><h6 id="横向"><a href="#横向" class="headerlink" title="横向"></a>横向</h6><ul><li>每组思想必须属于同一逻辑范畴</li><li>每组思想必须按逻辑顺序组织，具体的顺序取决于该组思想的逻辑关系是==演绎推理关系还是归纳推理关系==</li><li>演绎推理与归纳推理的区别如下图</li><li>演绎推理的3个步骤<ul><li>阐述世界上已存在的某种情况</li><li>阐述世界上同时存在的相关情况。如果第二个表述是针对第一个表述的主语或者谓语，则说明两个表述相关</li><li>说明这两个表述同时存在时隐含的意义</li></ul></li><li>归纳推理的步骤<ul><li>找到一个能够表示该组所有思想共同点的名词，即正确定义该组思想</li><li>识别并剔除不属该组，不具有共同点的思想</li></ul></li></ul><p><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/eg10.jpg" alt="区别"></p><h4 id="组织思想的逻辑顺序"><a href="#组织思想的逻辑顺序" class="headerlink" title="组织思想的逻辑顺序"></a>组织思想的逻辑顺序</h4><h5 id="演绎关系"><a href="#演绎关系" class="headerlink" title="演绎关系"></a>演绎关系</h5><ul><li>大前提</li><li>小前提</li><li>结论</li></ul><h5 id="归纳关系"><a href="#归纳关系" class="headerlink" title="归纳关系"></a>归纳关系</h5><h6 id="时间顺序：确定前因后果关系，代表一个过程或系统的一组行为"><a href="#时间顺序：确定前因后果关系，代表一个过程或系统的一组行为" class="headerlink" title="时间顺序：确定前因后果关系，代表一个过程或系统的一组行为"></a>时间顺序：确定前因后果关系，代表一个过程或系统的一组行为</h6><ul><li>根据结果找原因，区分原因和结果</li><li>结果<ul><li>第一（原因）</li><li>第二</li><li>第三</li></ul></li><li>揭示隐含的逻辑思路</li><li>在按照时间顺序组织的思想组中，你要按照采取行动的顺序（第一步、第二步、第三步）依次表述达到某一个结果必须采取的行动</li></ul><h6 id="空间顺序：将整体分割成部分，或将部分组成整体"><a href="#空间顺序：将整体分割成部分，或将部分组成整体" class="headerlink" title="空间顺序：将整体分割成部分，或将部分组成整体"></a>空间顺序：将整体分割成部分，或将部分组成整体</h6><ul><li>结构顺序就是当你使用示意图、地图、图画或照片想象某事务时的顺序</li><li>创建逻辑结构<ul><li>各部分之间相互独立，没有重叠，有排他性</li><li>所有部分完全穷尽，没有遗漏</li></ul></li><li>划分组织活动的方式<ul><li>根据活动本身（研发、生产、市场）</li><li>根据活动发生地点（国家东部、国家中西部）</li><li>根据针对特定产品、市场或客户活动的集合（各事业部、各业务单元）</li></ul></li><li>描述逻辑结构<ul><li>自上而下</li><li>自作而右</li></ul></li><li>修改逻辑结构</li><li>用结构顺序概念检查思路</li><li>地图<ul><li>北京</li><li>上海</li><li>广州</li><li>深圳</li></ul></li></ul><h6 id="重要性顺序：将类似事务按重要性归为一组"><a href="#重要性顺序：将类似事务按重要性归为一组" class="headerlink" title="重要性顺序：将类似事务按重要性归为一组"></a>重要性顺序：将类似事务按重要性归为一组</h6><ul><li>明确指明每组中的项目具有共同特性，确保将所有具有该特性的项目列入该组</li><li>在每组中，根据各个问题具有该特性的高低排序——最具有该特性的问题排第一，先强后弱，先重要后次要</li><li>创建适当的分组</li><li>最重要</li><li>次重要</li><li>不重要</li></ul><h3 id="自上而下法"><a href="#自上而下法" class="headerlink" title="自上而下法"></a>自上而下法</h3><p><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/eg3.jpg" alt="自上而下搭建步骤"></p><h4 id="画出主题方框——提出主题思想"><a href="#画出主题方框——提出主题思想" class="headerlink" title="画出主题方框——提出主题思想"></a>画出主题方框——提出主题思想</h4><ul><li>要讨论什么主题，知道则填入，不知道则到步骤2</li></ul><h4 id="设想主要疑问——设想受众的主要疑问"><a href="#设想主要疑问——设想受众的主要疑问" class="headerlink" title="设想主要疑问——设想受众的主要疑问"></a>设想主要疑问——设想受众的主要疑问</h4><ul><li>确定文章的读者，将面对哪些对象</li><li>希望回答关于主题的哪些疑问，没有则到步骤4</li></ul><h4 id="写出对该疑问的回答——写序言：背景、冲突、疑问、回答"><a href="#写出对该疑问的回答——写序言：背景、冲突、疑问、回答" class="headerlink" title="写出对该疑问的回答——写序言：背景、冲突、疑问、回答"></a>写出对该疑问的回答——写序言：背景、冲突、疑问、回答</h4><ul><li>如果写不出，则注明有能力回答该疑问</li></ul><h4 id="说明“背景”"><a href="#说明“背景”" class="headerlink" title="说明“背景”"></a>说明“背景”</h4><ul><li>把要讨论的主题与“背景”相结合，作出关于该主题的第一个不会引起争议的表述</li></ul><h4 id="指出“冲突”——与受众进行疑问-回答式对话"><a href="#指出“冲突”——与受众进行疑问-回答式对话" class="headerlink" title="指出“冲突”——与受众进行疑问/回答式对话"></a>指出“冲突”——与受众进行疑问/回答式对话</h4><ul><li>进行疑问/回答式对话</li><li>考虑“背景”中发生了哪些能使读者产生疑问的“冲突”</li><li>例如发生了读者不知道的意外，出现了某个问题等</li></ul><h4 id="检查“主要疑问”和“答案”——重复进行疑问-回答式对话"><a href="#检查“主要疑问”和“答案”——重复进行疑问-回答式对话" class="headerlink" title="检查“主要疑问”和“答案”——重复进行疑问/回答式对话"></a>检查“主要疑问”和“答案”——重复进行疑问/回答式对话</h4><ul><li>对“背景”中“冲突”的介绍，应当直接导致读者提出主要疑问</li><li>否则应该重新介绍“背景”中的“冲突”，使之可以直接导致读者提出主要疑问</li></ul><h3 id="自下而上法"><a href="#自下而上法" class="headerlink" title="自下而上法"></a>自下而上法</h3><ul><li>列出你想表达的所有思想要点</li><li>找出各要点之间的逻辑关系</li><li>得出结论</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>一定先搭结构，先尝试自上而下法</li><li>序言先写背景，将背景作为序言的起点</li><li>先多花时间思考序言，不要省略</li><li>将历史背景放在序言中</li><li>序言仅涉及读者不会对其真实性提出质疑的内容</li><li>在关键句层次上，更宜选择归纳推理法而非演绎论证法</li></ul><h2 id="第4章：序言的结构以及如何写"><a href="#第4章：序言的结构以及如何写" class="headerlink" title="第4章：序言的结构以及如何写"></a>第4章：序言的结构以及如何写</h2><h3 id="序言的结构"><a href="#序言的结构" class="headerlink" title="序言的结构"></a>序言的结构</h3><h3 id="序言如何写"><a href="#序言如何写" class="headerlink" title="序言如何写"></a>序言如何写</h3><h3 id="序言的常见模式"><a href="#序言的常见模式" class="headerlink" title="序言的常见模式"></a>序言的常见模式</h3><ul><li>为什么序言必须是将故事？<ul><li>让读者抛开复杂的思想，专注于你的文章</li><li>引起读者的兴趣，吸引注意力</li></ul></li><li>为什么序言必须是读者已知的信息？<ul><li>这样才不会让读者产生质疑</li></ul></li></ul><h3 id="序言的结构-1"><a href="#序言的结构-1" class="headerlink" title="序言的结构"></a>序言的结构</h3><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><p><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/eg4.jpg" alt="冲突"></p><ul><li>背景（S）<ul><li>何时引入？</li><li>在你能够作出关于文章主题独立、无争议的表述的时候</li><li>所有引出“背景”的句子都能锁定在特定的时间和空间</li></ul></li><li>冲突（C）<ul><li>能够促使读者提出“疑问”的即是冲突</li><li>推动故事情节发展</li></ul></li><li>疑问（Q）</li><li>回答（A）——关键句要点<ul><li>不仅要回答==文章主题思想==引起读者的疑问</li><li>还要呈现文章的框架结构</li><li>然后本章开始以关键句要点一章一章的讲述——同样采取背景+冲突+回答的格式</li></ul></li></ul><p><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/eg5.jpg" alt="序言结构"></p><h4 id="基本结构引出的形式"><a href="#基本结构引出的形式" class="headerlink" title="基本结构引出的形式"></a>基本结构引出的形式</h4><ul><li>标准式：背景——冲突——答案</li><li>开门见山式：答案——背景——冲突</li><li>突出忧虑式：冲突——背景——答案</li><li>突出信心式：疑问——背景——冲突——答案</li></ul><h3 id="好序言的原则"><a href="#好序言的原则" class="headerlink" title="好序言的原则"></a>好序言的原则</h3><ul><li>序言的目的是==提示==读者而不是==告诉==读者某些信息<ul><li>不应该含有读者需要证明后才能接受的信息</li><li>不应当含有图表</li></ul></li><li>序言必须包含讲故事的3个要素+背景+冲突+答案</li><li>序言的长度取决于读者和主题的需要</li></ul><h3 id="序言的常见模式-1"><a href="#序言的常见模式-1" class="headerlink" title="序言的常见模式"></a>序言的常见模式</h3><h4 id="发出指示式"><a href="#发出指示式" class="headerlink" title="发出指示式"></a>发出指示式</h4><p><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/eg6.jpg" alt="发出指示式"></p><h4 id="请求支持式"><a href="#请求支持式" class="headerlink" title="请求支持式"></a>请求支持式</h4><p><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/eg7.jpg" alt="请求支持式"></p><h4 id="解释做法式"><a href="#解释做法式" class="headerlink" title="解释做法式"></a>解释做法式</h4><p><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/eg8.jpg" alt="解释做法式"></p><h4 id="比较选择式"><a href="#比较选择式" class="headerlink" title="比较选择式"></a>比较选择式</h4><p><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/eg9.jpg" alt="比较选择式"></p><h2 id="第5章：演绎推理与归纳推理"><a href="#第5章：演绎推理与归纳推理" class="headerlink" title="第5章：演绎推理与归纳推理"></a>第5章：演绎推理与归纳推理</h2><h3 id="演绎推理"><a href="#演绎推理" class="headerlink" title="演绎推理"></a>演绎推理</h3><h3 id="归纳推理"><a href="#归纳推理" class="headerlink" title="归纳推理"></a>归纳推理</h3><h3 id="它们的区别"><a href="#它们的区别" class="headerlink" title="它们的区别"></a>它们的区别</h3><h1 id="第二篇：思考的逻辑"><a href="#第二篇：思考的逻辑" class="headerlink" title="第二篇：思考的逻辑"></a>第二篇：思考的逻辑</h1><ul><li>如何才能从原文罗列的信息，整理出修改后罗列的结论呢？</li><li>本篇将讨论有关的实用技巧</li><li>这个过程称为==冷静思考==</li></ul><h2 id="第6章：应用逻辑顺序"><a href="#第6章：应用逻辑顺序" class="headerlink" title="第6章：应用逻辑顺序"></a>第6章：应用逻辑顺序</h2><p><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/eg11.jpg" alt="大脑归纳分析活动"></p><h2 id="第7章：概括各组思想"><a href="#第7章：概括各组思想" class="headerlink" title="第7章：概括各组思想"></a>第7章：概括各组思想</h2><ul><li>概括各组思想</li><li>确保思想属于同一组，应抽象、提炼、概括思想精华</li><li><p>总结句避免使用“缺乏思想”的句子，总结句应该包含概括的思想</p><ul><li>例如：该公司存在2个问题</li></ul></li><li><p>思想的表达方式可以是==行动性语句==，即告诉读者什么事，也可以是==描述性语句==，即告诉读者关于某些事的情况</p><ul><li><p>概括行动性思想（介绍采取的行动、行为、步骤、流程）时，应说明采取行动后取得的“结果”（效果、达到的目标）</p><ul><li>在将各行动（步骤、流程等）联系起来之前，先用明确的语句描述各行动</li><li>找出明显的因果关系组合，尽量将每一组中的行动、步骤控制在5个以下<ul><li>区分行动步骤的层次<br><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/eg12.jpg" alt="区分层次"></li></ul></li><li>直接从这些行动、步骤、流程，总结、概括行动的结果、目标</li></ul></li><li><p>概括描述性思想（介绍背景、信息）时，应该说明这些思想具有的“共同点的含义”</p></li></ul></li></ul><h3 id="了解某一组思想真正想表达的思想观点"><a href="#了解某一组思想真正想表达的思想观点" class="headerlink" title="了解某一组思想真正想表达的思想观点"></a>了解某一组思想真正想表达的思想观点</h3><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ul><li>确定该组思想的类型（类别）</li><li>将同一类别的思想归类、分组</li><li>找出各类别思想之间的顺序</li></ul><h3 id="总结句避免使用“缺乏思想”的句子"><a href="#总结句避免使用“缺乏思想”的句子" class="headerlink" title="总结句避免使用“缺乏思想”的句子"></a>总结句避免使用“缺乏思想”的句子</h3><h3 id="总结句要说明行动产生的结果-目标"><a href="#总结句要说明行动产生的结果-目标" class="headerlink" title="总结句要说明行动产生的结果/目标"></a>总结句要说明行动产生的结果/目标</h3><h3 id="找出各结论之间的共性"><a href="#找出各结论之间的共性" class="headerlink" title="找出各结论之间的共性"></a>找出各结论之间的共性</h3><h1 id="第三篇：解决问题的逻辑"><a href="#第三篇：解决问题的逻辑" class="headerlink" title="第三篇：解决问题的逻辑"></a>第三篇：解决问题的逻辑</h1><h2 id="第8章：界定问题"><a href="#第8章：界定问题" class="headerlink" title="第8章：界定问题"></a>第8章：界定问题</h2><ul><li>“问题”是指你不喜欢某一结果-非期望结果R1（比如销售额降低），想得到其他结果-期望结果R2（比如销售额增长）</li><li>解决方案则是指如何从现状R1到目标R2</li></ul><ol><li>界定问题的框架</li><li>展开问题的各要素</li><li>发掘读者的疑问</li><li>开始写序言</li><li>实战案例</li></ol><h3 id="界定问题的框架"><a href="#界定问题的框架" class="headerlink" title="界定问题的框架"></a>界定问题的框架</h3><h4 id="展开说明框架中的各要素"><a href="#展开说明框架中的各要素" class="headerlink" title="展开说明框架中的各要素"></a>展开说明框架中的各要素</h4><ul><li>界定问题的框架需要回答3个问题<ul><li>发生了什么事情？（背景【切入点+困扰】）</li><li>我们不喜欢它什么？（非期望结果R1）</li><li>我们想要什么？（期望结果R2）</li></ul></li></ul><h4 id="把“界定的问题”写成序言"><a href="#把“界定的问题”写成序言" class="headerlink" title="把“界定的问题”写成序言"></a>把“界定的问题”写成序言</h4><ul><li>界定问题的框架可以遵循以下5个步骤<ul><li>展开问题的基本部分</li><li>你的解决方案处于哪一阶段（已经提出了，还是已经被接受了）</li><li>提出适当的疑问</li><li>检查序言是否呈现了界定的问题</li><li>检查金字塔是否回答了疑问</li></ul></li></ul><h3 id="展开问题的各要素"><a href="#展开问题的各要素" class="headerlink" title="展开问题的各要素"></a>展开问题的各要素</h3><ul><li>确定以下4个要素才能界定问题<ul><li>切入点/序幕</li><li>困扰/困惑</li><li>现状，非期望结果</li><li>目标，期望结果</li></ul></li></ul><h4 id="切入点-序幕"><a href="#切入点-序幕" class="headerlink" title="切入点/序幕"></a>切入点/序幕</h4><ul><li>设想自己静静的坐在一个黑暗的剧场里。大幕拉开，舞台布景描绘的是某一特定时刻的某一特定地点，这就是切入点或序幕</li><li>在序幕阶段，尽量作简单的设想和简短的描述，等到写序言时再展开</li></ul><h4 id="困扰-困惑"><a href="#困扰-困惑" class="headerlink" title="困扰/困惑"></a>困扰/困惑</h4><ul><li>某一事件的发生使剧情得以展开，并引发了非期望结果R1，这就是困扰/困惑</li><li>产生的原因有以下3种<ul><li>外部原因</li><li>内部原因</li><li>近期认识到的其他原因</li></ul></li></ul><h4 id="R1（现状、非期望结果）"><a href="#R1（现状、非期望结果）" class="headerlink" title="R1（现状、非期望结果）"></a>R1（现状、非期望结果）</h4><ul><li>R1是指读者需要设法解决或有可能面临的问题，或者是有可能抓住的机会</li><li>困扰带来的R1可能不止一个，可以在示意图里尽可能简短的文字加以说明</li></ul><h4 id="R2（目标，期望结果）"><a href="#R2（目标，期望结果）" class="headerlink" title="R2（目标，期望结果）"></a>R2（目标，期望结果）</h4><ul><li>对R2准确到位的描述，可以用具体的数字，也可以用具体的最终结果</li><li>有时你可能无法具体描述R2的最终结果，或者根本不能描述，这种情况，只需在R2部分写：如果问题得到解决，你希望达到的状态</li></ul><h3 id="发掘读者的疑问"><a href="#发掘读者的疑问" class="headerlink" title="发掘读者的疑问"></a>发掘读者的疑问</h3><ul><li>展开问题的基本内容后，下一步就是寻找读者的疑问</li></ul><p><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/eg13.jpg" alt="读者希望解决的问题大概"></p><h3 id="开始写序言"><a href="#开始写序言" class="headerlink" title="开始写序言"></a>开始写序言</h3><ul><li>针对上图7种问题，写出不同的序言</li></ul><h4 id="1、我们应该做什么"><a href="#1、我们应该做什么" class="headerlink" title="1、我们应该做什么"></a>1、我们应该做什么</h4><p><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/eg14.jpg" alt="1"></p><h4 id="2、我们是否应该做我们想做的事"><a href="#2、我们是否应该做我们想做的事" class="headerlink" title="2、我们是否应该做我们想做的事"></a>2、我们是否应该做我们想做的事</h4><p><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/eg14.jpg" alt="2"></p><h4 id="3、我们应该如何做我们想做的事"><a href="#3、我们应该如何做我们想做的事" class="headerlink" title="3、我们应该如何做我们想做的事"></a>3、我们应该如何做我们想做的事</h4><p><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/eg16.jpg" alt="3"></p><h4 id="4、解决方案行不通，我们应该做什么"><a href="#4、解决方案行不通，我们应该做什么" class="headerlink" title="4、解决方案行不通，我们应该做什么"></a>4、解决方案行不通，我们应该做什么</h4><p><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/eg17.jpg" alt="4"></p><h4 id="5、我们应该选哪种方案"><a href="#5、我们应该选哪种方案" class="headerlink" title="5、我们应该选哪种方案"></a>5、我们应该选哪种方案</h4><p><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/eg18.jpg" alt="5"></p><h4 id="6、我们应该采用哪些战略"><a href="#6、我们应该采用哪些战略" class="headerlink" title="6、我们应该采用哪些战略"></a>6、我们应该采用哪些战略</h4><p><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/eg19.jpg" alt="6"></p><h4 id="7、我们存在问题吗"><a href="#7、我们存在问题吗" class="headerlink" title="7、我们存在问题吗"></a>7、我们存在问题吗</h4><p><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/eg20.jpg" alt="7"></p><h3 id="实战案例"><a href="#实战案例" class="headerlink" title="实战案例"></a>实战案例</h3><p><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/eg21.jpg" alt="8"></p><p><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/eg22.jpg" alt="9"></p><h2 id="第9章：结构化分析问题"><a href="#第9章：结构化分析问题" class="headerlink" title="第9章：结构化分析问题"></a>第9章：结构化分析问题</h2><ul><li>分析问题的标准流程：<ol><li>收集信息</li><li>描述发现</li><li>得出结论</li><li>提出方案</li></ol></li></ul><h3 id="从信息资料入手-一般的方法"><a href="#从信息资料入手-一般的方法" class="headerlink" title="从信息资料入手-一般的方法"></a>从信息资料入手-一般的方法</h3><ul><li>不论客户存在什么问题，都从全公司或全行业分析入手</li><li>收集大量资料再进行分析会耗费大量的时间和金钱</li></ul><h3 id="设计诊断框架-作者提出的结构化分析方法"><a href="#设计诊断框架-作者提出的结构化分析方法" class="headerlink" title="设计诊断框架-作者提出的结构化分析方法"></a>设计诊断框架-作者提出的结构化分析方法</h3><ul><li>结构化分析的方法有3种<ol><li>呈现有形的结构</li><li>寻找因果关系和归类分组</li><li>为了找出产生问题的原因</li></ol></li></ul><h4 id="呈现有形的结构"><a href="#呈现有形的结构" class="headerlink" title="呈现有形的结构"></a>呈现有形的结构</h4><ul><li>任何一家企业或行业的具体领域都应该有清晰的结构</li><li>即包括由不同单位组成的系统，各自完成特定的功能</li><li>画一幅系统的现况或理想状况的图，帮助你分析和解决问题</li></ul><p><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/eg23.jpg" alt="行业业务流程"></p><h4 id="寻找因果关系"><a href="#寻找因果关系" class="headerlink" title="寻找因果关系"></a>寻找因果关系</h4><ul><li>诊断问题的第二种方法是寻找具有因果关系的要素，行为或任务，得出诊断结果</li></ul><h4 id="将产生问题的可能原因分类"><a href="#将产生问题的可能原因分类" class="headerlink" title="将产生问题的可能原因分类"></a>将产生问题的可能原因分类</h4><ul><li>第三种方法是将所有可能的原因按相似性分类</li></ul><h3 id="使用诊断框架"><a href="#使用诊断框架" class="headerlink" title="使用诊断框架"></a>使用诊断框架</h3><h3 id="建立逻辑树"><a href="#建立逻辑树" class="headerlink" title="建立逻辑树"></a>建立逻辑树</h3><ul><li>逻辑树可以解决我们能做什么？我们应该做什么的问题</li><li>使用逻辑树可以从逻辑上找出解决问题的可能方案</li><li>用逻辑树展示各组活动的组与组之间的相互关系的方法，也可以进行逻辑分析，找出各组思想的缺陷</li></ul><h3 id="是非问题分析"><a href="#是非问题分析" class="headerlink" title="是非问题分析"></a>是非问题分析</h3><ul><li>建立诊断框架的过程有时候被称为“是非问题分析”。但是“是非问题分析”一词广义上指几乎所有的逻辑树</li></ul><h1 id="第四篇：演示的逻辑"><a href="#第四篇：演示的逻辑" class="headerlink" title="第四篇：演示的逻辑"></a>第四篇：演示的逻辑</h1><h2 id="第10章：在书面上呈现金字塔"><a href="#第10章：在书面上呈现金字塔" class="headerlink" title="第10章：在书面上呈现金字塔"></a>第10章：在书面上呈现金字塔</h2><p>写长篇文章时，在页面上呈现金字塔层级的方法很多，常见的有：</p><ol><li>多级标题法</li><li>下划线法</li><li>数字编号法</li><li>行首缩进法</li><li>项目符号法</li></ol><p><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/eg24.jpg" alt="多级标题"></p><h3 id="突出显示文章的框架结构"><a href="#突出显示文章的框架结构" class="headerlink" title="突出显示文章的框架结构"></a>突出显示文章的框架结构</h3><ul><li>文章短，支持每一关键句要点的段落少于2个，读者很容易明白文中要点及其相互关系，则给==要点加上下划线==即可</li><li>文章长，支持每一关键句要点的段落多于2个，则使用==标题介绍==来阐述观点</li></ul><h4 id="多级标题法"><a href="#多级标题法" class="headerlink" title="多级标题法"></a>多级标题法</h4><ul><li>不同层次的思想用不同的标记区分</li><li>层次越低的思想离页面的右端越近</li><li>同一层次的思想采用同一表现形式</li></ul><p><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/eg25.jpg" alt="多级标题法"></p><p><strong>注意点：</strong></p><ol><li>每一层级的标题不可能只有一个，文章里不可能只有一个章标题，一个节标题，一个小节标题，一个编号段落等等</li><li>相同的思想应使用相同的句型，每一组思想都是同一类的思想，为了强调一致性，一组中的所有标题应该采用同样的句子顺序，即对仗。如果第一小节的标题中第一个词是名词，其他各小节标题的第一个词也应该是名词</li><li>标题用词应提炼思想的精髓，尽量简明扼要</li><li>标题与正文应分开考虑，标题为眼球，正文为头脑</li><li>每组标题应提前集中介绍，为了说明该组标题将解释或讨论的注意论点，以及将要提出的思想观点</li><li>不要滥用标题，只有当标题有助于说清楚你想表达的信息，有助于读者领会你思想的细节时才使用</li></ol><h4 id="下划线法"><a href="#下划线法" class="headerlink" title="下划线法"></a>下划线法</h4><p><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/eg26.jpg" alt="下划线法"></p><ul><li>图中排版格式比较难看，很多人采用下面的下划线法</li></ul><p><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/eg27.jpg" alt="下划线法-1"></p><p><strong>注意：</strong></p><ol><li>必须严格使用疑问/回答结构</li><li>必须注意论点的措辞，说明论点的信息越少越好</li><li>必须坚决把论点限制在演绎推理和归纳推理的框架内</li></ol><h4 id="数字编号法"><a href="#数字编号法" class="headerlink" title="数字编号法"></a>数字编号法</h4><p><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/eg28.jpg" alt="数字编号法"></p><h4 id="行首缩进法"><a href="#行首缩进法" class="headerlink" title="行首缩进法"></a>行首缩进法</h4><p><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/eg29.jpg" alt="行首缩进法"></p><ul><li>采用行首缩进法时，要用相同的句型表达观点</li></ul><h4 id="项目符号法"><a href="#项目符号法" class="headerlink" title="项目符号法"></a>项目符号法</h4><p><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/eg30.jpg" alt="项目符号法"></p><h3 id="上下文之间要有过渡"><a href="#上下文之间要有过渡" class="headerlink" title="上下文之间要有过渡"></a>上下文之间要有过渡</h3><ul><li>写完序言后，进入文章正文，需要写一段简短的文字介绍每一关键句要点</li><li>不要把两个章节在做什么连接在一起，而应该把它们说的内容（即主要思想观点）连接在一起</li></ul><h4 id="讲故事"><a href="#讲故事" class="headerlink" title="讲故事"></a>讲故事</h4><ul><li>一种把读者带入关键句要点的好方法是向他讲述背景-冲突-疑问三部曲，自然而然地引出关键句要点作为故事的答案</li></ul><p><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/image-20200528092834833.png" alt="image-20200528092834833"></p><h4 id="承上启下"><a href="#承上启下" class="headerlink" title="承上启下"></a>承上启下</h4><ul><li>从金字塔结构的前一部分挑选一个词、一句短语或总结其中心思想，把它用在下一部分的起始句中</li></ul><h4 id="总结各部分内容"><a href="#总结各部分内容" class="headerlink" title="总结各部分内容"></a>总结各部分内容</h4><ul><li>有时遇到一个章节特别长或特别复杂，希望停下来作一个完整总结后再继续往下写。这时记住其目的是尽量凝练地复述前文的主要论点和基调</li></ul><h4 id="得出完整结论"><a href="#得出完整结论" class="headerlink" title="得出完整结论"></a>得出完整结论</h4><ul><li>亚里士多德关于如何下结论的忠告</li></ul><p><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/image-20200528094014157.png" alt="image-20200528094014157"></p><h4 id="说明下一步行动"><a href="#说明下一步行动" class="headerlink" title="说明下一步行动"></a>说明下一步行动</h4><ul><li>如果你的文章是建议读者采取一系列你认为他有可能采取的行动，而且篇幅较长，就有必要说明下一步行动</li></ul><h2 id="第11章：在PPT中呈现金字塔"><a href="#第11章：在PPT中呈现金字塔" class="headerlink" title="第11章：在PPT中呈现金字塔"></a>第11章：在PPT中呈现金字塔</h2><p>设计PPT演示文稿的人必须了解和掌握的最基本规则：</p><ol><li>文字幻灯片应只包含最重要的、经过适当分组和总结的思想，叙述时应尽量简洁</li><li>演示文稿应图文并茂，使用各种图表相配合</li><li>演示文稿应呈现经过深思熟虑后的故事梗概和剧本</li></ol><p>演示文稿包括两类幻灯片：</p><ol><li>文字</li><li>图表</li></ol><p>理想的比例是图表占90%，文字占10%，其各自的作用是：</p><ol><li>说明演示文稿的框架结构（文字幻灯片）</li><li>强调重要的思想、观点、结论、论点、建议或要采取的措施等（文字幻灯片）</li><li>阐明单用文字难以说清楚的数据、关系（图表）</li></ol><h3 id="设计文字PPT幻灯片"><a href="#设计文字PPT幻灯片" class="headerlink" title="设计文字PPT幻灯片"></a>设计文字PPT幻灯片</h3><ul><li>你所说的和你在屏幕上演示的应该有明显的区别</li></ul><h4 id="清楚你要说的内容"><a href="#清楚你要说的内容" class="headerlink" title="清楚你要说的内容"></a>清楚你要说的内容</h4><ul><li>好的幻灯片总是尽可能直接简单地传递信息，不把文字浪费在那些可以通过口头表达的转折性或介绍性语言上</li><li>文字幻灯片最好只用于强调金字塔中的主要论点，如图所示</li></ul><p><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/image-20200529094300768.png" alt="image-20200529094300768"></p><h4 id="清楚你要演示的内容"><a href="#清楚你要演示的内容" class="headerlink" title="清楚你要演示的内容"></a>清楚你要演示的内容</h4><p>指导性原则</p><ol><li>每次只演示和说明一个论点</li><li>论点应使用完整的陈述句（销售前景看好），而不是标题性语言（销售前景）</li><li>文字应尽量简短</li><li>使用简单的词汇和数字、比如490万美元就比4876987美元容易记</li><li>字号应足够大，最远一位观众到屏幕的距离（英尺）除以32，得到的是你的PPT可以用的最小字号（英寸）</li><li>注意幻灯片的趣味性</li><li>用逐级展开呈现，提高趣味性，如下图</li></ol><p><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/image-20200601092702072.png" alt="image-20200601092702072"></p><h3 id="设计图表PPT幻灯片"><a href="#设计图表PPT幻灯片" class="headerlink" title="设计图表PPT幻灯片"></a>设计图表PPT幻灯片</h3><ul><li>图表幻灯片传递的信息应该尽量简单易懂，因为观众没有机会对它们仔细研究并找出各个部分的含义</li><li>图表幻灯片通常用饼图、条形图、柱状图、曲线图或散点图，表示某一结构或流程的组成部分</li><li>制作图表幻灯片的诀窍是：确定你想用图表回答的问题，把答案作为图表的标题，然后选择最合适表达论点的图表样式</li></ul><h3 id="故事梗概"><a href="#故事梗概" class="headerlink" title="==故事梗概=="></a>==故事梗概==</h3><h4 id="具体怎么做"><a href="#具体怎么做" class="headerlink" title="具体怎么做"></a>具体怎么做</h4><p>从金字塔结构到演示文稿，作者通常采用以下方法：</p><ol><li>序言尽量写得详细，把每个想说的词汇按照希望的顺序写下来</li><li>用写故事梗概的形式。每张幻灯片写作的顺序，从上往下依次为<ol><li>序言各要素、</li><li>关键句要点</li><li>关键句下一层次的论点</li></ol></li><li>初步决定你准备采用的呈现方法，只要知道数据的类型和想要表现何种关系即可</li><li>准备好每张幻灯片的讲稿，确保整个演示像讲故事一样流畅</li><li>完成幻灯片的设计和绘图</li><li>排练，排练，再排练！</li></ol><p><strong>提示：</strong>可以用一张白纸写最简单的故事梗概，把它分成若干个区域，每个区域代表一张空白幻灯片，写上你想要阐述的要点，并说明哪些需要用文字幻灯片，哪些需要用图片幻灯片</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><ul><li>将以下金字塔结构写成幻灯片</li><li>金字塔结构</li></ul><p><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/image-20200601094943816.png" alt="image-20200601094943816"></p><ul><li>幻灯片</li></ul><p><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/image-20200601095046018.png" alt="image-20200601095046018"><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/image-20200601095102552.png" alt="image-20200601095102552"></p><h3 id="本章总结"><a href="#本章总结" class="headerlink" title="本章总结"></a>本章总结</h3><p><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/image-20200601095235815.png" alt="image-20200601095235815"></p><h2 id="第12章：在字里行间呈现金字塔"><a href="#第12章：在字里行间呈现金字塔" class="headerlink" title="第12章：在字里行间呈现金字塔"></a>第12章：在字里行间呈现金字塔</h2><p>做到条理清晰的两个步骤：</p><ul><li>首先决定要说明的思想或要证明的论点</li><li>然后用文字表现</li><li>强迫自己想象各种思想观点之间的内在关系，头脑里有了清晰的图像后，就能立刻把它转换成清楚的句子</li></ul><h3 id="画脑图"><a href="#画脑图" class="headerlink" title="画脑图"></a>画脑图</h3><ul><li>利用脑图帮助自己记忆，也让自己的文章能被别人记住</li></ul><h3 id="把图像复制成文字"><a href="#把图像复制成文字" class="headerlink" title="把图像复制成文字"></a>把图像复制成文字</h3><ul><li>文章要让读者在阅读时感到愉悦。简单的方法就是：主观臆想那些当初用来得出思想的图像</li></ul><h1 id="附录：本书要点汇总"><a href="#附录：本书要点汇总" class="headerlink" title="附录：本书要点汇总"></a>附录：本书要点汇总</h1><p><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/image-20200602093917094.png" alt="image-20200602093917094"></p><p><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/image-20200602094149099.png" alt="image-20200602094149099"></p><p><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/image-20200602094212128.png" alt="image-20200602094212128"></p><p><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/image-20200602094234885.png" alt="image-20200602094234885"></p><p><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/image-20200602094252755.png" alt="image-20200602094252755"></p><p><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/image-20200602094323021.png" alt="image-20200602094323021"><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/image-20200602094340478.png" alt="image-20200602094340478"></p><p><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/image-20200602094421615.png" alt="image-20200602094421615"><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/image-20200602094447994.png" alt="image-20200602094447994"><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/image-20200602094855941.png" alt="image-20200602094855941"></p><p><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/image-20200602094944007.png" alt="image-20200602094944007"><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/image-20200602095019423.png" alt="image-20200602095019423"></p><p><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/image-20200602095102189.png" alt="image-20200602095102189"></p><p><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/image-20200602095118549.png" alt="image-20200602095118549"></p><p><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/image-20200602095128872.png" alt="image-20200602095128872"></p><p><img src="/2020/04/24/jin-zi-ta-yuan-li-du-shu-bi-ji/image-20200602095138041.png" alt="image-20200602095138041"></p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> 职场能力 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>细节营销读书笔记</title>
      <link href="/2020/04/14/xi-jie-ying-xiao-du-shu-bi-ji/"/>
      <url>/2020/04/14/xi-jie-ying-xiao-du-shu-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章：何为市场营销"><a href="#第一章：何为市场营销" class="headerlink" title="第一章：何为市场营销"></a>第一章：何为市场营销</h1><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><ul><li>市场营销只是常识吗？显然不是的</li><li>市场营销原则适用于所有行业</li><li>市场营销不是销售</li></ul><h2 id="语录"><a href="#语录" class="headerlink" title="语录"></a>语录</h2><ul><li>你可以借鉴任何行业任何公司的成功经验</li><li>市场营销工具（4P）转化为客户体验（4C）</li><li>帮助你的客户，让他们的生活更方便、更舒适，这样做会帮你省钱</li><li>一个问题以及该问题的解决方法未必处于同一个P的范畴</li><li>寻找无题之解，开拓创新之道</li></ul><h2 id="4P-生产商的视角"><a href="#4P-生产商的视角" class="headerlink" title="4P-生产商的视角"></a>4P-生产商的视角</h2><ul><li>产品</li><li>渠道</li><li>价格</li><li>促销</li></ul><h2 id="4C-客户的视角"><a href="#4C-客户的视角" class="headerlink" title="4C-客户的视角"></a>4C-客户的视角</h2><ul><li>客户的需求，而不是产品</li><li>成本，而不是价格</li><li>沟通，而不是促销</li><li>便利，而不是渠道</li></ul><p><img src="/2020/04/14/xi-jie-ying-xiao-du-shu-bi-ji/4p_4c.jpg" alt="4P-4C"></p><h1 id="第二章：市场营销的研发"><a href="#第二章：市场营销的研发" class="headerlink" title="第二章：市场营销的研发"></a>第二章：市场营销的研发</h1><h2 id="语录-1"><a href="#语录-1" class="headerlink" title="语录"></a>语录</h2><ul><li>找出世界上最成功的公司，研究它们的市场营销方法，调整修改，为你所用</li><li>市场营销中，小办法可以解决大问题，但是你必须得做个有心人</li><li>你的产品离开工厂后情况如何呢？得去做研发</li><li>公司至少要有几个真正得市场营销经理</li><li>寻找该问得问题</li><li>不要让市场营销研发成为管理者事业发展得绊脚石</li><li>把这一章得内容印发给员工，人手一册</li><li>愿意去观察、尝试、接受新方法的人是很少的</li></ul><h1 id="第三章：作为一种经营理念的市场营销"><a href="#第三章：作为一种经营理念的市场营销" class="headerlink" title="第三章：作为一种经营理念的市场营销"></a>第三章：作为一种经营理念的市场营销</h1><h2 id="语录-2"><a href="#语录-2" class="headerlink" title="语录"></a>语录</h2><ul><li>一家公司的价值取决于它的客户</li><li>如果你和你的客户生活在两个完全不同的世界，那么你很难见其所见</li><li>爱君者唯君耳</li><li>感同身受，体会客户的痛苦</li><li>看清现实</li><li>找你的前客户谈谈</li><li>从客户中招贤纳士</li><li>最了解你的客户的专家是客户自己</li><li>做做你自己的客户</li><li>也做做你竞争对手的客户</li><li>双赢是很好，但到底你赢多少，我赢多少呢？</li><li>我的市场营销做得很好，客户满意度就越不重要</li></ul><h1 id="第四章：做营销需要营销知识吗"><a href="#第四章：做营销需要营销知识吗" class="headerlink" title="第四章：做营销需要营销知识吗"></a>第四章：做营销需要营销知识吗</h1><h2 id="语录-3"><a href="#语录-3" class="headerlink" title="语录"></a>语录</h2><ul><li>市场营销中有很多正确答案，也有很多错误答案</li><li>确定一下你准备聘任的那位才华横溢的新市场营销经理是否懂市场营销</li><li>==告诉潜在客户如果他不买会失去什么==</li><li>“讨厌失去”的倾向强于“讨厌风险”的倾向</li><li>分散客户的注意力，不让他用脑，让他跟着感觉走</li><li>悲伤也有助于降低客户的理性决策能力</li><li>两性大战是鬼话</li><li>让美女去卖威士忌；让你的叔叔去卖保险</li><li>小恩小惠引出大恩大惠</li><li>发现、测试、完善。一个优秀的市场营销经理应是一个冷静实干、不断试验的科学家</li><li>市场营销成功的秘诀就是学以致用</li><li>在市场营销中，“正确”的意思是“足够正确”</li><li>市场营销就像赌博，赢面有利于你的时候，赌博并不危险</li></ul><h1 id="第五章：市场营销者的职责"><a href="#第五章：市场营销者的职责" class="headerlink" title="第五章：市场营销者的职责"></a>第五章：市场营销者的职责</h1><h2 id="语录-4"><a href="#语录-4" class="headerlink" title="语录"></a>语录</h2><ul><li>根据一个公司的客户判断这个公司的情况</li><li>常识告诉我们供不应求时市场营销的必要性下降==（恰恰相反——此时是最需要市场营销的。供不应求正好给我们提供一个绝好的机会提升我们客户组合的质量和价值。客户是我们最重要的资产）==</li><li>常识错误：供不应求时市场营销回报最高==（在供不应求时，市场营销投入越多，回报越多）==</li><li>易行之途则智者先至</li><li>当你的产品不能够给你带来优势时，你的客户能给你带来优势</li><li>向人力资源学习：考评客户，排序分类</li></ul><h1 id="第六章：管理你的市场"><a href="#第六章：管理你的市场" class="headerlink" title="第六章：管理你的市场"></a>第六章：管理你的市场</h1><h2 id="语录-5"><a href="#语录-5" class="headerlink" title="语录"></a>语录</h2><ul><li>如果你不了解竞争对手的客户，那么你就不了解你自己的客户</li><li>了解市场，了解自己，检验假设</li><li>要确保公司的CEO和市场营销经理们知道谁是你们的客户</li><li>不要只是阅读有关客户的资料，直接去寻访客户，眼见为实</li><li>检验你的假设，测量你的市场</li><li>当你觉得数据不可置信时，也许它们在讲述着一个你所不知道的故事</li><li>积极主动地管理影响你在行业细分市场上获利能力的五力<ul><li>进入壁垒：竞争对手进入你的市场难度如何？——不要进入别人也能进入的市场（==现在腾讯阿里哪个市场不能进入？==）</li><li>现有竞争：在有些行业，龙头老大之间相敬如宾——别找打，特别时在个儿比你大的人面前</li><li>替代品：竞争对手能伤你，而替代品能毁了你——技术壁垒</li><li>买方力量：如果买方有机会将你的钱弄到他自己的腰包，他是不会错过这个机会的</li><li>卖方力量：你若不能控制供应商的议价能力，你就赚不了钱——如果供应商有机会将你的钱弄到他自己的腰包，他也不会错过这个机会的</li></ul></li><li>寻找哀鸿遍野的战场——寻找最糟糕的行业进入</li><li>竞争并不发生在行业层面，而是发生在细分市场层面——==进入某个行业先问以下问题：==<ul><li>你进入这个行业后准备怎么做？</li><li>你会创建哪些新的细分市场？</li><li>你的蓝海在哪里？</li></ul></li><li>不求更好，但求不同，自立门户，自创山头</li><li>另外三大标准<ul><li>规模合适：一个细分市场，规模必须足够大，以纳你雄心，但也不能太大——==要么第一、要么第二，不然修、关、卖==</li><li>增长能力和获利能力</li><li>易得性：与其先确定目标人群得年龄再找寻以这个年龄为受众的媒体做广告，不如去找寻目标客户，直接问他们看到什么媒体</li></ul></li><li>如果不再有人能够指出你的错误，说明你该退休了</li></ul><h1 id="第七章：市场细分新思想"><a href="#第七章：市场细分新思想" class="headerlink" title="第七章：市场细分新思想"></a>第七章：市场细分新思想</h1><h2 id="语录-6"><a href="#语录-6" class="headerlink" title="语录"></a>语录</h2><ul><li>你需要谁成为你的客户？</li><li>更好的产品需要具备能够吸引更好的客户的属性</li><li>客户与品牌关系如下：<ul><li>忠诚的客户</li><li>于我有利的品牌转换者</li><li>于我不利的品牌转换者</li><li>竞争对手品牌的忠诚客户</li><li>不用此类产品的人</li></ul></li><li>如果你挪动一个客户，那么从他站的地方开始</li><li>重点突出，做强做大</li><li>宁为鸡首，别做凤尾</li><li>新产品的研发是好事，但是新市场的研发更好</li><li>失去好客户是坏事，扔掉坏客户是好事</li><li>战争是地狱，能躲就躲</li></ul><h1 id="第八章：失去你的客户"><a href="#第八章：失去你的客户" class="headerlink" title="第八章：失去你的客户"></a>第八章：失去你的客户</h1><h2 id="语录-7"><a href="#语录-7" class="headerlink" title="语录"></a>语录</h2><ul><li>找出你的前客户是谁，找到他们的下落</li><li>客户流失率降低一半，公司价值翻一番</li><li>找出谁是你最好的客户，确保他们有爱你的理由</li><li>向MBNA学习——MBNA（美信银行）1982年将降低客户流失率作为首要任务来抓，努力赢得前客户</li><li>提醒客户你的存在</li><li>不要让你的忠诚计划取代忠诚本身</li><li>设计高粘度的客户关系</li></ul><h1 id="第九章：你我都不知道什么是好广告"><a href="#第九章：你我都不知道什么是好广告" class="headerlink" title="第九章：你我都不知道什么是好广告"></a>第九章：你我都不知道什么是好广告</h1><h2 id="语录-8"><a href="#语录-8" class="headerlink" title="语录"></a>语录</h2><ul><li>告诉客户你是做什么的</li><li>和客户谈谈</li><li>不要自言自语</li><li>公司和它的广告公司是最不能评判其广告好坏的，它们知道得太多了</li><li>评判广告的最佳人选是你的潜在客户</li><li>试验好比买便宜的保险，不犯错误，就不必吸取教训了</li></ul><h1 id="第十章：好广告的要素"><a href="#第十章：好广告的要素" class="headerlink" title="第十章：好广告的要素"></a>第十章：好广告的要素</h1><ul><li>不同的销售情形适用不同的广告</li><li>品牌知名度是第一大挑战</li><li>品牌知名度有两种：记得和认得</li><li>认得：<ul><li>确保品牌包装和名称在广告中得到充分展示</li><li>必须阐述此类产品的功能用途</li><li>第一次宣传到做得声势浩大</li></ul></li><li>记得：<ul><li>广告正文主题句必须包括产品用途、品牌名词和第二人称呼语</li><li>不断重复主题句</li><li>保持较高的出镜率</li></ul></li><li>品牌态度是第二大挑战——品牌态度是指客户对其所知产品的好恶态度<br><img src="/2020/04/14/xi-jie-ying-xiao-du-shu-bi-ji/4_imp.jpg" alt="4_imp"></li><li>品牌态度可以分为以下四类以及对应广告规则：<ul><li>重要 &amp; 消极动机：<ul><li>在产品生命周期的早期，正确描绘与购买动机相吻合的情绪</li><li>得让目标客户接受广告得主要意思</li><li>目标受众对品牌的已有态度必须是首要考虑的问题</li></ul></li><li>重要 &amp; 积极动机： <ul><li>情感的真实性是最为重要的，广告必须符合目标受众所在的群体的情绪状态和生活方式</li><li>必须让人们把自己和广告中的产品在一起，产生归属感</li><li>当受众缺乏有关产品的事实信息时，就应该给他们提供信息</li><li>要夸张渲染，言过其实，不要谦虚</li></ul></li><li>不重要 &amp; 消极动机<ul><li>使用“问题与解决办法”的简单哦公式，保持广告单刀直入</li><li>未必要让客户喜欢你的广告</li><li>关于产品的好处裨益，要竭尽渲染之能事</li></ul></li><li>不重要 &amp; 积极动机<ul><li>情感的共鸣很重要</li><li>品牌所产生的联想，情感必须是独特的——万宝路就是个很好例子</li><li>目标受众必须喜欢这个广告</li><li>通过联想塑造品牌形象</li></ul></li></ul></li><li>了解你面临的销售情形，选择相应的广告规则，因势利导</li><li>要打破常规，首先必须掌握常规——马克吐温</li><li>如果你的广告代理公司只会故弄玄虚，设计一个广告的目的是激发受众的好奇心，那就解雇他</li></ul><h1 id="第十一章：应该在哪里做广告"><a href="#第十一章：应该在哪里做广告" class="headerlink" title="第十一章：应该在哪里做广告"></a>第十一章：应该在哪里做广告</h1><h2 id="语录-9"><a href="#语录-9" class="headerlink" title="语录"></a>语录</h2><ul><li>在哪里做广告？——问问你的（潜在）客户</li><li>不要向同一个客户重复做广告</li><li>如果你的广告集中在单个媒体渠道，那么重叠和浪费产生的概率更大</li><li>分清主次：媒体-信息-执行</li></ul><h1 id="第十二章：你的广告公司不是你的合作伙伴"><a href="#第十二章：你的广告公司不是你的合作伙伴" class="headerlink" title="第十二章：你的广告公司不是你的合作伙伴"></a>第十二章：你的广告公司不是你的合作伙伴</h1><h2 id="语录-10"><a href="#语录-10" class="headerlink" title="语录"></a>语录</h2><ul><li>如果你相信你的广告公司，那么你将一无所获</li><li>广告公司所谓的免费调研是“羊毛出在羊身上”，不值得去占这个便宜</li><li>如果广告公司是你的战略宣传伙伴，那么汽车销售员就是你的战略交通伙伴——这岂不荒唐</li><li>不要只用一家广告公司</li><li>举办广告大赛，获得更好得创意</li><li>比照测试多个创意方案</li></ul><h1 id="第十三章：不要问你的品牌能为你做些什么"><a href="#第十三章：不要问你的品牌能为你做些什么" class="headerlink" title="第十三章：不要问你的品牌能为你做些什么"></a>第十三章：不要问你的品牌能为你做些什么</h1><h2 id="语录-11"><a href="#语录-11" class="headerlink" title="语录"></a>语录</h2><ul><li>品牌使得决策更容易</li><li>品牌可以降低风险</li><li>品牌可以让我获得他人得尊重</li><li>品牌帮助客户创造更理想得现实世界</li><li>你的产品和服务让你有钱，让你的品牌出名</li><li>品牌不是丰厚利润的唯一来源</li><li>当品牌对你很重要时，品牌价值不高的代价十分高昂</li><li>当品牌对你很重要时，你必须身体力行你的品牌</li><li>品牌说：“我能做的你都能做，但你不是我”——当其他公司仿照你的品牌时，你的品牌能反过来保护你</li><li>公司战略和品牌战略不谋而合——公司战略和品牌战略应该是统一的</li><li>小心读市场营销的工程师——技术性市场营销</li></ul><h1 id="第十四章：营销数学"><a href="#第十四章：营销数学" class="headerlink" title="第十四章：营销数学"></a>第十四章：营销数学</h1><h2 id="语录-12"><a href="#语录-12" class="headerlink" title="语录"></a>语录</h2><ul><li>在市场营销中没有比提高效率更容易的事情了</li><li>市场营销杠杆底线是营销决策要考虑的关键比例，是营销投资决策的试金石</li><li>降价是最昂贵的市场营销策略</li><li>保持低成本是生产成本的职责</li><li>保持高价格是营销部门的职责</li><li>利润高于市场份额，也会带来市场份额</li><li>追求短期利润无可厚非，有了短期才有长期</li><li>你的销售代表干活卖力不卖力，会有什么区别？——如果卖力干活加薪拿奖金不划算的话，他就不会卖力</li></ul><h1 id="第十五章：定价策略"><a href="#第十五章：定价策略" class="headerlink" title="第十五章：定价策略"></a>第十五章：定价策略</h1><h2 id="语录-13"><a href="#语录-13" class="headerlink" title="语录"></a>语录</h2><ul><li>打折时将绝对金额</li><li>收费时讲百分比</li><li>开发价值，宣传价值</li><li>要谈价值，而不是价格</li><li>价格永远不是第一个P</li><li>低价格信号对买方管用，所以对卖方也管用</li><li>价格实际是低的，但是看着不低，这招可能对你管用</li><li>价格尾数是9，很好，5也不错，在亚洲，8也很好</li><li>不要自作聪明——以为自己可以占便宜</li><li>价格要因人而异——价格歧视</li><li>运用创造力、新发明、研发来寻找价格歧视新方法</li><li>定价很重要</li></ul><h1 id="第十六章：分销"><a href="#第十六章：分销" class="headerlink" title="第十六章：分销"></a>第十六章：分销</h1><h2 id="语录-14"><a href="#语录-14" class="headerlink" title="语录"></a>语录</h2><ul><li>当众多公司合作共事时，高效率并非是自然而然地结果</li><li>个性理性地决策未必能给集体带来好结果</li><li>成为你的渠道系统地“黑手党教父”</li><li>把钱给经销商并能证明你的支配力</li></ul><h1 id="第十七章：支配力"><a href="#第十七章：支配力" class="headerlink" title="第十七章：支配力"></a>第十七章：支配力</h1><h2 id="语录-15"><a href="#语录-15" class="headerlink" title="语录"></a>语录</h2><ul><li>==工作和收入是负相关关系==</li><li>公司应该提高对权力管理的重视程度</li><li>效率提高对奴隶而言没有任何好处</li><li>积极管理关系，尽量增强渠道伙伴对你的依赖性</li><li>应自己去做那些能增强渠道支配力的分销工作</li><li>任何一个P都可以带来任何一个C：促销可以增强渠道支配力</li></ul><h1 id="第十八章：营销新概念——诚信"><a href="#第十八章：营销新概念——诚信" class="headerlink" title="第十八章：营销新概念——诚信"></a>第十八章：营销新概念——诚信</h1><h2 id="语录-16"><a href="#语录-16" class="headerlink" title="语录"></a>语录</h2><ul><li>诚实是公司最宝贵的资产</li><li>你的客户、投资者、员工认为你的公司有多诚实，就有多卖命</li><li>不诚实是滑坡式的灾难</li><li>像折磨客户那样折磨自己，感同身受</li><li>偷钱是不对的，偷时间也是不对的</li><li>偷你客户的时间和金钱是很危险的生意</li><li>检验客户服务的简单标准：你会这样对待你的母亲吗？</li><li>诚实——一个全新的概念</li></ul><h1 id="第十九章：外面的世界"><a href="#第十九章：外面的世界" class="headerlink" title="第十九章：外面的世界"></a>第十九章：外面的世界</h1><h2 id="语录-17"><a href="#语录-17" class="headerlink" title="语录"></a>语录</h2><ul><li>组织架构图应该显示所有参与营销你的产品的人和公司</li><li>任何一个对于你产品的成功有着直接或间接影响的人都应该是你宝贵的客户</li><li>你帮助了渠道也就是帮助了自己</li><li>小事做好了，大事自然水到渠成</li><li>管理你的商店</li><li>如果你偷朋友的钱，那么你将没朋友</li><li>在价值链各个环节提供增值，首先关心你客户的商业模式</li><li>解决了客户的问题也就解决了自己的问题</li><li>复杂的公式帮不了你，如果输入是错误参数的话</li><li>帮助客户达到利润最大化，你的利润自然也就最大化了</li><li>不要忙于管理，而忘了去寻找并留住客户</li><li>市场营销的成败取决于公司外部，而不是内部</li><li>不要为了节省小钱，搞得客户民怨沸腾</li></ul><h1 id="第二十章：最新的思考"><a href="#第二十章：最新的思考" class="headerlink" title="第二十章：最新的思考"></a>第二十章：最新的思考</h1><h2 id="语录-18"><a href="#语录-18" class="headerlink" title="语录"></a>语录</h2><ul><li>你考虑过你的营销对象吗</li><li>改变你的收费标准</li><li>经济低迷时的市场营销</li><li>做到兼容并蓄</li></ul>]]></content>
      
      
      <categories>
          
          <category> AI/数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据科学 </tag>
            
            <tag> 细节营销 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>富爸爸穷爸爸读书笔记</title>
      <link href="/2020/04/07/fu-ba-ba-qiong-ba-ba-du-shu-bi-ji/"/>
      <url>/2020/04/07/fu-ba-ba-qiong-ba-ba-du-shu-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章：富人不为钱工作"><a href="#第一章：富人不为钱工作" class="headerlink" title="第一章：富人不为钱工作"></a>第一章：富人不为钱工作</h1><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><h3 id="左脑时刻"><a href="#左脑时刻" class="headerlink" title="左脑时刻"></a>左脑时刻</h3><ul><li>尽管有一份高收入的工作，像穷爸爸一样的人仍只能勉强维持着收支平衡</li></ul><h3 id="右脑时刻"><a href="#右脑时刻" class="headerlink" title="右脑时刻"></a>右脑时刻</h3><ul><li>用一个新颖的、具有创造性的方法看待废弃的连环画可以带来商机</li></ul><h3 id="潜意识时刻"><a href="#潜意识时刻" class="headerlink" title="潜意识时刻"></a>潜意识时刻</h3><ul><li>人们让恐惧和贪婪控制了自己的人生</li></ul><h2 id="语录"><a href="#语录" class="headerlink" title="语录"></a>语录</h2><ul><li>穷人和中产阶级为钱而工作，富人让钱为他工作</li><li>生活推着我们所有的人，有些人放弃了，有些人在抗争，少数人学会了这门课程，取得了进步，他们欢迎生活推动着他们</li><li>说到钱，大多数人都希望稳稳妥妥的赚钱，这样他们感到安全。关于钱，他们没有激情，有的只是恐惧</li><li>正是出于恐惧的心理，人们才想找一份安稳的工作。这些恐惧有：害怕付不起账单，害怕被解雇，害怕没有足够的钱，害怕重新开始。为了寻求保障，他们学习某种专业，或是做生意，拼命为钱工作。大多数人成了钱的奴隶，然后把怒气发泄到他们老板身上</li><li>大多数人并不知道是他们的感情代替了他们进行思考</li><li>就像一幅画表现的：驴子拉车，因为主人在它面前挂了个胡萝卜。主人清楚自己想要去哪里，而驴子却只是在追逐一个幻影。但第二天驴子依旧会去拉车，因为又有胡萝卜放在它的面前==我们大多数人就是那只驴子==</li></ul><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><ul><li>从小的教育就是让我们认真学习，通过高考进入好的大学，然后学习一门热门的专业，再进入社会为钱工作，然后工作、赚钱、支付账单、再工作。工资越高、花费越高，慢慢的就变成了那只驴子</li><li>恐惧是我们害怕重新开始，害怕去冒险。家庭责任、支付不完的账单、没钱让我们越来越畏畏缩缩。但是我们又贪婪，渴望有钱，所以很多人买彩票，渴望一夜暴富，却很少去学习理财知识，投资自己</li></ul><h1 id="第二章：为什么要教授财务知识"><a href="#第二章：为什么要教授财务知识" class="headerlink" title="第二章：为什么要教授财务知识"></a>第二章：为什么要教授财务知识</h1><h2 id="本章小结-1"><a href="#本章小结-1" class="headerlink" title="本章小结"></a>本章小结</h2><h3 id="左脑时刻-1"><a href="#左脑时刻-1" class="headerlink" title="左脑时刻"></a>左脑时刻</h3><ul><li>观察这些数字并学习他们所讲的故事</li><li>==资产把钱放入你的口袋==</li><li>如果有东西把钱从你的口袋里拿出来，它就是负债</li></ul><h3 id="右脑时刻-1"><a href="#右脑时刻-1" class="headerlink" title="右脑时刻"></a>右脑时刻</h3><ul><li>资产负债表清楚的解释了钱在不同人的生活中的活动规律</li></ul><h3 id="潜意识时刻-1"><a href="#潜意识时刻-1" class="headerlink" title="潜意识时刻"></a>潜意识时刻</h3><ul><li>被排斥的恐惧导致人们顺从，从不提出质疑，普遍接受别人的观点和流行趋势，最后却使自己的财物受到损害</li></ul><h3 id="几张图"><a href="#几张图" class="headerlink" title="几张图"></a>几张图</h3><p><img src="/2020/04/07/fu-ba-ba-qiong-ba-ba-du-shu-bi-ji/zichan.jpg" alt="资产现金流模式图"></p><p><img src="/2020/04/07/fu-ba-ba-qiong-ba-ba-du-shu-bi-ji/fuzhai.jpg" alt="负债现金流模式图"></p><p><img src="/2020/04/07/fu-ba-ba-qiong-ba-ba-du-shu-bi-ji/qiongzhongfu.jpg" alt="穷人中产富人图"></p><h2 id="语录-1"><a href="#语录-1" class="headerlink" title="语录"></a>语录</h2><ul><li>重要的不是你挣了多少钱，而是你能留下多少钱</li><li>只有知识才能解决问题并创造财富，那些不是靠财务知识挣来的钱也不会长久</li><li>富人获得资产，而穷人和中产阶级获得负债，只不过他们以为那些负债是资产</li></ul><h2 id="反思-1"><a href="#反思-1" class="headerlink" title="反思"></a>反思</h2><ul><li>我的财务教育可以说几乎没有，因为以前没钱，所以也就没想着去学习这些知识，现在看来是多么的愚蠢</li><li>作者对资产和负债的定义相当简单透彻，我们大多数人的一生是工作、买房、买车、娶妻、生子，但是贷款买的房车让自己背上了30年的负债，况且小孩的花费，只会让自己压力越来越大，越来越穷</li><li>现在的我就是穷人的现金流模式，争取往富人方向发展</li></ul><h1 id="第三章：关注自己的事业"><a href="#第三章：关注自己的事业" class="headerlink" title="第三章：关注自己的事业"></a>第三章：关注自己的事业</h1><h2 id="本章小结-2"><a href="#本章小结-2" class="headerlink" title="本章小结"></a>本章小结</h2><h3 id="左脑时刻-2"><a href="#左脑时刻-2" class="headerlink" title="左脑时刻"></a>左脑时刻</h3><ul><li>当资产产生的收入能够支付奢侈品时，才是你可以去购买它们的时候</li></ul><h3 id="右脑时刻-2"><a href="#右脑时刻-2" class="headerlink" title="右脑时刻"></a>右脑时刻</h3><ul><li>创造性的去想一想什么才是你的事业，而不是你的职业</li></ul><h3 id="潜意识时刻-2"><a href="#潜意识时刻-2" class="headerlink" title="潜意识时刻"></a>潜意识时刻</h3><ul><li>获得你所喜欢的资产，这样你才能很好的打理他们，享受其中的学习过程</li></ul><h3 id="资产分类"><a href="#资产分类" class="headerlink" title="资产分类"></a>资产分类</h3><ul><li>不需要我到场就可以正常运作的业务。我拥有它们，但是由别人经营和管理。如果==我必须在那工作，那它就不是我的事业，而是我的职业==</li><li>股票</li><li>债券</li><li>能够产生收入的房地产</li><li>票据（借据）</li><li>版税，如音乐、手稿、专利</li><li>其他任何有价值、可产生收入或有增值潜力并且有很好销路的东西</li></ul><h2 id="语录-2"><a href="#语录-2" class="headerlink" title="语录"></a>语录</h2><ul><li>为了财务安全，人们需要关注自己的事业，而不是职业</li><li>富人关心的焦点是资产而其他人关心的是收入</li><li>存在财务问题的人经常耗费一生为别人工作，其中许多人在他们不能工作时就变得一无所有</li><li>一旦把1美元投入了资产项，就不要让它出来。你应该这么想：这1美元进了你的资产项，它就成了你的雇员。关于钱，最妙的就是让它可以一天24小时不间断工作，还能为你的子孙后代服务</li><li>一个重要的区别就是：富人最后才买奢侈品，穷人和中产阶级会先买奢侈品</li></ul><h2 id="反思-2"><a href="#反思-2" class="headerlink" title="反思"></a>反思</h2><ul><li>我的职业是数据挖掘工程师，我的事业暂时没有，得找一份事业了</li><li>目前为止拥有的净资产也就是我脑子里面的知识了</li><li>大多数时候我的现金流并不适合购买奢侈品，但是我还是去购买了，并且还经常去旅游等</li></ul><h1 id="第四章：税收的历史和公司的力量"><a href="#第四章：税收的历史和公司的力量" class="headerlink" title="第四章：税收的历史和公司的力量"></a>第四章：税收的历史和公司的力量</h1><h2 id="本章小结-3"><a href="#本章小结-3" class="headerlink" title="本章小结"></a>本章小结</h2><h3 id="左脑时刻-3"><a href="#左脑时刻-3" class="headerlink" title="左脑时刻"></a>左脑时刻</h3><ul><li>会计就是财务知识或者解读数字的能力。如果你想建立一个商业帝国，这项能力至关重要。你管理的钱越多，就越要精确，否则你的大厦就会倒塌</li></ul><h3 id="右脑时刻-3"><a href="#右脑时刻-3" class="headerlink" title="右脑时刻"></a>右脑时刻</h3><ul><li>投资就是“钱生钱”的科学。这包含策略和方案，这要使用属于创造的右脑来做</li></ul><h3 id="潜意识时刻-3"><a href="#潜意识时刻-3" class="headerlink" title="潜意识时刻"></a>潜意识时刻</h3><ul><li>了解市场是供给与需求的科学。在市场基本面或者说一项投资的经济意义基础上，你需要了解受感情驱动的市场的“技术面”</li></ul><h3 id="拥有公司的好处"><a href="#拥有公司的好处" class="headerlink" title="拥有公司的好处"></a>拥有公司的好处</h3><ul><li>拥有公司的富人是：挣钱、支出、缴税</li><li>为公司工作的人是：挣钱、缴税、支出</li><li>两者的区别就是税赋的压力让为公司工作的人损失很多</li></ul><h3 id="财商的组成"><a href="#财商的组成" class="headerlink" title="财商的组成"></a>财商的组成</h3><ul><li>会计（财务知识）</li><li>投资（钱生钱的科学和策略）</li><li>了解市场（供给与需求的科学以及市场条件）</li><li>法律（减税优惠和在诉讼中获得保护）</li></ul><h2 id="语录-3"><a href="#语录-3" class="headerlink" title="语录"></a>语录</h2><ul><li>事实上富人并未被征税，是中产阶级尤其是受过良好教育的高收入的中产阶级在为穷人支付税金</li><li>如果你为钱工作，你就把力量给了你的老板，如果让钱为你工作，你就能控制这种力量</li><li>了解减税优惠政策和公司法的人会比雇员和小业主更快致富</li></ul><h2 id="反思-3"><a href="#反思-3" class="headerlink" title="反思"></a>反思</h2><ul><li>中国的税收政策可能跟书中所说不一样，现在对个人也有很多减税优惠</li></ul><h1 id="第五章：富人的投资"><a href="#第五章：富人的投资" class="headerlink" title="第五章：富人的投资"></a>第五章：富人的投资</h1><h2 id="本章小结-4"><a href="#本章小结-4" class="headerlink" title="本章小结"></a>本章小结</h2><h3 id="左脑时刻-4"><a href="#左脑时刻-4" class="headerlink" title="左脑时刻"></a>左脑时刻</h3><ul><li>一小笔钱可以通过精明的、好的投资变成一大笔钱</li></ul><h3 id="右脑时刻-4"><a href="#右脑时刻-4" class="headerlink" title="右脑时刻"></a>右脑时刻</h3><ul><li>作者常常鼓励他的成人学生要从《富爸爸现金流》游戏中发现哪些情况是他们所知道的，哪些是他们还需要学习的。最重要的是，这个游戏能反映一个人的行为方式，它是一个实时的反馈系统。它不需要老师们不停的交接，它就像是一场个人间的对话，完全按照你的习惯定制</li></ul><h3 id="潜意识时刻-4"><a href="#潜意识时刻-4" class="headerlink" title="潜意识时刻"></a>潜意识时刻</h3><ul><li>我们都拥有巨大的潜能——这是上天赏赐的礼物。我们都或多或少地存在着某种自我怀疑的心理，从而阻碍前行的步伐。==这种障碍很少是缺乏某种技术性的东西，更多是缺乏自信==</li></ul><h3 id="投资者类型"><a href="#投资者类型" class="headerlink" title="投资者类型"></a>投资者类型</h3><ul><li>进行一揽子投资的人（比如财务规划师）</li><li>自己创造投资机会的人（职业投资者），要想成为这种类型的人，必须学会以下三种技能<ul><li>如何找到别人错失的机会</li><li>如何筹措资金</li><li>如何把精明的人组织起来并雇佣他们为你工作。==风险无处不在，要学会驾驭风险，别总想回避风险==</li></ul></li></ul><h2 id="语录-4"><a href="#语录-4" class="headerlink" title="语录"></a>语录</h2><ul><li>在现实生活中，人们往往是依靠勇气而不是智慧去取得领先的位置的</li><li>陈旧的思想是那些在贫困线上苦苦挣扎的人背负的最大债务。原因很简单：他们没有意识到已有的某种思想或方法在昨天还是一种资产，今天却已经变成了负债</li><li>我们唯一的，也是最重要的资产是我们的头脑。如果使其得到良好的训练，它转瞬间就能创造大量的财富。而未经训练的头脑有可能创造无数的贫穷来拖垮一个家庭，甚至几代人</li></ul><h2 id="反思-4"><a href="#反思-4" class="headerlink" title="反思"></a>反思</h2><ul><li>作者说得对，阻碍我们前进的并非技术性知识的缺乏，而是自我怀疑和自信的缺乏。我平时总是尽量避免风险，总是害怕血本无归，归根结底还是自己没摸清其套路</li><li>如果减少对失败的恐惧，这是一个问题，待努力</li></ul><h1 id="第六章：学会不为钱工作"><a href="#第六章：学会不为钱工作" class="headerlink" title="第六章：学会不为钱工作"></a>第六章：学会不为钱工作</h1><h2 id="本章小结-5"><a href="#本章小结-5" class="headerlink" title="本章小结"></a>本章小结</h2><h3 id="左脑时刻-5"><a href="#左脑时刻-5" class="headerlink" title="左脑时刻"></a>左脑时刻</h3><ul><li>辞去一份看似有前途的工作而去追求另一份工作，短期来看，你的薪水可能会减少；但从长远来看，你将从中获得巨大的收益</li></ul><h3 id="右脑时刻-5"><a href="#右脑时刻-5" class="headerlink" title="右脑时刻"></a>右脑时刻</h3><ul><li>==学习专业以外的其他技能将会使你受益==</li></ul><h3 id="潜意识时刻-5"><a href="#潜意识时刻-5" class="headerlink" title="潜意识时刻"></a>潜意识时刻</h3><ul><li>面对你需要学习的新技能，请务必克服内心的恐惧和懒惰。而且你必须强迫自己去学习，像去健身房一样，当你做到之后，你会感到很高兴</li></ul><h3 id="成功必需管理技能"><a href="#成功必需管理技能" class="headerlink" title="成功必需管理技能"></a>成功必需管理技能</h3><ul><li>现金流管理</li><li>系统管理</li><li>人员管理</li><li>销售技能</li><li>营销技能</li><li>沟通能力</li></ul><h2 id="语录-5"><a href="#语录-5" class="headerlink" title="语录"></a>语录</h2><ul><li>工作比破产强一点</li><li>年轻人在找工作时要看能从中学到什么，而不是只看能挣多少钱</li><li>付出金钱是那些非常富有的家庭保持富有的秘诀</li></ul><h2 id="反思-5"><a href="#反思-5" class="headerlink" title="反思"></a>反思</h2><ul><li>精通专业技能既是优势也是弱点，找工作的时候只看能挣多少钱，而没有去关注其中能学到的东西，得改</li><li>平时不愿意花钱去学习新的知识，不愿去看书、健身，自己的惰性时刻在作怪，还是没有下定决心的勇气</li></ul><h1 id="第八章：开始行动"><a href="#第八章：开始行动" class="headerlink" title="第八章：开始行动"></a>第八章：开始行动</h1><h2 id="本章小结-6"><a href="#本章小结-6" class="headerlink" title="本章小结"></a>本章小结</h2><h3 id="左脑时刻-6"><a href="#左脑时刻-6" class="headerlink" title="左脑时刻"></a>左脑时刻</h3><ul><li>用自律精神践行“首先支付自己”这一法则，以确保永远把“增加资产项”放在第一位</li></ul><h3 id="右脑时刻-6"><a href="#右脑时刻-6" class="headerlink" title="右脑时刻"></a>右脑时刻</h3><ul><li>让你的头脑对新的想法和新的做事方式保持开放，以便让新旧想法和方式交锋，擦出思想的火花</li></ul><h3 id="潜意识时刻-6"><a href="#潜意识时刻-6" class="headerlink" title="潜意识时刻"></a>潜意识时刻</h3><ul><li>挖掘“我想变得富有”的理由和目标，并不断增强这些深层次的精神动力。它们将帮助你扫除通往财务自由之路上的一切障碍</li></ul><h3 id="唤醒理财天赋的十个步骤"><a href="#唤醒理财天赋的十个步骤" class="headerlink" title="唤醒理财天赋的十个步骤"></a>唤醒理财天赋的十个步骤</h3><h4 id="精神的力量——需要一个超现实的理由"><a href="#精神的力量——需要一个超现实的理由" class="headerlink" title="精神的力量——需要一个超现实的理由"></a>精神的力量——需要一个超现实的理由</h4><ul><li>定一个强有力的理由和目标来扫除一切障碍</li><li>这些理由和目标是“想要”和“不想要”的结合体</li></ul><h4 id="选择的力量——每天做出自己的选择"><a href="#选择的力量——每天做出自己的选择" class="headerlink" title="选择的力量——每天做出自己的选择"></a>选择的力量——每天做出自己的选择</h4><ul><li>首先选择投资教育，因为我们的头脑是最强大的工具</li><li>多听，多学习。以长远的眼光来看待财富，不要有一夜暴富的念头</li><li>选择学习不同新知识，选择运动，选择投资领域等等</li></ul><h4 id="关系的力量——慎重地选择朋友"><a href="#关系的力量——慎重地选择朋友" class="headerlink" title="关系的力量——慎重地选择朋友"></a>关系的力量——慎重地选择朋友</h4><ul><li>不要听贫穷或者胆小的人的话，因为他们总会告诉你这件事为什么不行</li><li>尽量跟“内线人员”打交道，因为他们知道一些内幕消息</li></ul><h4 id="快速学习的力量——掌握一种模式，然后再学习一种新的模式"><a href="#快速学习的力量——掌握一种模式，然后再学习一种新的模式" class="headerlink" title="快速学习的力量——掌握一种模式，然后再学习一种新的模式"></a>快速学习的力量——掌握一种模式，然后再学习一种新的模式</h4><ul><li>你学到了什么，就会成为什么样的人</li><li>大多数人的赚钱模式<ul><li>上班</li><li>赚钱</li><li>支付账单</li><li>平衡支票薄</li><li>购买共同基金</li><li>然后再上班</li></ul></li><li>如果挣钱不够多，则需要探寻新的赚钱模式</li></ul><h4 id="自律的力量——首先支付自己"><a href="#自律的力量——首先支付自己" class="headerlink" title="自律的力量——首先支付自己"></a>自律的力量——首先支付自己</h4><ul><li>能够自律是将富人、穷人分开的首要因素</li><li>开创事业所必备的3种管理技能<ul><li>现金流管理</li><li>人事管理</li><li>时间管理</li></ul></li><li>何为首先支付自己，请看下图</li><li>首先支付自己的两个法则<ul><li>不要让自己背上数额过大的债务包袱。保持低支出。首先建立资产项，然后再用资产项购买大房子和豪车</li><li>当你资金短缺时，让压力去发挥作用，不要动用你的储蓄或投资。利用压力激发你的理财天赋，想出新的赚钱方法，然后支付你的账单。这样不但能让你赚到钱，还可以提高你的财商</li></ul></li></ul><p><img src="/2020/04/07/fu-ba-ba-qiong-ba-ba-du-shu-bi-ji/zhifuziji.jpg" alt="首先支付自己"></p><p><img src="/2020/04/07/fu-ba-ba-qiong-ba-ba-du-shu-bi-ji/zhifubieren.jpg" alt="首先支付别人"></p><h4 id="好建议的力量——给你的经纪人以优厚的报仇"><a href="#好建议的力量——给你的经纪人以优厚的报仇" class="headerlink" title="好建议的力量——给你的经纪人以优厚的报仇"></a>好建议的力量——给你的经纪人以优厚的报仇</h4><ul><li>信息是无价的，一位好的经纪人不仅为你提供信息，还能让你赚钱</li><li>所有的经纪人的能力并非都一样。与他们交流，了解他们拥有多少财产或投资。要找以为很关心你的利益的经纪人，并且慷慨的对待他</li></ul><h4 id="无私的力量——做一个“印第安给予者”"><a href="#无私的力量——做一个“印第安给予者”" class="headerlink" title="无私的力量——做一个“印第安给予者”"></a>无私的力量——做一个“印第安给予者”</h4><ul><li>让你的初始投资回本，并且要快速回本</li><li>“印第安给予者”：印第安人给白人一条毯子，白人以为是礼物，但是印第安人会要回毯子！</li></ul><h4 id="专注的力量——用资产购买奢侈品"><a href="#专注的力量——用资产购买奢侈品" class="headerlink" title="专注的力量——用资产购买奢侈品"></a>专注的力量——用资产购买奢侈品</h4><ul><li>增加资产以支付自己想要的东西</li></ul><h4 id="神话的力量——对英雄的崇拜"><a href="#神话的力量——对英雄的崇拜" class="headerlink" title="神话的力量——对英雄的崇拜"></a>神话的力量——对英雄的崇拜</h4><ul><li>促使孩子学习的最有效方法之一便是假装自己变成了自己最崇拜的英雄</li><li>通过偶像的模范作用，挖掘我们自身的无限潜能</li></ul><h4 id="给予的力量——先予后取"><a href="#给予的力量——先予后取" class="headerlink" title="给予的力量——先予后取"></a>给予的力量——先予后取</h4><ul><li>如果想获得，就要先给予</li><li>你给别人的越多，你学到的也越多、</li></ul><h2 id="语录-6"><a href="#语录-6" class="headerlink" title="语录"></a>语录</h2><ul><li>金矿到处都是，但是大部分人没有经过相应的培训，所以发现不了他们</li><li>没有强有力的理由和目标，任何事情都会变得非常困难</li><li>从理财角度来说，我们每挣到一美元，就得到一次选择自己称为富人、穷人的机会</li><li>轻松的道路会越走越艰难，而艰难的道路会越走越轻松</li></ul><h2 id="反思-6"><a href="#反思-6" class="headerlink" title="反思"></a>反思</h2><ul><li>为什么要变得富有，因为家庭的责任，父母的建康，孩子的教育，妹子的奢侈</li><li>目前的消费习惯是拿一部分钱买基金，拿一部分钱每个月出去吃一两顿，每年出去两三次旅游，这样的消费习惯应该是没法让自己变富的</li><li>自己的自律习惯还是得好好锻炼一下</li></ul><h1 id="第九章：要做的事情"><a href="#第九章：要做的事情" class="headerlink" title="第九章：要做的事情"></a>第九章：要做的事情</h1><h2 id="本章小结-7"><a href="#本章小结-7" class="headerlink" title="本章小结"></a>本章小结</h2><h3 id="行动指南清单"><a href="#行动指南清单" class="headerlink" title="行动指南清单"></a>行动指南清单</h3><h4 id="停下手头的活儿"><a href="#停下手头的活儿" class="headerlink" title="停下手头的活儿"></a>停下手头的活儿</h4><ul><li>休息一下，评估一下你的做法中哪些有效，哪些无效</li></ul><h4 id="寻找新的思想"><a href="#寻找新的思想" class="headerlink" title="寻找新的思想"></a>寻找新的思想</h4><ul><li>到书店搜寻能提供独特、与众不同这类主张的书</li></ul><h4 id="找一些做过你想做的事情的人"><a href="#找一些做过你想做的事情的人" class="headerlink" title="找一些做过你想做的事情的人"></a>找一些做过你想做的事情的人</h4><ul><li>请他们和你一起共进午餐，向他们请教一些诀窍和技巧</li></ul><h4 id="参加辅导班、阅读和研讨会"><a href="#参加辅导班、阅读和研讨会" class="headerlink" title="参加辅导班、阅读和研讨会"></a>参加辅导班、阅读和研讨会</h4><ul><li>从互联网上搜索新的、有趣的课程并参加</li></ul><h4 id="提出多份报价"><a href="#提出多份报价" class="headerlink" title="提出多份报价"></a>提出多份报价</h4><ul><li>大部分卖主的要价过高，很少有要价低于标的物的实际价值</li><li>提出多份报价，总会有人跟你达成购买意向，例如你提出一个低的报价，说不定对方就同意了呢</li><li>记得使用“免责条款”来做报价。例如：合同上加一条，如果我的合伙人不同意或者其他不可抗力因素，我有权取消合同（虽然你不一定有合伙人，或者合伙人也有可能是你的猫）</li></ul><h4 id="每月在某一地区慢跑、散步或驾车10分钟左右"><a href="#每月在某一地区慢跑、散步或驾车10分钟左右" class="headerlink" title="每月在某一地区慢跑、散步或驾车10分钟左右"></a>每月在某一地区慢跑、散步或驾车10分钟左右</h4><ul><li>在这个过程中发现可以投资的项目</li><li>一桩交易要盈利，得具备两个条件：<ul><li>一是廉价</li><li>二是有变化，价格变动等</li></ul></li></ul><h4 id="为什么消费者总是穷人？"><a href="#为什么消费者总是穷人？" class="headerlink" title="为什么消费者总是穷人？"></a>为什么消费者总是穷人？</h4><ul><li>利润在购买时就已确定，而不是在出售时获得的</li><li>当股市下降时，不要急于逃出</li></ul><h4 id="关注适当的地方"><a href="#关注适当的地方" class="headerlink" title="关注适当的地方"></a>关注适当的地方</h4><ul><li>学习、关注感兴趣的领域</li></ul><h4 id="首先寻找想买进的人，然后才去找想卖出的人"><a href="#首先寻找想买进的人，然后才去找想卖出的人" class="headerlink" title="首先寻找想买进的人，然后才去找想卖出的人"></a>首先寻找想买进的人，然后才去找想卖出的人</h4><ul><li>只盯着小生意的人是不会有很大突破的，得考虑买下一个大的馅饼，划分成几小块，出售给不同人</li></ul><h4 id="考虑大生意"><a href="#考虑大生意" class="headerlink" title="考虑大生意"></a>考虑大生意</h4><ul><li>多考虑大生意</li></ul><h4 id="学习前人经验"><a href="#学习前人经验" class="headerlink" title="学习前人经验"></a>学习前人经验</h4><ul><li>学习富人</li></ul><h4 id="行动起来"><a href="#行动起来" class="headerlink" title="行动起来"></a>行动起来</h4><ul><li>开始动起来</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 理财 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算广告学3-0</title>
      <link href="/2020/03/20/ji-suan-guang-gao-xue-3-0/"/>
      <url>/2020/03/20/ji-suan-guang-gao-xue-3-0/</url>
      
        <content type="html"><![CDATA[<h1 id="投放流程图"><a href="#投放流程图" class="headerlink" title="投放流程图"></a>投放流程图</h1><p><img src="/2020/03/20/ji-suan-guang-gao-xue-3-0/toufang.jpg" alt="投放流程图"></p><h1 id="CTR预估"><a href="#CTR预估" class="headerlink" title="CTR预估"></a>CTR预估</h1><h2 id="FTRL"><a href="#FTRL" class="headerlink" title="FTRL"></a>FTRL</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/55135954" target="_blank" rel="noopener">LR+FTRL算法原理以及工程化实现</a></li></ul><h1 id="流量分配"><a href="#流量分配" class="headerlink" title="流量分配"></a>流量分配</h1><h2 id="什么是流量？"><a href="#什么是流量？" class="headerlink" title="什么是流量？"></a>什么是流量？</h2><ul><li>流量就是媒体拥有的用户数据，例如：抖音的用户数据</li></ul><h2 id="什么是流量分配？"><a href="#什么是流量分配？" class="headerlink" title="什么是流量分配？"></a>什么是流量分配？</h2><ul><li><p>DSP根据媒体给的流量给不同的广告主分配其需要的流量</p></li><li><p>结合转化函数与广告主导量要求来分配流量</p></li></ul><h1 id="出价"><a href="#出价" class="headerlink" title="出价"></a>出价</h1>]]></content>
      
      
      <categories>
          
          <category> AI/数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据科学 </tag>
            
            <tag> 计算广告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka</title>
      <link href="/2020/01/02/kafka/"/>
      <url>/2020/01/02/kafka/</url>
      
        <content type="html"><![CDATA[<h1 id="Kafka基础"><a href="#Kafka基础" class="headerlink" title="Kafka基础"></a>Kafka基础</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="Kafka是什么？"><a href="#Kafka是什么？" class="headerlink" title="Kafka是什么？"></a>Kafka是什么？</h3><ul><li>Apache Kafka是一个分布式流平台</li><li>Kafka作为一个集群运行在一个或多个服务器上，这些服务器可以跨越多个数据中心</li><li>Kafka集群将记录流存储在称为主题<code>Topic</code>的类别中</li><li><strong>每个记录由一个键<code>key</code>、一个值<code>value</code>和一个时间戳<code>timestamp</code>组成</strong></li></ul><h3 id="流平台的关键特性"><a href="#流平台的关键特性" class="headerlink" title="流平台的关键特性"></a>流平台的关键特性</h3><ul><li>发布和订阅记录流，类似于消息队列或企业消息传递系统</li><li>以容错的持久方式存储记录流</li><li>处理记录流（当它们发生时）</li></ul><h3 id="Kafka的应用领域"><a href="#Kafka的应用领域" class="headerlink" title="Kafka的应用领域"></a>Kafka的应用领域</h3><ul><li>构建实时流数据管道，在系统或应用程序之间可靠地获取数据</li><li>构建转换或响应数据流的实时流应用程序</li></ul><h3 id="Kafka的四个核心API"><a href="#Kafka的四个核心API" class="headerlink" title="Kafka的四个核心API"></a>Kafka的四个核心API</h3><p><img src="/2020/01/02/kafka/kafka-apis.png" alt="Kafka-APIs"></p><ul><li><a href="https://kafka.apache.org/documentation.html#producerapi" target="_blank" rel="noopener">Producer API</a>：允许应用程序将记录流发布到一个或多个Kafka主题<code>Topic</code></li><li><a href="https://kafka.apache.org/documentation.html#consumerapi" target="_blank" rel="noopener">Consumer API</a>：允许应用程序订阅一个或多个主题<code>Topic</code>，并处理产生给它们的记录流。</li><li><a href="https://kafka.apache.org/documentation.html#connectapi" target="_blank" rel="noopener">Streams API</a>：允许应用程序充当流处理器，使用一个或多个主题<code>Topic</code>的输入流，并生成一个或多个输出主题<code>Topic</code>的输出流，从而有效地将输入流转换为输出流</li><li><a href="https://kafka.apache.org/documentation.html#connectapi" target="_blank" rel="noopener">Connector API</a>：允许构建和运行将Kafka主题<code>Topic</code>连接到现有应用程序或数据库的可重用生产者或消费者。例如，到关系数据库的连接器可能捕获对表的每个更改。</li></ul><h3 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h3><ul><li>在Kafka中，客户端和服务器之间的通信是通过一个简单的、高性能的、语言无关的<code>TCP</code>协议来完成的。此协议经过版本控制，并保持与旧版本的向后兼容性</li></ul><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="主题-Topics"><a href="#主题-Topics" class="headerlink" title="主题[Topics]"></a>主题<code>[Topics]</code></h3><ul><li>主题是被发布记录所属类别或订阅源的名词</li><li>一个主题可以有零个，一个或多个消费者来订阅写入该主题的数据</li></ul><h3 id="日志-Logs"><a href="#日志-Logs" class="headerlink" title="日志[Logs]"></a>日志<code>[Logs]</code></h3><ul><li>对于每个主题，Kafka集群维护一个类似下图的分区日志</li></ul><p><img src="/2020/01/02/kafka/log_anatomy.png" alt="log_anatomy"></p><ul><li>每个分区都是有序的，不可变的记录序列，这些记录连续地附加到结构化的提交日志中</li><li>每个分区中的记录都分配有一个称为<strong>偏移</strong>的顺序ID号，该ID唯一地标识分区中的每个记录</li><li>Kafka集群使用可配置的保留期限持久保留所有已发布记录（无论是否已使用它们），超过保留期限后，记录将被丢弃以释放空间</li><li><p>Kafka的性能在数据大小方面是稳定的，所以<strong>长时间存储数据不是问题</strong></p></li><li><p>如下图，偏移量由使用者控制：通常，使用者在读取记录时会线性地推进其偏移量，但是实际上，由于位置是由使用者控制的，因此它可以按喜欢的任何顺序使用记录。 例如，使用者可以重置到较旧的偏移量以重新处理过去的数据，或者跳到最近的记录并从“现在”开始使用。</p></li></ul><p><img src="/2020/01/02/kafka/log_consumer.png" alt="log_consumer"></p><ul><li>这些特性的组合意味着Kafka消费者非常便宜，他们可以来去自如，对集群或其他消费者没有太大影响。例如，您可以使用命令行工具“跟踪”任何主题的内容，而不需要更改任何现有使用者所使用的内容</li><li>日志中的分区有多种用途。 首先，它们允许日志扩展到超出单个服务器所能容纳的大小。 每个单独的分区都必须适合托管它的服务器，但是一个主题可能有很多分区，因此它可以处理任意数量的数据。 其次，它们充当并行性的单元</li></ul><h3 id="分布-Distribution"><a href="#分布-Distribution" class="headerlink" title="分布[Distribution]"></a>分布<code>[Distribution]</code></h3><ul><li>日志的分区分布在Kafka群集中的服务器上，每个服务器处理数据并要求共享分区。 </li><li>每个分区都在可配置数量的服务器之间复制，以实现容错功能</li><li>每个分区有一个充当“领导者”的服务器和零个或多个充当“追随者”的服务器</li><li>领导者处理该分区的所有读写请求，而追随者则被动复制领导者</li><li>如果领导者失败，则追随者之一将自动成为新领导者</li><li>每个服务器既充当某些分区的领导者，又充当其他分区的追随者，这样集群中的负载得到了很好的平衡</li></ul><h3 id="异地备份-Geo-Replication"><a href="#异地备份-Geo-Replication" class="headerlink" title="异地备份[Geo-Replication]"></a>异地备份<code>[Geo-Replication]</code></h3><ul><li>Kafka MirrorMaker为集群提供异地备份支持</li><li>使用MirrorMaker，消息可以跨多个数据中心或云区域进行备份</li><li>您可以在主动/被动方案中使用它进行备份和恢复，或在主动/主动方案中将数据放置在离您的用户更近的位置，或支持本地数据需求</li></ul><h3 id="生产者-Producers"><a href="#生产者-Producers" class="headerlink" title="生产者[Producers]"></a>生产者<code>[Producers]</code></h3><ul><li>生产者将数据发布到他们选择的主题</li><li>生产者负责选择将哪个记录分配给主题中的哪个分区</li><li>这可以以循环的方式来完成，只是为了平衡负载，也可以根据某种语义划分函数来完成(比如基于记录中的某个键)</li></ul><h3 id="消费者-Consumers"><a href="#消费者-Consumers" class="headerlink" title="消费者[Consumers]"></a>消费者<code>[Consumers]</code></h3><ul><li>消费者使用消费者组名称标记自己，并且发布到主题的每条记录都会传递到每个订阅消费者组中的一个消费者实例</li><li>消费者实例可以在单独的进程中或在单独的机器上</li><li>如果所有消费者实例具有相同的消费者组，那么记录将有效地在消费者实例上进行负载平衡</li><li>如果所有消费者实例都有不同的消费者组，那么每个记录将被广播到所有消费者进程</li></ul><p><strong>举例如下图：</strong></p><p><img src="/2020/01/02/kafka/consumer-groups.png" alt="log_consumer"></p><ul><li>一个包含四个分区（P0-P3）和两个消费者组的两台服务器【Kafka集群】</li><li>消费者组A有两个消费者实例（C1、C2），而组B有四个（C3-C6）</li><li>Kafka中实现消费的方法是在消费者实例的日志中划分分区，这样每个实例在任何时候都是分区“公平共享”的唯一消费者</li><li>这个保持组成员身份的过程是由Kafka协议动态处理的</li><li>如果新的实例加入组，它们将从组的其他成员那里接管一些分区</li><li>如果一个实例死亡，它的分区将分配给其余的实例</li><li>如图中：消费者组A中C1负责P0\P3，C2负责P1\P2；消费者组B中每个实例负责一个分区</li><li>Kafka只提供分区内记录的总顺序，而不提供主题中不同分区之间的总顺序</li><li>对大多数应用程序来说，按分区排序和按键分区数据的能力已经足够</li><li>但是，如果需要记录的总顺序，则可以使用只有一个分区的主题来实现</li><li>尽管这意味着每个使用者组只有一个使用者进程（一个使用者实例？）</li></ul><h3 id="多租户-Multi-tenancy"><a href="#多租户-Multi-tenancy" class="headerlink" title="多租户[Multi-tenancy]"></a>多租户<code>[Multi-tenancy]</code></h3><ul><li>可以将Kafka部署为多租户解决方案</li><li>通过配置哪些主题可以生成或使用数据，可以启用多租户</li><li>还有对限额的操作支持</li><li>管理员可以对请求定义和强制配额，以控制客户端使用的代理资源</li><li>有关更多信息，请参阅<a href="https://kafka.apache.org/documentation/#security" target="_blank" rel="noopener">安全文档</a></li></ul><h3 id="保证性-Guarantees"><a href="#保证性-Guarantees" class="headerlink" title="保证性[Guarantees]"></a>保证性<code>[Guarantees]</code></h3><p>在较高级别上，Kafka提供以下保证：</p><ul><li>生产者发送到特定主题分区的消息将按照发送的顺序追加<ol><li>也就是说，如果记录M1是由与记录M2相同的生产者发送的，并且M1是先发送的，那么M1的偏移量将比M2低，并出现在日志的前面</li></ol></li><li>消费者实例按【记录在日志中存储的顺序】查看记录</li><li>对于具有复制因子N的主题，我们将容忍至多N-1个服务器故障，而不会丢失提交到日志的任何记录</li></ul><h1 id="Kafka进阶"><a href="#Kafka进阶" class="headerlink" title="Kafka进阶"></a>Kafka进阶</h1><h2 id="Kafka作为消息传递系统-Kafka-as-a-Messaging-System"><a href="#Kafka作为消息传递系统-Kafka-as-a-Messaging-System" class="headerlink" title="Kafka作为消息传递系统[Kafka as a Messaging System]"></a>Kafka作为消息传递系统<code>[Kafka as a Messaging System]</code></h2><h3 id="传统的企业消息传递系统"><a href="#传统的企业消息传递系统" class="headerlink" title="传统的企业消息传递系统"></a>传统的企业消息传递系统</h3><p>传统的消息传递系统拥有两个模块：</p><h4 id="队列-queuing"><a href="#队列-queuing" class="headerlink" title="队列-queuing"></a>队列-queuing</h4><ul><li>在队列中，消费者池可以从服务器读取数据，而每条记录都将被发送到其中的一位消费者</li><li>队列的优点是它允许在多个消费者实例上划分数据处理</li><li>不幸的是，队列不是多用户的：一旦一个进程读取了数据，其他用户就读取不了了</li><li>传统队列在服务器上按顺序保留记录，如果多个使用者从队列中消费，则服务器按存储记录的顺序分发记录</li><li>然而，尽管服务器按顺序分发记录，但这些记录是异步传递给消费者的，因此它们可能在不同的消费者上不按顺序到达</li><li>这实际上意味着记录的顺序在并行使用时丢失</li><li>消息传递系统通常通过“独占消费者”的概念来解决这个问题，该概念只允许一个进程从队列中消费，但这当然意味着处理中不存在并行性</li></ul><h4 id="发布-订阅-publish-subscribe"><a href="#发布-订阅-publish-subscribe" class="headerlink" title="发布-订阅-publish-subscribe"></a>发布-订阅-publish-subscribe</h4><ul><li>在发布-订阅中，记录被广播给所有消费者</li><li>发布-订阅允许将数据广播到多个进程，但是由于每个消息都传递到每个订阅者，因此无法扩展处理</li></ul><h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><ul><li>Kafka中的消费者组概念概括了队列＆发布-订阅</li><li>与队列一样，消费者组允许将处理划分到一组进程(消费者组的成员)上</li><li>与发布-订阅一样，Kafka允许向多个消费者组广播消息</li><li>Kafka也比传统的消息传递系统有更强的订购保证</li><li>通过对主题内分区的并行性的概念，Kafka能够在用户进程池上提供<strong>排序保证</strong>和<strong>负载平衡</strong></li><li>这是通过将主题中的分区分配给消费者组中的消费者实例来实现的，这样每个分区正好由组中的一个消费者使用</li><li>通过这样做，我们可以确保消费者是该分区的唯一读取者，并按顺序使用数据</li><li>由于有许多分区，这仍然可以在许多消费者实例上平衡负载</li><li>但是请注意，在一个消费者组中<strong>不能有比分区更多</strong>的消费者实例</li></ul><h1 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h1><ul><li><a href="https://kafka.apache.org/documentation/" target="_blank" rel="noopener">官网文档</a></li></ul><h1 id="疑难解答"><a href="#疑难解答" class="headerlink" title="疑难解答"></a>疑难解答</h1>]]></content>
      
      
      <categories>
          
          <category> AI/数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> 消息系统 </tag>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Storm</title>
      <link href="/2019/12/17/storm/"/>
      <url>/2019/12/17/storm/</url>
      
        <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="Storm是什么？"><a href="#Storm是什么？" class="headerlink" title="Storm是什么？"></a>Storm是什么？</h3><ul><li>Storm是Apache下的一个<strong>分布式实时</strong>大数据处理系统</li></ul><h3 id="Storm优势"><a href="#Storm优势" class="headerlink" title="Storm优势"></a>Storm优势</h3><ul><li>实时流</li><li>快</li><li>数据处理保证</li><li>容错</li></ul><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p><img src="/2019/12/17/storm/core_concept.jpg" alt="图：storm拓扑"></p><h4 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h4><ul><li>主要数据结构，有序元素的列表</li><li>默认情况支持所有数据类型</li><li>通常是一组逗号分隔的值</li></ul><h4 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h4><ul><li>Tuple的无序序列</li></ul><h4 id="Spouts"><a href="#Spouts" class="headerlink" title="Spouts"></a>Spouts</h4><ul><li>Stream的源头</li><li>通常，Storm从原始数据源（Kafka队列等）接受数据</li><li>也可以通过编写Spouts从数据源读取数据</li><li>“ISpout”是实现Spout的核心接口</li><li>一些特定的接口包括：IRichSpout，BaseRichSpout，KafkaSpout等</li></ul><h4 id="Bolts"><a href="#Bolts" class="headerlink" title="Bolts"></a>Bolts</h4><ul><li>逻辑处理单元</li><li>可以执行过滤、聚合等数据操作</li><li>“IBolt”是实现Bolt的核心接口</li><li>一些特定的接口包括：IRichBolt，IBasicBolt等</li></ul><h3 id="拓扑"><a href="#拓扑" class="headerlink" title="拓扑"></a>拓扑</h3><ul><li>图：storm拓扑就是一个拓扑</li><li>Spouts和Bolts连接就形成拓扑结构</li><li>拓扑是有向图，顶点是计算，边是数据流</li><li>Storm始终保持拓扑运行直到你终止且主要工作就是运行拓扑</li></ul><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><ul><li>Storm执行的每个Spout和Bolt被称为任务</li></ul><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ul><li>一个拓扑中的顶点被分布到多个<strong>工作节点</strong>上分布式运行</li><li>Storm将所有工作节点上的任务均匀分布</li><li>工作节点的角色是监听作业，并在新作业到达时启动或停止进程</li></ul><h3 id="流分组"><a href="#流分组" class="headerlink" title="流分组"></a>流分组</h3><p>数据流从Spouts流到Bolts，或从一个Bolts流到另一个Bolts时，则需要分组控制，有以下四种分组方式</p><h4 id="随机分组"><a href="#随机分组" class="headerlink" title="随机分组"></a>随机分组</h4><ul><li>相等数量的Tuples随机分布在执行Bolts的所有worker（包含工作节点和工作节点进程）中</li></ul><h4 id="字段分组"><a href="#字段分组" class="headerlink" title="字段分组"></a>字段分组</h4><ul><li>Tuples中具有相同字段的分配给同一个worker</li></ul><h4 id="全局分组"><a href="#全局分组" class="headerlink" title="全局分组"></a>全局分组</h4><ul><li>所有Tuples分配给同一个worker</li></ul><h4 id="所有分组"><a href="#所有分组" class="headerlink" title="所有分组"></a>所有分组</h4><ul><li>将所有Tuples都建立副本，并分配给所有的worker</li></ul><h2 id="集群架构"><a href="#集群架构" class="headerlink" title="集群架构"></a>集群架构</h2><h3 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h3><p><img src="/2019/12/17/storm/storm_structure.jpg" alt="图：storm集群架构"></p><h3 id="组件-1"><a href="#组件-1" class="headerlink" title="组件"></a>组件</h3><h4 id="Nimbus（主节点）"><a href="#Nimbus（主节点）" class="headerlink" title="Nimbus（主节点）"></a>Nimbus（主节点）</h4><ul><li>集群的主节点</li><li>负责给工作节点分发任务和数据</li><li>监听各工作节点的故障</li></ul><h4 id="Supervisor（工作节点）"><a href="#Supervisor（工作节点）" class="headerlink" title="Supervisor（工作节点）"></a>Supervisor（工作节点）</h4><ul><li>除了主节点的其他节点</li><li>完成主节点分配任务的节点</li><li>至少有一个工作进程</li></ul><h4 id="Worker-process（工作进程）"><a href="#Worker-process（工作进程）" class="headerlink" title="Worker process（工作进程）"></a>Worker process（工作进程）</h4><ul><li>执行与特点拓扑相关的任务</li><li>不会自己运行任务</li><li>通过创建执行器Executor来执行特点的任务</li><li>拥有多个执行器Executor</li></ul><h4 id="Executor（执行器）"><a href="#Executor（执行器）" class="headerlink" title="Executor（执行器）"></a>Executor（执行器）</h4><ul><li>工作进程产生的单个线程</li><li>至少运行一个任务</li><li>仅用于特定的Spout或Bolt</li></ul><h4 id="Task（任务）"><a href="#Task（任务）" class="headerlink" title="Task（任务）"></a>Task（任务）</h4><ul><li>处理实际的数据</li><li>要么是Spout，要么是Bolt</li></ul><h4 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h4><ul><li>Nimbus是无状态的，所以需要ZooKeeper来监视工作节点的状态</li><li>通过ZooKeeper来监视状态，这样故障的网络就可以重新启动</li></ul><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="/2019/12/17/storm/storm_job_process.jpg" alt="图：storm工作流程"></p><h3 id="详细流程介绍"><a href="#详细流程介绍" class="headerlink" title="详细流程介绍"></a>详细流程介绍</h3><ol><li>Nimbus等待客户端提交拓扑任务</li><li>Nimbus创建任务的本地目录并将任务上传至<code>$STORM_HOME/tmp/nimbus/inbox/</code></li><li>Nimbus从ZooKeeper监控工作节点的心跳并计算拓扑的工作量</li><li>Nimbus将任务分配信息写入ZooKeeper</li><li>工作节点监听ZooKeeper的信息，当有任务分配时，启动任务的拓扑</li><li>工作节点启动任务拓扑后，启动相应数目的worker进程</li><li>由worker进程来执行任务（Spout或Bolt）</li></ol><h2 id="分布式消息系统"><a href="#分布式消息系统" class="headerlink" title="分布式消息系统"></a>分布式消息系统</h2><h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><ul><li>详情请见<a href="/2020/01/02/kafka/" title="Kafka笔记">Kafka笔记</a></li></ul><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><h1 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h1><ul><li><a href="https://www.w3cschool.cn/apache_storm/" target="_blank" rel="noopener">Apache Storm教程</a></li></ul><h1 id="疑难解答"><a href="#疑难解答" class="headerlink" title="疑难解答"></a>疑难解答</h1>]]></content>
      
      
      <categories>
          
          <category> AI/数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> Storm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark</title>
      <link href="/2019/12/12/spark/"/>
      <url>/2019/12/12/spark/</url>
      
        <content type="html"><![CDATA[<h1 id="Spark基础"><a href="#Spark基础" class="headerlink" title="Spark基础"></a>Spark基础</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>Spark是UC Berkeley AMP lab所开源的类似Hadoop MapReduce的通用并行框架，它能更好地适用于数据挖掘与机器学习等需要迭代的MapReduce的算法。</li></ul><h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><h4 id="运行速度快："><a href="#运行速度快：" class="headerlink" title="运行速度快："></a>运行速度快：</h4><ul><li>Spark使用先进的DAG（Directed Acyclic Graph，有向无环图）执行引擎，以支持循环数据流与内存计算，基于内存的执行速度可比Hadoop MapReduce快上百倍，基于磁盘的执行速度也能快十倍；</li></ul><h4 id="容易使用："><a href="#容易使用：" class="headerlink" title="容易使用："></a>容易使用：</h4><ul><li>Spark支持使用Scala、Java、Python和R语言进行编程，简洁的API设计有助于用户轻松构建并行程序，并且可以通过Spark Shell进行交互式编程；</li></ul><h4 id="通用性："><a href="#通用性：" class="headerlink" title="通用性："></a>通用性：</h4><ul><li>Spark提供了完整而强大的技术栈，包括SQL查询、流式计算、机器学习和图算法组件，这些组件可以无缝整合在同一个应用中，足以应对复杂的计算；</li></ul><h4 id="运行模式多样："><a href="#运行模式多样：" class="headerlink" title="运行模式多样："></a>运行模式多样：</h4><ul><li>Spark可运行于独立的集群模式中，或者运行于Hadoop中，也可运行于Amazon EC2等云环境中，并且可以访问HDFS、Cassandra、HBase、Hive等多种数据源。</li><li>Spark的计算模式也属于MapReduce，但不局限于Map和Reduce操作，还提供了多种数据集操作类型，编程模型比MapReduce更灵活；</li><li>Spark提供了内存计算，中间结果直接放到内存中，带来了更高的迭代运算效率；</li><li>Spark基于DAG的任务调度执行机制，要优于MapReduce的迭代执行机制。</li></ul><h2 id="生态系统"><a href="#生态系统" class="headerlink" title="生态系统"></a>生态系统</h2><h3 id="大数据处理类型"><a href="#大数据处理类型" class="headerlink" title="大数据处理类型"></a>大数据处理类型</h3><h4 id="复杂的批量数据处理："><a href="#复杂的批量数据处理：" class="headerlink" title="复杂的批量数据处理："></a>复杂的批量数据处理：</h4><ul><li>时间跨度通常在数十分钟到数小时之间；</li><li>Hadoop MapReduce</li></ul><h4 id="基于历史数据的交互式查询："><a href="#基于历史数据的交互式查询：" class="headerlink" title="基于历史数据的交互式查询："></a>基于历史数据的交互式查询：</h4><ul><li>时间跨度通常在数十秒到数分钟之间；</li><li>Impala：Impala与Hive相似，但底层引擎不同，提供了实时交互式</li><li>SQL查询</li></ul><h4 id="基于实时数据流的数据处理："><a href="#基于实时数据流的数据处理：" class="headerlink" title="基于实时数据流的数据处理："></a>基于实时数据流的数据处理：</h4><ul><li>时间跨度通常在数百毫秒到数秒之间</li><li>Storm：开源流计算框架</li></ul><h4 id="Spark所提供的生态系统足以应对上述三种场景"><a href="#Spark所提供的生态系统足以应对上述三种场景" class="headerlink" title="Spark所提供的生态系统足以应对上述三种场景"></a>Spark所提供的生态系统足以应对上述三种场景</h4><ul><li>即同时支持批处理、交互式查询和流数据处理。</li></ul><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><h4 id="访问和接口"><a href="#访问和接口" class="headerlink" title="访问和接口"></a>访问和接口</h4><h5 id="Spark-Streaming"><a href="#Spark-Streaming" class="headerlink" title="Spark Streaming"></a>Spark Streaming</h5><p><a href="https://spark.apache.org/docs/latest/streaming-programming-guide.html" target="_blank" rel="noopener">https://spark.apache.org/docs/latest/streaming-programming-guide.html</a></p><p>Spark Streaming支持高吞吐量、可容错处理的实时流数据处理，其核心思路是将流式计算分解成一系列短小的批处理作业。Spark Streaming支持多种数据输入源，如Kafka、Flume和TCP套接字等；</p><p>kafka：<a href="https://www.w3cschool.cn/apache_kafka/" target="_blank" rel="noopener">https://www.w3cschool.cn/apache_kafka/</a></p><p>Flume：<a href="https://juejin.im/post/5be4e549f265da61441f8dbe" target="_blank" rel="noopener">https://juejin.im/post/5be4e549f265da61441f8dbe</a></p><p>TCP：<a href="http://www.ruanyifeng.com/blog/2017/06/tcp-protocol.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2017/06/tcp-protocol.html</a></p><h5 id="BlinkDB"><a href="#BlinkDB" class="headerlink" title="BlinkDB"></a>BlinkDB</h5><ul><li>BlinkDB 是一个用于在海量数据上运行交互式 SQL 查询的大规模并行查询引擎。</li></ul><h5 id="Spark-Sql"><a href="#Spark-Sql" class="headerlink" title="Spark Sql"></a>Spark Sql</h5><ul><li><a href="https://spark.apache.org/docs/latest/sql-programming-guide.html" target="_blank" rel="noopener">https://spark.apache.org/docs/latest/sql-programming-guide.html</a></li><li>Spark SQL允许开发人员直接处理RDD，同时也可查询Hive、HBase等外部数据源。Spark SQL的一个重要特点是其能够统一处理关系表和RDD，使得开发人员可以轻松地使用SQL命令进行查询，并进行更复杂的数据分析；</li></ul><h5 id="GraphX"><a href="#GraphX" class="headerlink" title="GraphX"></a>GraphX</h5><ul><li><a href="https://spark.apache.org/docs/latest/graphx-programming-guide.html" target="_blank" rel="noopener">https://spark.apache.org/docs/latest/graphx-programming-guide.html</a></li><li>GraphX是Spark中用于图计算的API，可认为是Pregel在Spark上的重写及优化，Graphx性能良好，拥有丰富的功能和运算符，能在海量数据上自如地运行复杂的图算法。</li></ul><h5 id="MLBase"><a href="#MLBase" class="headerlink" title="MLBase"></a>MLBase</h5><ul><li><a href="https://amplab.cs.berkeley.edu/publication/mlbase-a-distributed-machine-learning-system/" target="_blank" rel="noopener">https://amplab.cs.berkeley.edu/publication/mlbase-a-distributed-machine-learning-system/</a></li></ul><h5 id="MlLib"><a href="#MlLib" class="headerlink" title="MlLib"></a>MlLib</h5><ul><li><a href="https://spark.apache.org/docs/latest/ml-guide.html" target="_blank" rel="noopener">https://spark.apache.org/docs/latest/ml-guide.html</a></li><li>MLlib提供了常用机器学习算法的实现，包括聚类、分类、回归、协同过滤等，降低了机器学习的门槛，开发人员只要具备一定的理论知识就能进行机器学习的工作；</li></ul><h4 id="处理引擎"><a href="#处理引擎" class="headerlink" title="处理引擎"></a>处理引擎</h4><h5 id="Spark-Core"><a href="#Spark-Core" class="headerlink" title="Spark Core"></a>Spark Core</h5><ul><li><a href="https://blog.csdn.net/bingoxubin/article/details/79076978" target="_blank" rel="noopener">https://blog.csdn.net/bingoxubin/article/details/79076978</a></li><li>Spark Core包含Spark的基本功能，如内存计算、任务调度、部署模式、故障恢复、存储管理等。Spark建立在统一的抽象RDD之上，使其可以以基本一致的方式应对不同的大数据处理场景；通常所说的Apache Spark，就是指Spark Core；</li></ul><h4 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h4><h5 id="Tachyon"><a href="#Tachyon" class="headerlink" title="Tachyon"></a>Tachyon</h5><ul><li><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-spark-tachyon/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/opensource/os-cn-spark-tachyon/</a></li></ul><h5 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h5><ul><li><a href="https://hadoop.apache.org/docs/r1.0.4/cn/hdfs_design.html" target="_blank" rel="noopener">https://hadoop.apache.org/docs/r1.0.4/cn/hdfs_design.html</a></li></ul><h5 id="Amazon-S3"><a href="#Amazon-S3" class="headerlink" title="Amazon S3"></a>Amazon S3</h5><ul><li><a href="https://aws.amazon.com/cn/s3/" target="_blank" rel="noopener">https://aws.amazon.com/cn/s3/</a></li></ul><h4 id="资源管理调度"><a href="#资源管理调度" class="headerlink" title="资源管理调度"></a>资源管理调度</h4><h5 id="Mesos"><a href="#Mesos" class="headerlink" title="Mesos"></a>Mesos</h5><ul><li><a href="http://mesos.apache.org/" target="_blank" rel="noopener">http://mesos.apache.org/</a></li></ul><h5 id="Hadoop-YARN"><a href="#Hadoop-YARN" class="headerlink" title="Hadoop YARN"></a>Hadoop YARN</h5><ul><li><a href="https://hadoop.apache.org/docs/current/hadoop-yarn/hadoop-yarn-site/YARN.html" target="_blank" rel="noopener">https://hadoop.apache.org/docs/current/hadoop-yarn/hadoop-yarn-site/YARN.html</a></li></ul><h2 id="运行架构"><a href="#运行架构" class="headerlink" title="运行架构"></a>运行架构</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="RDD："><a href="#RDD：" class="headerlink" title="RDD："></a>RDD：</h4><ul><li>是弹性分布式数据集（Resilient Distributed Dataset）的简称，是分布式内存的一个抽象概念，提供了一种高度受限的共享内存模型；</li></ul><h4 id="DAG："><a href="#DAG：" class="headerlink" title="DAG："></a>DAG：</h4><ul><li>是Directed Acyclic Graph（有向无环图）的简称，反映RDD之间的依赖关系；</li></ul><h4 id="Executor："><a href="#Executor：" class="headerlink" title="Executor："></a>Executor：</h4><ul><li>是运行在工作节点（Worker Node）上的一个进程，负责运行任务，并为应用程序存储数据；</li></ul><h5 id="Spark所采用的Executor有两个优点"><a href="#Spark所采用的Executor有两个优点" class="headerlink" title="Spark所采用的Executor有两个优点"></a>Spark所采用的Executor有两个优点</h5><ul><li>一是利用多线程来执行具体的任务（Hadoop MapReduce采用的是进程模型），减少任务的启动开销；</li><li>二是Executor中有一个BlockManager存储模块，会将内存和磁盘共同作为存储设备，当需要多轮迭代计算时，可以将中间结果存储到这个存储模块里，下次需要时，就可以直接读该存储模块里的数据，而不需要读写到HDFS等文件系统里，因而有效减少了IO开销；或者在交互式查询场景下，预先将表缓存到该存储系统上，从而可以提高读写IO性能。</li></ul><h4 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h4><ul><li>用户编写的Spark应用程序；</li></ul><h4 id="任务："><a href="#任务：" class="headerlink" title="任务："></a>任务：</h4><ul><li>运行在Executor上的工作单元；</li></ul><h4 id="作业："><a href="#作业：" class="headerlink" title="作业："></a>作业：</h4><ul><li>一个作业包含多个RDD及作用于相应RDD上的各种操作；</li></ul><h4 id="阶段："><a href="#阶段：" class="headerlink" title="阶段："></a>阶段：</h4><ul><li>是作业的基本调度单位，一个作业会分为多组任务，每组任务被称为“阶段”，或者也被称为“任务集”。</li></ul><h3 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h3><h4 id="集群资源管理器（Cluster-Manager）"><a href="#集群资源管理器（Cluster-Manager）" class="headerlink" title="集群资源管理器（Cluster Manager）"></a>集群资源管理器（Cluster Manager）</h4><ul><li>可以是Spark自带的资源管理器，也可以是YARN或Mesos等资源管理框架。</li></ul><h4 id="运行作业任务的工作节点（Worker-Node）"><a href="#运行作业任务的工作节点（Worker-Node）" class="headerlink" title="运行作业任务的工作节点（Worker Node）"></a>运行作业任务的工作节点（Worker Node）</h4><h4 id="每个应用的任务控制节点（Driver）"><a href="#每个应用的任务控制节点（Driver）" class="headerlink" title="每个应用的任务控制节点（Driver）"></a>每个应用的任务控制节点（Driver）</h4><h4 id="每个工作节点上负责具体任务的执行进程（Executor）"><a href="#每个工作节点上负责具体任务的执行进程（Executor）" class="headerlink" title="每个工作节点上负责具体任务的执行进程（Executor）"></a>每个工作节点上负责具体任务的执行进程（Executor）</h4><h3 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h3><ol><li>当一个Spark应用被提交时，首先需要为这个应用构建起基本的运行环境，即由任务控制节点（Driver）创建一个SparkContext，由SparkContext负责和资源管理器（Cluster Manager）的通信以及进行资源的申请、任务的分配和监控等。SparkContext会向资源管理器注册并申请运行Executor的资源；</li><li>资源管理器为Executor分配资源，并启动Executor进程，Executor运行情况将随着“心跳”发送到资源管理器上；</li><li>SparkContext根据RDD的依赖关系构建DAG图，DAG图提交给DAG调度器（DAGScheduler）进行解析，将DAG图分解成多个“阶段”（每个阶段都是一个任务集），并且计算出各个阶段之间的依赖关系，然后把一个个“任务集”提交给底层的任务调度器（TaskScheduler）进行处理；Executor向SparkContext申请任务，任务调度器将任务分发给Executor运行，同时，SparkContext将应用程序代码发放给Executor；</li><li>任务在Executor上运行，把执行结果反馈给任务调度器，然后反馈给DAG调度器，运行完毕后写入数据并释放所有资源。</li></ol><h3 id="运行架构特点"><a href="#运行架构特点" class="headerlink" title="运行架构特点"></a>运行架构特点</h3><pre><code>        *  每个应用都有自己专属的Executor进程，并且该进程在应用运行期间一直驻留。Executor进程以多线程的方式运行任务，减少了多进程任务频繁的启动开销，使得任务执行变得非常高效和可靠；        *  Spark运行过程与资源管理器无关，只要能够获取Executor进程并保持通信即可；        *  Executor上有一个BlockManager存储模块，类似于键值存储系统（把内存和磁盘共同作为存储设备），在处理迭代计算任务时，不需要把中间结果写入到HDFS等文件系统，而是直接放在这个存储系统上，后续有需要时就可以直接读取；在交互式查询场景下，也可以把表提前缓存到这个存储系统上，提高读写IO性能；        *  任务采用了数据本地性和推测执行等优化机制。数据本地性是尽量将计算移到数据所在的节点上进行，即“计算向数据靠拢”，因为移动计算比移动数据所占的网络资源要少得多。而且，Spark采用了延时调度机制，可以在更大的程度上实现执行过程优化。比如，拥有数据的节点当前正被其他的任务占用，那么，在这种情况下是否需要将数据移动到其他的空闲节点呢？答案是不一定。因为，如果经过预测发现当前节点结束当前任务的时间要比移动数据的时间还要少，那么，调度就会等待，直到当前节点可用。</code></pre><h2 id="RDD的设计与运行原理"><a href="#RDD的设计与运行原理" class="headerlink" title="RDD的设计与运行原理"></a>RDD的设计与运行原理</h2><h3 id="RDD概念"><a href="#RDD概念" class="headerlink" title="RDD概念"></a>RDD概念</h3><ul><li><p>一个RDD就是一个分布式对象集合，本质上是一个只读的分区记录集合，每个RDD可以分成多个分区，每个分区就是一个数据集片段，并且一个RDD的不同分区可以被保存到集群中不同的节点上，从而可以在集群中的不同节点上进行并行计算。</p></li><li><p>RDD提供了一种高度受限的共享内存模型，即RDD是只读的记录分区的集合，不能直接修改，只能基于稳定的物理存储中的数据集来创建RDD，或者通过在其他RDD上执行确定的转换操作（如map、join和groupBy）而创建得到新的RDD。</p></li><li><p>RDD提供了一组丰富的操作以支持常见的数据运算，分为“行动”（Action）和“转换”（Transformation）两种类型，</p><ol><li>行动：行动操作（比如count、collect等）接受RDD但是返回非RDD（即输出一个值或结果）</li><li>转换：转换操作（比如map、filter、groupBy、join等）接受RDD并返回RDD</li></ol><p><strong>注意事项：</strong></p><p>适合：对于数据集中元素执行相同操作的批处理式应用</p><p>不适合：不适合用于需要异步、细粒度状态的应用，比如Web应用系统、增量式的网页爬虫等</p></li></ul><h4 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h4><ul><li>RDD读入外部数据源（或者内存中的集合）进行创建；</li><li>RDD经过一系列的“转换”操作，每一次都会产生不同的RDD，供给下一个“转换”使用；</li><li>最后一个RDD经“行动”操作进行处理，并输出到外部数据源（或者变成Scala集合或标量）。</li></ul><h3 id="RDD特性"><a href="#RDD特性" class="headerlink" title="RDD特性"></a>RDD特性</h3><h4 id="高效的容错性。"><a href="#高效的容错性。" class="headerlink" title="高效的容错性。"></a>高效的容错性。</h4><ul><li>在RDD的设计中，数据只读，不可修改，如果需要修改数据，必须从父RDD转换到子RDD，由此在不同RDD之间建立了血缘关系。所以，RDD是一种天生具有容错机制的特殊集合，不需要通过数据冗余的方式（比如检查点）实现容错，而只需通过RDD父子依赖（血缘）关系重新计算得到丢失的分区来实现容错，无需回滚整个系统，这样就避免了数据复制的高开销，而且重算过程可以在不同节点之间并行进行，实现了高效的容错。</li><li>RDD提供的转换操作都是一些粗粒度的操作（比如map、filter和join），RDD依赖关系只需要记录这种粗粒度的转换操作，而不需要记录具体的数据和各种细粒度操作的日志（比如对哪个数据项进行了修改），这就大大降低了数据密集型应用中的容错开销；</li></ul><h4 id="中间结果持久化到内存。"><a href="#中间结果持久化到内存。" class="headerlink" title="中间结果持久化到内存。"></a>中间结果持久化到内存。</h4><ul><li>数据在内存中的多个RDD操作之间进行传递，不需要“落地”到磁盘上，避免了不必要的读写磁盘开销；</li></ul><h4 id="存放的数据可以是Java对象，"><a href="#存放的数据可以是Java对象，" class="headerlink" title="存放的数据可以是Java对象，"></a>存放的数据可以是Java对象，</h4><ul><li>避免了不必要的对象序列化和反序列化开销。</li></ul><h3 id="RDD间的依赖关系"><a href="#RDD间的依赖关系" class="headerlink" title="RDD间的依赖关系"></a>RDD间的依赖关系</h3><h4 id="窄依赖（Narrow-Dependency）"><a href="#窄依赖（Narrow-Dependency）" class="headerlink" title="窄依赖（Narrow Dependency）"></a>窄依赖（Narrow Dependency）</h4><ul><li>表现为一个父RDD的分区对应于一个子RDD的分区，或多个父RDD的分区对应于一个子RDD的分区；</li><li>窄依赖典型的操作包括map、filter、union等</li><li>对于窄依赖的RDD，可以以流水线的方式计算所有父分区，不会造成网络之间的数据混合。</li></ul><h4 id="宽依赖（Wide-Dependency）"><a href="#宽依赖（Wide-Dependency）" class="headerlink" title="宽依赖（Wide Dependency）"></a>宽依赖（Wide Dependency）</h4><ul><li>表现为存在一个父RDD的一个分区对应一个子RDD的多个分区</li><li>宽依赖典型的操作包括groupByKey、sortByKey等</li><li>对于宽依赖的RDD，则通常伴随着Shuffle操作，即首先需要计算好所有父分区数据，然后在节点之间进行Shuffle。</li></ul><p><strong>比较：</strong></p><ul><li>相对而言，在两种依赖关系中，窄依赖的失败恢复更为高效，它只需要根据父RDD分区重新计算丢失的分区即可（不需要重新计算所有分区），而且可以并行地在不同节点进行重新计算。</li><li>而对于宽依赖而言，单个节点失效通常意味着重新计算过程会涉及多个父RDD分区，开销较大。</li><li>此外，Spark还提供了数据检查点和记录日志，用于持久化中间RDD，从而使得在进行失败恢复时不需要追溯到最开始的阶段。</li><li>在进行故障恢复时，Spark会对数据检查点开销和重新计算RDD分区的开销进行比较，从而自动选择最优的恢复策略。</li></ul><h3 id="阶段的划分"><a href="#阶段的划分" class="headerlink" title="阶段的划分"></a>阶段的划分</h3><ul><li>在DAG中进行反向解析，遇到宽依赖就断开，遇到窄依赖就把当前的RDD加入到当前的阶段中；将窄依赖尽量划分在同一个阶段中，可以实现流水线计算（具体的阶段划分算法请参见AMP实验室发表的论文《Resilient Distributed Datasets: A Fault-Tolerant Abstraction for In-Memory Cluster Computing》）</li></ul><h3 id="RDD运行过程"><a href="#RDD运行过程" class="headerlink" title="RDD运行过程"></a>RDD运行过程</h3><ol><li>创建RDD对象；</li><li>SparkContext负责计算RDD之间的依赖关系，构建DAG；</li><li>DAGScheduler负责把DAG图分解成多个阶段，每个阶段中包含了多个任务，每个任务会被任务调度器分发给各个工作节点（Worker Node）上的Executor去执行。</li></ol><h2 id="SPARK的部署模式"><a href="#SPARK的部署模式" class="headerlink" title="SPARK的部署模式"></a>SPARK的部署模式</h2><h3 id="三种部署模式"><a href="#三种部署模式" class="headerlink" title="三种部署模式"></a>三种部署模式</h3><h4 id="standalone模式"><a href="#standalone模式" class="headerlink" title="standalone模式"></a>standalone模式</h4><ul><li>Spark框架本身也自带了完整的资源调度管理服务，可以独立部署到一个集群中，而不需要依赖其他系统来为其提供资源管理调度服务。</li></ul><h4 id="Spark-on-Mesos模式"><a href="#Spark-on-Mesos模式" class="headerlink" title="Spark on Mesos模式"></a>Spark on Mesos模式</h4><ul><li>Spark运行在Mesos上，要比运行在YARN上更加灵活、自然。目前，Spark官方推荐采用这种模式，</li></ul><h4 id="Spark-on-YARN模式"><a href="#Spark-on-YARN模式" class="headerlink" title="Spark on YARN模式"></a>Spark on YARN模式</h4><ul><li>Spark可运行于YARN之上，与Hadoop进行统一部署，即“Spark on YARN”，</li></ul><h3 id="从“Hadoop-Storm”架构转向Spark架构"><a href="#从“Hadoop-Storm”架构转向Spark架构" class="headerlink" title="从“Hadoop+Storm”架构转向Spark架构"></a>从“Hadoop+Storm”架构转向Spark架构</h3><h4 id="采用“Hadoop-Storm”部署方式的一个案例"><a href="#采用“Hadoop-Storm”部署方式的一个案例" class="headerlink" title="采用“Hadoop+Storm”部署方式的一个案例"></a>采用“Hadoop+Storm”部署方式的一个案例</h4><p>​                大数据层<br>​                    数据存储<br>​                        HDFS<br>​                        HBase<br>​                        Cassandra<br>​                    调度器<br>​                        YARN<br>​                        Mesos<br>​                    实时查询<br>​                        Redis<br>​                        Solr<br>​                        HBase<br>​                    离线分析<br>​                        Hive<br>​                        Pig<br>​                        Impala<br>​                        MapReduce<br>​                    用户行为实时分析<br>​                        UV<br>​                        PV<br>​                    Storm实时流处理<br>​                        欺诈监控<br>​                        系统报警<br>​                        点击流推荐<br>​                数据收集<br>​                    业务数据收集<br>​                        Flume<br>​                        Kafka<br>​                        ETL<br>​                    网站数据收集<br>​                        Collector<br>​                    用户行为数据收集<br>​                        PV/UV<br>​                        点击流信息<br>​                        导航数据收集<br>​                业务应用层<br>​                    应用数据<br>​                        导航日志<br>​                        应用日志<br>​                    系统数据<br>​                        系统日志<br>​                        报警数据<br>​                繁琐！</p><h4 id="Spark架构优点"><a href="#Spark架构优点" class="headerlink" title="Spark架构优点"></a>Spark架构优点</h4><ul><li>实现一键式安装和配置、线程级别的任务监控和告警；</li><li>降低硬件集群、软件维护、任务监控和应用开发的难度；</li><li>便于做成统一的硬件、计算平台资源池。</li><li>Spark Streaming的原理是将流数据分解成一系列短小的批处理作业，每个短小的批处理作业使用面向批处理的Spark Core进行处理，通过这种方式变相实现流计算，而不是真正实时的流计算，因而通常无法实现毫秒级的响应</li></ul><h4 id="Hadoop和Spark的统一部署"><a href="#Hadoop和Spark的统一部署" class="headerlink" title="Hadoop和Spark的统一部署"></a>Hadoop和Spark的统一部署</h4><ul><li>一方面，由于Hadoop生态系统中的一些组件所实现的功能，目前还是无法由Spark取代的，比如，Storm可以实现毫秒级响应的流计算，但是，Spark则无法做到毫秒级响应。</li><li>另一方面，企业中已经有许多现有的应用，都是基于现有的Hadoop组件开发的，完全转移到Spark上需要一定的成本。</li><li>实时计算工具<ol><li>storm：<a href="https://www.w3cschool.cn/apache_storm/" target="_blank" rel="noopener">https://www.w3cschool.cn/apache_storm/</a></li><li>flink：<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/tutorials/local_setup.html" target="_blank" rel="noopener">https://ci.apache.org/projects/flink/flink-docs-release-1.8/tutorials/local_setup.html</a></li></ol></li></ul><h1 id="Spark进阶"><a href="#Spark进阶" class="headerlink" title="Spark进阶"></a>Spark进阶</h1><h1 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h1><ul><li><a href="https://study.163.com/course/courseMain.htm?courseId=1002887002" target="_blank" rel="noopener">大数据技术原理与应用</a></li><li><a href="https://study.163.com/course/courseMain.htm?courseId=1209408816" target="_blank" rel="noopener">SPARK编程指南-Python</a></li><li><a href="https://www.w3cschool.cn/spark/" target="_blank" rel="noopener">w3school</a></li><li><a href="http://dblab.xmu.edu.cn/blog/1709-2/" target="_blank" rel="noopener">厦门大学博客</a></li><li><a href="https://spark.apache.org/docs/latest/index.html" target="_blank" rel="noopener">SPARK官网</a></li></ul><h1 id="疑难解答"><a href="#疑难解答" class="headerlink" title="疑难解答"></a>疑难解答</h1>]]></content>
      
      
      <categories>
          
          <category> AI/数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据科学 </tag>
            
            <tag> Spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDFS</title>
      <link href="/2019/11/27/hdfs/"/>
      <url>/2019/11/27/hdfs/</url>
      
        <content type="html"><![CDATA[<h1 id="HDFS基础"><a href="#HDFS基础" class="headerlink" title="HDFS基础"></a>HDFS基础</h1><h2 id="分布式文件系统"><a href="#分布式文件系统" class="headerlink" title="分布式文件系统"></a>分布式文件系统</h2><ul><li>分布式文件系统把文件分布存储在多个计算机节点上，成千上万的计算机节点构成计算机集群</li></ul><h2 id="HDFS简介与相关概念"><a href="#HDFS简介与相关概念" class="headerlink" title="HDFS简介与相关概念"></a>HDFS简介与相关概念</h2><h3 id="HDFS简介"><a href="#HDFS简介" class="headerlink" title="HDFS简介"></a>HDFS简介</h3><h4 id="实现目标："><a href="#实现目标：" class="headerlink" title="实现目标："></a>实现目标：</h4><ul><li>兼容廉价的硬件设备</li><li>流数据读写</li><li>大数据集</li><li>简单的文件模型</li><li>强大的跨平台兼容性</li></ul><h4 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h4><ul><li>不适合低延迟数据访问</li><li>无法高效存储大量小文件</li><li>不支持多用户写入及任意修改文件</li></ul><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><h4 id="块"><a href="#块" class="headerlink" title="块"></a>块</h4><ul><li>HDFS默认一个块64MB，一个文件被分成多个块，以块为存储单位</li><li>块的大小远远大于普通文件系统，可以最小化寻址开销</li><li>块带来的好处：<ol><li>支持大规模文件存储：一个大规模文件可以分成若干个块，不同的块分发到不同的节点上</li><li>简化系统设计：大大简化了存储管理以及方便了元数据的管理，元数据管理可以由其他系统负责</li><li>适合数据备份：采用冗余存储到多个节点，提高容错性和可用性</li></ol></li></ul><h4 id="NameNode"><a href="#NameNode" class="headerlink" title="NameNode"></a>NameNode</h4><h5 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h5><ul><li>存储元数据</li><li>元数据保存到内存中</li><li>保存文件，block，DataNode之间的映射关系</li></ul><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><p><img src="/2019/11/27/hdfs/namenode_architecture.png" alt="图：DataNode数据结构"></p><ul><li>FsImage：维护系统文件树以及所有元数据，包含文件的复制等级、修改、访问时间、访问权限、块大小以及组成文件的块，目录的存储修改时间、权限和配额。没有记录块存储在哪个DataNode，而是存储映射关系到内存。每次增加DataNode到集群时，DataNode都会把自己包含的块列表告知NameNode，确保映射是最新</li><li>EditLog：记录创建、删除、重命名等操作</li></ul><h5 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h5><ul><li>启动的时候，将FsImage文件中的内容加载到内存，再执行EditLog中的各项操作，使得内存中的元数据和实际的同步</li><li>一旦内存中成功建立文件系统元数据的映射，则创建一个新的FsImage和一个<strong>空的</strong>EditLog</li><li>每次执行写操作之后，且在向客户端发送代码之前，EditLog都需要同步更新</li><li>因为FsImage文件一般很大（GB常见），如果所有的更新操作都往里加，则会导致系统变慢，所以需要一个不断更新的EditLog</li><li>但是随着对文件不断的更新，EditLog也会不断的增大，怎么解决这个问题呢？<strong><em>使用SecondaryNameNode</em></strong>，详情如下：</li></ul><p><img src="/2019/11/27/hdfs/editlog.png" alt="图：EditLog解决"></p><h5 id="内存全景"><a href="#内存全景" class="headerlink" title="内存全景"></a>内存全景</h5><p><img src="/2019/11/27/hdfs/namenode_memory.png" alt="图：DataNode内存全景"></p><ul><li>参考<a href="https://tech.meituan.com/2016/08/26/namenode.html" target="_blank" rel="noopener">HDFS NameNode内存全景</a></li></ul><h4 id="DatanNode（廉价机器）"><a href="#DatanNode（廉价机器）" class="headerlink" title="DatanNode（廉价机器）"></a>DatanNode（廉价机器）</h4><h5 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h5><ul><li>存储文件内容</li><li>文件内容保存到磁盘</li><li>维护block id到DataNode本地文件的映射关系</li></ul><h2 id="HDFS结构"><a href="#HDFS结构" class="headerlink" title="HDFS结构"></a>HDFS结构</h2><p><img src="/2019/11/27/hdfs/hdfs_architecture.png" alt="图：hdfs结构"></p><h3 id="HDFS命名空间管理"><a href="#HDFS命名空间管理" class="headerlink" title="HDFS命名空间管理"></a>HDFS命名空间管理</h3><ul><li>命名空间包含目录、文件和块</li><li>使用的是传统的分级文件体系</li></ul><h3 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h3><ul><li>在TCP/TP协议之上</li><li>客户端通过一个可配置的端口向NameNode主动发起TCP连接，并使用<strong>客户端协议</strong>与NameNode进行交互</li><li>NameNode与DataNode之间使用<strong>数据节点协议</strong>交互</li><li>客户端与DataNode使用RPC（remote procedure call）实现</li></ul><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ul><li>HDFS在部署时提供了客户端</li><li>客户端是一个库，暴露HDFS文件系统接口</li><li>客户端支持打开、读取、写入等常见操作，提供类shell的命令行访问数据</li></ul><h3 id="HDFS-1-0-局限性"><a href="#HDFS-1-0-局限性" class="headerlink" title="HDFS-1.0-局限性"></a>HDFS-1.0-局限性</h3><ul><li>命名空间的限制：NameNode保存在内存中，受到内存空间大小限制</li><li>性能的瓶颈：受限单个NameNode的吞吐量</li><li>隔离问题：集群中只有一个NameNode，只有一个命名空间，因此没法对不同程序进行隔离</li><li>集群的可用性：一旦唯一的NameNode发生故障，则导致整个集群不可用</li></ul><h2 id="HDFS存储原理"><a href="#HDFS存储原理" class="headerlink" title="HDFS存储原理"></a>HDFS存储原理</h2><h3 id="冗余数据保存"><a href="#冗余数据保存" class="headerlink" title="冗余数据保存"></a>冗余数据保存</h3><ul><li>多副本对数据进行冗余保存，一般默认冗余保存3份</li><li>优点<ol><li>加快数据传输速度</li><li>容易检查数据错误</li><li>保证数据可靠性</li></ol></li></ul><h3 id="数据存取策略"><a href="#数据存取策略" class="headerlink" title="数据存取策略"></a>数据存取策略</h3><h4 id="数据存放"><a href="#数据存放" class="headerlink" title="数据存放"></a>数据存放</h4><ul><li>第一个副本：放置在上传文件的数据节点；如果在集群外提交，则随机挑选机器存放</li><li>第二个副本：放置在与第一个副本<strong>不同的机架</strong>（rack）的节点上</li><li>第三个副本：与第一个副本<strong>相同机架</strong>的不同节点上</li></ul><h4 id="数据读取"><a href="#数据读取" class="headerlink" title="数据读取"></a>数据读取</h4><ul><li>当客户端读取数据时，从NameNode获得数据块不同副本的存放位置列表，通过API来获取这些存放位置的机架ID与客户端对应机架ID，如果ID相同，则优先选择该副本，反之随机读取</li></ul><h3 id="数据错误与恢复"><a href="#数据错误与恢复" class="headerlink" title="数据错误与恢复"></a>数据错误与恢复</h3><h4 id="NameNode出错"><a href="#NameNode出错" class="headerlink" title="NameNode出错"></a>NameNode出错</h4><ul><li>使用SecondaryNameNode进行数据恢复</li></ul><h4 id="DataNode出错"><a href="#DataNode出错" class="headerlink" title="DataNode出错"></a>DataNode出错</h4><ul><li>心跳机制：每个DataNode会定期向NameNode发送心跳信息</li><li>当DataNode出错时，NameNode收不到心跳，则会将他们标记为“宕机”，其节点上所有数据标记为“不可读”，也不会再给他们发送任何IO请求</li><li>NameNode还会检查，当某个数据库的副本数量小于冗余因子，就会启动<strong>数据冗余复制</strong>，产生新副本</li></ul><h4 id="数据出错"><a href="#数据出错" class="headerlink" title="数据出错"></a>数据出错</h4><ul><li>网络传输和磁盘错误等因素，会造成数据错误</li><li>当文件本创建时，客户端会对每一个文件进行信息摘录，并写入到同一路径的隐藏文件中</li><li>当客户端读取文件的时候，会先读取信息摘录文件，然后对读取的数据块进行校验，如果检验出错，客户端则会<strong>请求到另外一个DataNode读取文件块</strong>，并向NameNode报告这个文件块有错误，然后NameNode会重新复制这个块</li></ul><h2 id="HDFS数据读写过程"><a href="#HDFS数据读写过程" class="headerlink" title="HDFS数据读写过程"></a>HDFS数据读写过程</h2><h3 id="读过程-JAVA"><a href="#读过程-JAVA" class="headerlink" title="读过程-JAVA"></a>读过程-JAVA</h3><ul><li>JAVA读过程</li></ul><p><img src="/2019/11/27/hdfs/java_read_hdfs.png" alt="图：JAVA读HDFS过程"></p><h3 id="写过程-JAVA"><a href="#写过程-JAVA" class="headerlink" title="写过程-JAVA"></a>写过程-JAVA</h3><ul><li>JAVA写过程</li></ul><p><img src="/2019/11/27/hdfs/java_write_hdfs.png" alt="图：JAVA写HDFS过程"></p><h1 id="HDFS进阶"><a href="#HDFS进阶" class="headerlink" title="HDFS进阶"></a>HDFS进阶</h1><h2 id="HDFS编程实践"><a href="#HDFS编程实践" class="headerlink" title="HDFS编程实践"></a>HDFS编程实践</h2><ul><li><a href="http://dblab.xmu.edu.cn/blog/290-2/" target="_blank" rel="noopener">编程实践</a></li></ul><h1 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h1><ul><li><a href="https://study.163.com/course/courseMain.htm?courseId=1002887002" target="_blank" rel="noopener">大数据技术原理与应用</a></li></ul><h1 id="疑难解答"><a href="#疑难解答" class="headerlink" title="疑难解答"></a>疑难解答</h1>]]></content>
      
      
      <categories>
          
          <category> AI/数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据科学 </tag>
            
            <tag> Hadoop </tag>
            
            <tag> HDFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算广告学2.0</title>
      <link href="/2019/11/22/ji-suan-guang-gao-xue-2-0/"/>
      <url>/2019/11/22/ji-suan-guang-gao-xue-2-0/</url>
      
        <content type="html"><![CDATA[<h1 id="广告的基本知识"><a href="#广告的基本知识" class="headerlink" title="广告的基本知识"></a>广告的基本知识</h1><h2 id="广告的目的"><a href="#广告的目的" class="headerlink" title="广告的目的"></a>广告的目的</h2><h3 id="什么是广告？"><a href="#什么是广告？" class="headerlink" title="什么是广告？"></a>什么是广告？</h3><h4 id="广告的定义"><a href="#广告的定义" class="headerlink" title="广告的定义"></a>广告的定义</h4><ul><li>广告是由已确定的出资人通过各种媒介进行的有关产品的、通常有偿、有组织、综合的、劝服性的非人员信息传播活动。</li></ul><h4 id="广告的主体"><a href="#广告的主体" class="headerlink" title="广告的主体"></a>广告的主体</h4><ul><li>出资人：广告主</li><li>媒介</li><li>受众</li></ul><h4 id="广告的本质功能"><a href="#广告的本质功能" class="headerlink" title="广告的本质功能"></a>广告的本质功能</h4><ul><li>借助媒介的力量，完成较低成本的用户接触</li></ul><h2 id="广告的有效性模型"><a href="#广告的有效性模型" class="headerlink" title="广告的有效性模型"></a>广告的有效性模型</h2><p><img src="/2019/11/22/ji-suan-guang-gao-xue-2-0/guanggaoyouxiaoxing.png" alt="图：广告有效性模型"></p><h2 id="广告与营销的区别"><a href="#广告与营销的区别" class="headerlink" title="广告与营销的区别"></a>广告与营销的区别</h2><p><img src="/2019/11/22/ji-suan-guang-gao-xue-2-0/guanggaoyuxiaoshoudifferent.png" alt="图：广告与销售区别"></p><h2 id="在线广告的特点"><a href="#在线广告的特点" class="headerlink" title="在线广告的特点"></a>在线广告的特点</h2><p><img src="/2019/11/22/ji-suan-guang-gao-xue-2-0/zaixianguanggaodutexing.png" alt="图：在线广告独特性"></p><h2 id="在线广告市场"><a href="#在线广告市场" class="headerlink" title="在线广告市场"></a>在线广告市场</h2><p><img src="/2019/11/22/ji-suan-guang-gao-xue-2-0/ads_online.png" alt="图：在线广告结构"></p><p><strong>媒体三种变现方式：</strong></p><ol><li>直接给广告网络</li><li>通过ADX</li><li>通过SSP</li></ol><ul><li>需求方：广告主等等</li><li>供给方：媒体等等</li></ul><h2 id="计算广告核心问题和挑战"><a href="#计算广告核心问题和挑战" class="headerlink" title="计算广告核心问题和挑战"></a>计算广告核心问题和挑战</h2><p><img src="/2019/11/22/ji-suan-guang-gao-xue-2-0/tiaozhan.png" alt="图：核心计算问题"></p><p><strong>挑战：</strong></p><ul><li>大规模：用户量大，高并发在线投放系统</li><li>动态性：用户的兴趣随时变化</li><li>丰富的查询信息：需要把用户和上下文的多样信号一起综合</li><li>探索与发现：需要主动探索未知的数据，例如用户的其他未展示信息</li></ul><h2 id="广告、搜索和推荐的比较"><a href="#广告、搜索和推荐的比较" class="headerlink" title="广告、搜索和推荐的比较"></a>广告、搜索和推荐的比较</h2><p><img src="/2019/11/22/ji-suan-guang-gao-xue-2-0/qubie.png" alt="图：区别"></p><h2 id="投资回报（ROI）分析"><a href="#投资回报（ROI）分析" class="headerlink" title="投资回报（ROI）分析"></a>投资回报（ROI）分析</h2><p><img src="/2019/11/22/ji-suan-guang-gao-xue-2-0/roi.png" alt="图：ROI"></p><p><strong>参数解释：</strong></p><ol><li><p>$a_i$：广告</p></li><li><p>$u_i$：用户</p></li><li>$c_i$：上下文</li></ol><h2 id="在线广告系统结构"><a href="#在线广告系统结构" class="headerlink" title="在线广告系统结构"></a>在线广告系统结构</h2><p><img src="/2019/11/22/ji-suan-guang-gao-xue-2-0/ads_system.png" alt="图：在线广告系统结构"></p><h1 id="合约广告系统"><a href="#合约广告系统" class="headerlink" title="合约广告系统"></a>合约广告系统</h1><h2 id="常用广告系统开源工具"><a href="#常用广告系统开源工具" class="headerlink" title="常用广告系统开源工具"></a>常用广告系统开源工具</h2><p><img src="/2019/11/22/ji-suan-guang-gao-xue-2-0/tool.png" alt="图：开源工具"></p><ul><li>GFS</li><li>Thrift</li></ul><p><img src="/2019/11/22/ji-suan-guang-gao-xue-2-0/thrift.png" alt="图：thrift工具"></p><ul><li>Storm</li><li>Scribe</li><li>Flume</li><li>Chubby</li><li>Hadoop</li><li>HDFS</li><li>MapReduce</li><li>Avro</li><li>Chuhwa</li><li>ZooKeeper</li><li>HBase</li><li>Oozie</li><li>Pig</li><li>Hive</li><li>BigTable</li><li>HYPERTABLE</li><li>Cassandra</li><li>mahout</li><li>Elephant-bird</li></ul><h2 id="合约广告简介"><a href="#合约广告简介" class="headerlink" title="合约广告简介"></a>合约广告简介</h2><h3 id="直接媒体购买"><a href="#直接媒体购买" class="headerlink" title="直接媒体购买"></a>直接媒体购买</h3><ul><li>供给方：广告排期系统，帮助媒体自动执行多个合同的排期，不提供受众定向</li><li>需求方：代理商，帮助广告商策划和执行排期，用经验和人工满足广告商的质量需求</li><li>代表：4A公司</li></ul><h3 id="担保式投送与广告投放"><a href="#担保式投送与广告投放" class="headerlink" title="担保式投送与广告投放"></a>担保式投送与广告投放</h3><ul><li>担保式投送（guaranteed delivery）（保证量）：基于合约的广告机制，量优于质的销售方式，采用CPM的方式结算</li><li>广告投放机（Ad server）（希望帮广告商做一些优化，优化质）：CPM必然要求广告投送由服务器完成决策，受众定向、CTR预测和流量预测是广告投放机的基础，担保式投送下，投放机满足各合约的量，并尽可能优化各广告主流量的质</li></ul><h2 id="在线分配问题"><a href="#在线分配问题" class="headerlink" title="在线分配问题"></a>在线分配问题</h2><p><img src="/2019/11/22/ji-suan-guang-gao-xue-2-0/online_allocation.png" alt="图：在线分配问题"></p><ul><li>用拉格朗日方法求解</li></ul><p><img src="/2019/11/22/ji-suan-guang-gao-xue-2-0/method1.png" alt="图：拉格朗日方法"></p><ul><li>$b_{ia}$：第i个impression（曝光）拿到广告a的收益</li><li>$x_{ia}$：流量分配以及预算控制</li><li>display ad problem：有量的需求，量的下限或预算（上限）的需求</li><li>adwords problem：没有明确的量需求</li><li>NGD：non-guaranteed delivery（上限的需求）</li><li>流量预测下的GD在线分配</li></ul><p><img src="/2019/11/22/ji-suan-guang-gao-xue-2-0/method2.png" alt="图：GD在线分配"></p><h2 id="Hadoop介绍"><a href="#Hadoop介绍" class="headerlink" title="Hadoop介绍"></a>Hadoop介绍</h2><p><img src="/2019/11/22/ji-suan-guang-gao-xue-2-0/mapreduce.png" alt="图：mapreduce在统计中应用"></p><h1 id="受众定向（audience-targeting）-在线广告的核心"><a href="#受众定向（audience-targeting）-在线广告的核心" class="headerlink" title="受众定向（audience targeting）-在线广告的核心"></a>受众定向（audience targeting）-在线广告的核心</h1><h2 id="受众定向概念"><a href="#受众定向概念" class="headerlink" title="受众定向概念"></a>受众定向概念</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><img src="/2019/11/22/ji-suan-guang-gao-xue-2-0/audience_targeting.png" alt="图：受众定向"></p><h3 id="常见受众定向方式"><a href="#常见受众定向方式" class="headerlink" title="常见受众定向方式"></a>常见受众定向方式</h3><ul><li>$f(a,u)$：<ol><li><strong>重定向</strong>，如果某个用户访问某个广告，则给该用户或该广告打上某一个标签</li><li><strong>lookalike</strong>，从海量数据中找到与已有种子用户相似的用户</li></ol></li><li>$f(u)$：行为定向</li><li>$f(c)$：上下文定向</li></ul><h2 id="行为定向-对user打标签"><a href="#行为定向-对user打标签" class="headerlink" title="行为定向-对user打标签"></a>行为定向-对user打标签</h2><h3 id="九种重要的原始行为（按信息强度排序）"><a href="#九种重要的原始行为（按信息强度排序）" class="headerlink" title="九种重要的原始行为（按信息强度排序）"></a>九种重要的原始行为（按信息强度排序）</h3><ul><li>transaction：交易信息</li><li>pre-transaction：预交易信息</li><li>paid search click：付款点击信息</li><li>ad click：广告点击信息</li><li>search click：搜索点击信息</li><li>search： 搜索信息</li><li>share：分享信息</li><li>page view：网页浏览信息</li><li>ad view：广告流量信息</li></ul><p><strong>行为定向计算：</strong>为用户的每个行为标签计算一个值（强度）</p><h3 id="行为定向其他标签"><a href="#行为定向其他标签" class="headerlink" title="行为定向其他标签"></a>行为定向其他标签</h3><ul><li>session log：以用户ID为key的形式，可以将targeting变成局部运算</li><li>long-term：多日标签累计计算，采用时间衰减方式，仅需昨天的f和今天的t</li></ul><h2 id="上下文定向-即时标签"><a href="#上下文定向-即时标签" class="headerlink" title="上下文定向-即时标签"></a>上下文定向-即时标签</h2><p><strong>以url举例：</strong></p><ul><li>用在线cache系统存储url</li><li>不预先加载任何cache内容，对cache中不存在的url，立刻返回空特征，同时触发相应的页面爬虫和特征提取</li><li>设置cache系统合适的失效时间以完成特征自动更新</li></ul><h2 id="Topic-Model-上下文（页面主题分析）"><a href="#Topic-Model-上下文（页面主题分析）" class="headerlink" title="Topic Model-上下文（页面主题分析）"></a>Topic Model-上下文（页面主题分析）</h2><p><img src="/2019/11/22/ji-suan-guang-gao-xue-2-0/topic_model.png" alt="图：常用模型图"></p><p><strong>参数解释：</strong></p><ul><li>$\pi$：先验分布</li><li>$z$：隐含主题</li><li>$w$：词word</li></ul><h2 id="数据加工和交易"><a href="#数据加工和交易" class="headerlink" title="数据加工和交易"></a>数据加工和交易</h2><h3 id="精准广告业务是什么？"><a href="#精准广告业务是什么？" class="headerlink" title="精准广告业务是什么？"></a>精准广告业务是什么？</h3><ul><li>数据源——用户行为——定向系统——用户标签——投放机</li></ul><h3 id="有价值的数据"><a href="#有价值的数据" class="headerlink" title="有价值的数据"></a>有价值的数据</h3><ul><li>用户标识</li><li>用户行为</li></ul><h3 id="数据管理平台（DMP）"><a href="#数据管理平台（DMP）" class="headerlink" title="数据管理平台（DMP）"></a>数据管理平台（DMP）</h3><ul><li>目的：<ol><li>为网站提供数据加工和对外交易能力</li><li>加工跨媒体用户标签，在交易市场中售卖</li><li>是否应直接从事广告交易存在争议</li></ol></li><li>关键特征：<ol><li>定制化用户划分</li><li>统一的对外数据接口</li></ol></li></ul><h3 id="data-highway工具"><a href="#data-highway工具" class="headerlink" title="data highway工具"></a>data highway工具</h3><ul><li>scribe：大规模分布式日志收集系统</li><li><strong>flume</strong></li><li>chukwa</li></ul><h1 id="竞价广告系统（supply端）"><a href="#竞价广告系统（supply端）" class="headerlink" title="竞价广告系统（supply端）"></a>竞价广告系统（supply端）</h1><h2 id="位置拍卖理论"><a href="#位置拍卖理论" class="headerlink" title="位置拍卖理论"></a>位置拍卖理论</h2><h4 id="竞价系统理论"><a href="#竞价系统理论" class="headerlink" title="竞价系统理论"></a>竞价系统理论</h4><p><img src="/2019/11/22/ji-suan-guang-gao-xue-2-0/bid_theory.png" alt="图：竞价系统理论"></p><h4 id="定价机制"><a href="#定价机制" class="headerlink" title="定价机制"></a>定价机制</h4><p><img src="/2019/11/22/ji-suan-guang-gao-xue-2-0/bid_theory1.png" alt="图：定价机制"></p><h2 id="广告网络概念"><a href="#广告网络概念" class="headerlink" title="广告网络概念"></a>广告网络概念</h2><h4 id="广告网络"><a href="#广告网络" class="headerlink" title="广告网络"></a>广告网络</h4><ul><li>connect advertisers to web sites that want to host advertisements</li><li>自行估计给定（a,u,c）组合的CTR</li></ul><h4 id="主要特征"><a href="#主要特征" class="headerlink" title="主要特征"></a>主要特征</h4><ul><li>竞价系统</li><li>淡化广告位概念</li><li>最合适的计价方式是CPC</li><li>不易支持定制化用户划分</li></ul><h2 id="广告检索"><a href="#广告检索" class="headerlink" title="广告检索"></a>广告检索</h2><h4 id="布尔表达式检索"><a href="#布尔表达式检索" class="headerlink" title="布尔表达式检索"></a>布尔表达式检索</h4><p><img src="/2019/11/22/ji-suan-guang-gao-xue-2-0/search.png" alt="图：布尔表达式检索"></p><ul><li>index算法</li></ul><h4 id="长query情况下的相关性检索"><a href="#长query情况下的相关性检索" class="headerlink" title="长query情况下的相关性检索"></a>长query情况下的相关性检索</h4><p><img src="/2019/11/22/ji-suan-guang-gao-xue-2-0/search1.png" alt="图：长query检索"></p><ul><li>weigth-and（wand）检索算法</li></ul><h2 id="流量预测"><a href="#流量预测" class="headerlink" title="流量预测"></a>流量预测</h2><ul><li>可以视query为a，对（u,c）进行检索的反向检索（retrieval）问题</li><li>由于（u,c）联合空间规模过大，需要进行预处理</li></ul><h4 id="预测过程"><a href="#预测过程" class="headerlink" title="预测过程"></a>预测过程</h4><ul><li>给定a，首先通过c的索引找出所有符合条件c的集合</li><li>对每个c估计eCPM(a,c)，并根据eCPM得到a在c上胜出的百分比并累加则得到a的流量预测值</li></ul><h2 id="ZooKeeper介绍-分布式同步服务"><a href="#ZooKeeper介绍-分布式同步服务" class="headerlink" title="ZooKeeper介绍-分布式同步服务"></a>ZooKeeper介绍-分布式同步服务</h2><ul><li>在基于消息传递通信模型的分布式环境下解决一致性问题的基础服务</li><li>用层次式namespace维护同步需要的状态空间</li><li>保证实现特性：timeliness等</li><li>较复杂的同步模式需要利用API编程实现</li><li>Paxos算法</li></ul><h2 id="点击率预测与逻辑回归"><a href="#点击率预测与逻辑回归" class="headerlink" title="点击率预测与逻辑回归"></a>点击率预测与逻辑回归</h2><h4 id="点击率预测"><a href="#点击率预测" class="headerlink" title="点击率预测"></a>点击率预测</h4><p><img src="/2019/11/22/ji-suan-guang-gao-xue-2-0/ctr.png" alt="图：点击率预测"></p><h2 id="逻辑回归优化方法介绍"><a href="#逻辑回归优化方法介绍" class="headerlink" title="逻辑回归优化方法介绍"></a>逻辑回归优化方法介绍</h2><h4 id="L-BFGS"><a href="#L-BFGS" class="headerlink" title="L-BFGS"></a>L-BFGS</h4><p><img src="/2019/11/22/ji-suan-guang-gao-xue-2-0/lbfgs.png" alt="图：优化方法"></p><h4 id="ADMM方法"><a href="#ADMM方法" class="headerlink" title="ADMM方法"></a>ADMM方法</h4><p><img src="/2019/11/22/ji-suan-guang-gao-xue-2-0/admm.png" alt="图：admm"></p><h2 id="动态特征"><a href="#动态特征" class="headerlink" title="动态特征"></a>动态特征</h2><h4 id="多层次点击反馈"><a href="#多层次点击反馈" class="headerlink" title="多层次点击反馈"></a>多层次点击反馈</h4><p><img src="/2019/11/22/ji-suan-guang-gao-xue-2-0/feature.png" alt="图：多层次点击"></p><h1 id="探索广告与广告网络（suppy端）"><a href="#探索广告与广告网络（suppy端）" class="headerlink" title="探索广告与广告网络（suppy端）"></a>探索广告与广告网络（suppy端）</h1><h2 id="探索与利用"><a href="#探索与利用" class="headerlink" title="探索与利用"></a>探索与利用</h2><p><img src="/2019/11/22/ji-suan-guang-gao-xue-2-0/explore.png" alt="图：探索与利用"></p><h4 id="UCB"><a href="#UCB" class="headerlink" title="UCB"></a>UCB</h4><p><img src="/2019/11/22/ji-suan-guang-gao-xue-2-0/ucb.png" alt="图：ucb"></p><h4 id="Contextual-Bandit"><a href="#Contextual-Bandit" class="headerlink" title="Contextual Bandit"></a>Contextual Bandit</h4><p><img src="/2019/11/22/ji-suan-guang-gao-xue-2-0/contextual.png" alt="图：contextual bandit"></p><h2 id="搜索广告"><a href="#搜索广告" class="headerlink" title="搜索广告"></a>搜索广告</h2><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>广告网络的特殊形式<ol><li>用户定向标签</li><li>session内的短时间用户搜索行为更重要</li><li>上下文定向标签</li></ol></li><li>典型位置竞价模式<ol><li>分南区、北区、东区等</li></ol></li></ul><h4 id="查询词扩展"><a href="#查询词扩展" class="headerlink" title="查询词扩展"></a>查询词扩展</h4><ul><li>基于推荐的方法<ol><li>挖掘矩阵找到相关query</li></ol></li><li>基于语义的方法<ol><li>topic model</li></ol></li><li>基于收益的方法<ol><li>根据eCPM统计得到表现较好的相关query</li></ol></li></ul><h4 id="用户相关的搜索广告决策"><a href="#用户相关的搜索广告决策" class="headerlink" title="用户相关的搜索广告决策"></a>用户相关的搜索广告决策</h4><ul><li>结果个性化对于搜索广告作用有限</li><li>广告展示条数是可以深度个性化的</li><li>可以根据统一session内的行为调整广告结果</li></ul><h4 id="短时用户行为反馈"><a href="#短时用户行为反馈" class="headerlink" title="短时用户行为反馈"></a>短时用户行为反馈</h4><ul><li>短时用户行为</li><li>短时用户行为反馈<ol><li>短时受众定向</li><li>短时点击反馈</li></ol></li><li>短时用户行为计算<ol><li>需要准实时对用户行为加工，不适合在Hadoop上进行</li></ol></li></ul><h2 id="流式计算平台"><a href="#流式计算平台" class="headerlink" title="流式计算平台"></a>流式计算平台</h2><h4 id="Storm"><a href="#Storm" class="headerlink" title="Storm"></a>Storm</h4><ul><li>大规模实时数据处理框架，自动完成数据分发和可靠性管理，开发者只需要关注处理逻辑</li><li>数据流基本在网络和内存进行</li><li>计算逻辑类似mapreduce，区别在于<strong>调度数据而非调度计算</strong>，hadoop却是<strong>调度计算</strong></li></ul><h2 id="广告购买平台（demand端）-trading-desk"><a href="#广告购买平台（demand端）-trading-desk" class="headerlink" title="广告购买平台（demand端）-trading desk"></a>广告购买平台（demand端）-trading desk</h2><h4 id="关键特征"><a href="#关键特征" class="headerlink" title="关键特征"></a>关键特征</h4><ul><li>连接到不同媒体和广告网络，为广告商提供universal marketplace</li><li>非实时竞价campaign的ROI优化能力</li><li>经常由代理公司孵化出来</li></ul><h4 id="非RTB流量的ROI优化"><a href="#非RTB流量的ROI优化" class="headerlink" title="非RTB流量的ROI优化"></a>非RTB流量的ROI优化</h4><p><img src="/2019/11/22/ji-suan-guang-gao-xue-2-0/non_rtb_roi.png" alt="图：non_rtb_roi"></p><h1 id="广告交易市场（ADX）"><a href="#广告交易市场（ADX）" class="headerlink" title="广告交易市场（ADX）"></a>广告交易市场（ADX）</h1><h2 id="广告交易市场（ad-exchange）"><a href="#广告交易市场（ad-exchange）" class="headerlink" title="广告交易市场（ad-exchange）"></a>广告交易市场（ad-exchange）</h2><p><img src="/2019/11/22/ji-suan-guang-gao-xue-2-0/adx.png" alt="图：adx"></p><p><strong>主要流程：</strong></p><ul><li>某个 User 访问某个网站，网站通知 Adx 目前有一次展示机会</li><li>Adx 通过 RTBD 接口向各个 DSP 询价，从而获取 DSP提供的各个广告（相当于图中的 Ad retrieval）</li><li>Adx 通过出价进行排序，并选择出价最高的广告展示给用户（相当于图中的 Ad ranking）</li><li>Adx 在日志中记录该广告的展示记录</li></ul><h4 id="关键特征-1"><a href="#关键特征-1" class="headerlink" title="关键特征"></a>关键特征</h4><ul><li>用实时竞价方式连接广告和上下文、用户</li><li>按照展示上的竞价收取广告主费用</li></ul><h2 id="实时竞价-RTB"><a href="#实时竞价-RTB" class="headerlink" title="实时竞价-RTB"></a>实时竞价-RTB</h2><p><img src="/2019/11/22/ji-suan-guang-gao-xue-2-0/rtb.png" alt="图：rtb"></p><h2 id="cookie-mapping"><a href="#cookie-mapping" class="headerlink" title="cookie mapping"></a>cookie mapping</h2><p><img src="/2019/11/22/ji-suan-guang-gao-xue-2-0/cookie_mapping.png" alt="图：cookie mapping"></p><h2 id="supply-side-platform-供应方平台"><a href="#supply-side-platform-供应方平台" class="headerlink" title="supply side platform-供应方平台"></a>supply side platform-供应方平台</h2><h4 id="媒体流量变现方式"><a href="#媒体流量变现方式" class="headerlink" title="媒体流量变现方式"></a>媒体流量变现方式</h4><ul><li>合约广告，与广告主签订合约进行投放（CPM 结算）</li><li>竞价广告，将广告位托管给广告网络，广告网络根据人群售卖给广告主（CPC 结算）</li><li>实时竞价（按展示结算）</li></ul><h4 id="关键特征-2"><a href="#关键特征-2" class="headerlink" title="关键特征"></a>关键特征</h4><ul><li>提供媒体端的用户划分和售卖能力</li><li>可以灵活接入多种变现方式</li><li>收益管理：统一网络优化和RTB，优化媒体利益</li></ul><h2 id="demand-side-platform-需求方平台（交易市场demand端技术）"><a href="#demand-side-platform-需求方平台（交易市场demand端技术）" class="headerlink" title="demand side platform-需求方平台（交易市场demand端技术）"></a>demand side platform-需求方平台（交易市场demand端技术）</h2><h4 id="关键特征："><a href="#关键特征：" class="headerlink" title="关键特征："></a>关键特征：</h4><ul><li>定制化用户划分</li><li>跨媒体流量采购</li><li>通过ROI估计来支持RTB</li></ul><h4 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h4><p><img src="/2019/11/22/ji-suan-guang-gao-xue-2-0/dsp.png" alt="图：dsp"></p><p><strong>难点：</strong>要估计 <strong>eCPM = CTR * clickValue</strong>，ADX不是对全部DSP询价，而是会预估每个DSP会不会出价，从而减轻询价成本（带宽成本）。</p><h2 id="DSP流量预测"><a href="#DSP流量预测" class="headerlink" title="DSP流量预测"></a>DSP流量预测</h2><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul><li>DSP需要预测流量以决定采买策略</li><li>DSP拿到流量就是bid的函数，称为bid landscape</li></ul><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>由于DSP<strong>无法拿到所有流量情况</strong>，因此无法像供给方ssp那样进行流量预测</li><li>如何利用历史投放数据仍然是关键</li></ul><h2 id="DSP点击价值估计"><a href="#DSP点击价值估计" class="headerlink" title="DSP点击价值估计"></a>DSP点击价值估计</h2><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>DSP的实时出价</li><li>广告网络中的出价工具</li><li>智能定价</li></ul><h4 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h4><ul><li>非常稀疏的训练数据</li><li>与广告主类型强烈相关的行为模式</li></ul><h4 id="点击价值估计若干原则"><a href="#点击价值估计若干原则" class="headerlink" title="点击价值估计若干原则"></a>点击价值估计若干原则</h4><ul><li>模型估计时，用较大的bias换较小的variance，以达到稳健估计的目的</li><li>充分利用广告商类型的层级结构，以及转化流程上的特征</li></ul><h2 id="DSP重定向（retargeting）"><a href="#DSP重定向（retargeting）" class="headerlink" title="DSP重定向（retargeting）"></a>DSP重定向（retargeting）</h2><p><strong>重点：</strong></p><ul><li>当一个用户浏览过我们的产品或官网，但是他没有形成转化，但之后他去浏览其他媒体的时候，我们通过对他投放广告则可以加大其转化可能</li></ul><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>网站重定向</li><li>搜索重定向</li><li>个性化重定向<ol><li>根据用户关注或购买，推送商品粒度的广告</li><li>已购买的，推荐相关产品</li><li>站外推荐</li></ol></li></ul><h4 id="推荐算法"><a href="#推荐算法" class="headerlink" title="推荐算法"></a>推荐算法</h4><ul><li>协同过滤算法<ol><li>内存方法或非参数方法：近邻、Item-based/user-based</li><li>模型方法或参数方法：矩阵分解、贝叶斯</li></ol></li><li>基于内容算法</li><li>SVD++算法</li></ul><h4 id="新客推荐-lookalike"><a href="#新客推荐-lookalike" class="headerlink" title="新客推荐-lookalike"></a>新客推荐-lookalike</h4><ul><li>由广告商提供一部分种子用户，DSP通过网络行为的相似性来找到潜在用户</li><li>是一种广告商自定义标签，可以视为扩展的重定向</li><li>在同样reach水平下，效果好于通用标签</li><li>尽量利用非demand数据，注意避免在竞争对手之间倒卖用户</li></ul><h2 id="需求端推荐方法"><a href="#需求端推荐方法" class="headerlink" title="需求端推荐方法"></a>需求端推荐方法</h2><p><img src="/2019/11/22/ji-suan-guang-gao-xue-2-0/recommend.png" alt="图：recommend"></p><h2 id="广告流量交易方式"><a href="#广告流量交易方式" class="headerlink" title="广告流量交易方式"></a>广告流量交易方式</h2><p><img src="/2019/11/22/ji-suan-guang-gao-xue-2-0/trade.png" alt="图：trade"></p><p><strong>优先销售：</strong></p><ul><li>CPT结算</li><li>GD（担保式投放）：CPM 结算 + 人群定向</li></ul><p><strong>程序交易：</strong></p><ul><li>竞价广告（Ad network）</li><li><p>实时竞价广告（Adx）</p></li><li><p>DSP：network optimization + RTBD</p></li><li>SSP：portfolio selection + RTBS</li></ul>]]></content>
      
      
      <categories>
          
          <category> AI/数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据科学 </tag>
            
            <tag> 计算广告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>职业规划</title>
      <link href="/2019/11/21/zhi-ye-gui-hua/"/>
      <url>/2019/11/21/zhi-ye-gui-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="一、笔记"><a href="#一、笔记" class="headerlink" title="一、笔记"></a>一、笔记</h1><h2 id="1、职业与职业生涯"><a href="#1、职业与职业生涯" class="headerlink" title="1、职业与职业生涯"></a>1、职业与职业生涯</h2><h3 id="（1）我们如何对待职业，职业也就如何对待我们"><a href="#（1）我们如何对待职业，职业也就如何对待我们" class="headerlink" title="（1）我们如何对待职业，职业也就如何对待我们"></a>（1）我们如何对待职业，职业也就如何对待我们</h3><ul><li>职业它是付出与回报的关系，你付出多少，它就回报多少</li></ul><h3 id="（2）什么是职业生涯，职业生涯分类"><a href="#（2）什么是职业生涯，职业生涯分类" class="headerlink" title="（2）什么是职业生涯，职业生涯分类"></a>（2）什么是职业生涯，职业生涯分类</h3><ul><li>职业生涯就是一个人的职业经历</li><li>职业生涯分为外职业生涯（别人给予和决定的经历）和内职业生涯（自己给自己的经历）</li><li>内职业生涯的发展是外职业生涯发展的前提，外职业生涯促进内职业生涯的发展</li></ul><h3 id="（3）学会为自己工作可以提高内职业生涯"><a href="#（3）学会为自己工作可以提高内职业生涯" class="headerlink" title="（3）学会为自己工作可以提高内职业生涯"></a>（3）学会为自己工作可以提高内职业生涯</h3><ul><li>为自己工作：你的工作热情和程度不为其他条件而所动则是为自己工作，许三多就是为自己当兵</li></ul><h3 id="（4）积极的面对工作可以提高内职业生涯"><a href="#（4）积极的面对工作可以提高内职业生涯" class="headerlink" title="（4）积极的面对工作可以提高内职业生涯"></a>（4）积极的面对工作可以提高内职业生涯</h3><ul><li>积极面对工作：</li></ul><h2 id="2、职业生涯规划"><a href="#2、职业生涯规划" class="headerlink" title="2、职业生涯规划"></a>2、职业生涯规划</h2><h3 id="（1）职业生涯规划定义"><a href="#（1）职业生涯规划定义" class="headerlink" title="（1）职业生涯规划定义"></a>（1）职业生涯规划定义</h3><ul><li>根据主观和客观的方面去规划职业生涯</li></ul><h3 id="（2）误区"><a href="#（2）误区" class="headerlink" title="（2）误区"></a>（2）误区</h3><ul><li>局部思维</li><li>要考虑全局，整个行业，<strong>要想到未来的形势</strong></li><li>静态思维：应该是动态思维，随着时间动态发展的</li><li>从众思维：不要从众，切忌人云亦云</li></ul><h3 id="（3）影响职业生涯的因素"><a href="#（3）影响职业生涯的因素" class="headerlink" title="（3）影响职业生涯的因素"></a>（3）影响职业生涯的因素</h3><ul><li>习惯</li><li>情绪</li><li>兴趣</li><li>特长</li></ul><h2 id="3、制定职业生涯"><a href="#3、制定职业生涯" class="headerlink" title="3、制定职业生涯"></a>3、制定职业生涯</h2><h3 id="（1）明确目标"><a href="#（1）明确目标" class="headerlink" title="（1）明确目标"></a>（1）明确目标</h3><ul><li>目标导向、以始为终</li><li>文字记载、随时提醒</li></ul><h3 id="（2）详细计划"><a href="#（2）详细计划" class="headerlink" title="（2）详细计划"></a>（2）详细计划</h3><ul><li>性格分析：感性还是理性</li><li>职业生涯路径分析：决定自己是走哪条路，创业还是兢兢业业</li><li>自我swot分析：扬长避短</li><li>时间分解和自我反思：自己缺什么赶快补什么</li><li>提高学习力的细分模型：总是忆往昔，说明你还在原地踏步</li><li>付诸行动和做出结果：一定要做，不做一定不会成功</li></ul><h1 id="二、参考课程"><a href="#二、参考课程" class="headerlink" title="二、参考课程"></a>二、参考课程</h1><ul><li><a href="https://study.163.com/course/courseMain.htm?courseId=1003599028" target="_blank" rel="noopener">职业生涯规划</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 职场通用技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 求职准备 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>职业形象</title>
      <link href="/2019/11/20/zhi-ye-xing-xiang/"/>
      <url>/2019/11/20/zhi-ye-xing-xiang/</url>
      
        <content type="html"><![CDATA[<h1 id="一、笔记"><a href="#一、笔记" class="headerlink" title="一、笔记"></a>一、笔记</h1><h2 id="1、形象管理概论"><a href="#1、形象管理概论" class="headerlink" title="1、形象管理概论"></a>1、形象管理概论</h2><h3 id="（1）形象的定义"><a href="#（1）形象的定义" class="headerlink" title="（1）形象的定义"></a>（1）形象的定义</h3><ul><li>他人眼中的自己</li></ul><h3 id="（2）形象的形成变数"><a href="#（2）形象的形成变数" class="headerlink" title="（2）形象的形成变数"></a>（2）形象的形成变数</h3><ul><li>性别</li><li>年龄</li><li>教育程度</li><li>职业和工作性质</li><li>工作和居住地缘</li><li>文化背景</li></ul><h3 id="（3）形象管理的三个步骤"><a href="#（3）形象管理的三个步骤" class="headerlink" title="（3）形象管理的三个步骤"></a>（3）形象管理的三个步骤</h3><ul><li>内在</li><li>表达：文字、语言、视觉、行为</li><li>公关：交际</li></ul><h2 id="2、服仪管理"><a href="#2、服仪管理" class="headerlink" title="2、服仪管理"></a>2、服仪管理</h2><h3 id="（1）装扮的三个层面"><a href="#（1）装扮的三个层面" class="headerlink" title="（1）装扮的三个层面"></a>（1）装扮的三个层面</h3><ul><li>心理</li><li>生理</li><li>社会</li></ul><h3 id="（2）主流审美观"><a href="#（2）主流审美观" class="headerlink" title="（2）主流审美观"></a>（2）主流审美观</h3><ul><li>形象被一半以上人认同，就是主流审美观</li></ul><h3 id="（3）社会期望值"><a href="#（3）社会期望值" class="headerlink" title="（3）社会期望值"></a>（3）社会期望值</h3><ul><li>形象风险，什么行业就穿符合该行业的服装</li><li>适合工作的服装，和不适合工作的服装</li></ul><h3 id="（4）穿着的TPO"><a href="#（4）穿着的TPO" class="headerlink" title="（4）穿着的TPO"></a>（4）穿着的TPO</h3><ul><li>时间</li><li>地点</li><li>场合</li></ul><h3 id="（5）男士服装风格分析"><a href="#（5）男士服装风格分析" class="headerlink" title="（5）男士服装风格分析"></a>（5）男士服装风格分析</h3><ul><li>休闲服</li><li>商务装</li><li>商务休闲装</li></ul><h3 id="（6）女士服装风格分析"><a href="#（6）女士服装风格分析" class="headerlink" title="（6）女士服装风格分析"></a>（6）女士服装风格分析</h3><h3 id="（7）身材分析"><a href="#（7）身材分析" class="headerlink" title="（7）身材分析"></a>（7）身材分析</h3><ul><li>比例：头身，趴着睡和斜着睡，躺着睡会让脸横向发展</li><li>曲线（女生）</li></ul><h3 id="（8）以服装修饰身材"><a href="#（8）以服装修饰身材" class="headerlink" title="（8）以服装修饰身材"></a>（8）以服装修饰身材</h3><ul><li><a href="https://www.zhihu.com/question/20872048" target="_blank" rel="noopener">知乎回答</a></li></ul><h3 id="（9）色彩搭配原理"><a href="#（9）色彩搭配原理" class="headerlink" title="（9）色彩搭配原理"></a>（9）色彩搭配原理</h3><ul><li><a href="https://zh.wikihow.com/搭配衣服颜色" target="_blank" rel="noopener">wikihow</a></li></ul><h2 id="3、仪态美学"><a href="#3、仪态美学" class="headerlink" title="3、仪态美学"></a>3、仪态美学</h2><h3 id="（1）基本站姿"><a href="#（1）基本站姿" class="headerlink" title="（1）基本站姿"></a>（1）基本站姿</h3><h3 id="（2）优雅坐姿"><a href="#（2）优雅坐姿" class="headerlink" title="（2）优雅坐姿"></a>（2）优雅坐姿</h3><h2 id="4、行为形象"><a href="#4、行为形象" class="headerlink" title="4、行为形象"></a>4、行为形象</h2><h3 id="（1）礼貌问题"><a href="#（1）礼貌问题" class="headerlink" title="（1）礼貌问题"></a>（1）礼貌问题</h3><ul><li>知识</li><li>常识</li><li>同理心（基础）</li></ul><h3 id="（2）个人隐私"><a href="#（2）个人隐私" class="headerlink" title="（2）个人隐私"></a>（2）个人隐私</h3><ul><li>身高</li><li>年龄</li></ul><h1 id="二、参考课程信息"><a href="#二、参考课程信息" class="headerlink" title="二、参考课程信息"></a>二、参考课程信息</h1><ul><li><a href="https://study.163.com/course/courseMain.htm?courseId=680003" target="_blank" rel="noopener">美丽百分百-个人形象管理</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 职场通用技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 求职准备 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sql</title>
      <link href="/2019/11/19/sql/"/>
      <url>/2019/11/19/sql/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Sql基础"><a href="#一、Sql基础" class="headerlink" title="一、Sql基础"></a>一、Sql基础</h1><p><a href="llljl.md">git</a></p>]]></content>
      
      
      <categories>
          
          <category> AI/数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据科学 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> Sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql</title>
      <link href="/2019/11/18/mysql/"/>
      <url>/2019/11/18/mysql/</url>
      
        <content type="html"><![CDATA[<h1 id="一、MySql基础"><a href="#一、MySql基础" class="headerlink" title="一、MySql基础"></a>一、MySql基础</h1><h2 id="1、MySql简介"><a href="#1、MySql简介" class="headerlink" title="1、MySql简介"></a>1、MySql简介</h2><h3 id="（1）什么是MySql？"><a href="#（1）什么是MySql？" class="headerlink" title="（1）什么是MySql？"></a>（1）什么是MySql？</h3><ul><li>MySql软件提供了一个非常快速、多线程、多用户和健壮的Sql数据库服务器（结构化查询）。MySql服务器适用于任务关键型、高负载的生产系统以及嵌入到大规模部署的软件中。</li></ul><h3 id="（2）安装"><a href="#（2）安装" class="headerlink" title="（2）安装"></a>（2）安装</h3><ul><li><a href="https://dev.mysql.com/doc/refman/8.0/en/installing.html" target="_blank" rel="noopener">参考官网</a></li></ul><h3 id="（3）启动"><a href="#（3）启动" class="headerlink" title="（3）启动"></a>（3）启动</h3><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">mysql -h host -u user -p# Enter password: ********<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="（4）退出"><a href="#（4）退出" class="headerlink" title="（4）退出"></a>（4）退出</h3><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">QUIT<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2、"><a href="#2、" class="headerlink" title="2、"></a>2、</h2><h1 id="二、MySql进阶"><a href="#二、MySql进阶" class="headerlink" title="二、MySql进阶"></a>二、MySql进阶</h1><h1 id="三、参考书籍"><a href="#三、参考书籍" class="headerlink" title="三、参考书籍"></a>三、参考书籍</h1><ul><li><a href="https://dev.mysql.com/doc/refman/8.0/en/" target="_blank" rel="noopener">官方教程</a></li></ul><h1 id="四、疑难解答"><a href="#四、疑难解答" class="headerlink" title="四、疑难解答"></a>四、疑难解答</h1>]]></content>
      
      
      <categories>
          
          <category> AI/数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据科学 </tag>
            
            <tag> MySql </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git笔记</title>
      <link href="/2019/11/12/git/"/>
      <url>/2019/11/12/git/</url>
      
        <content type="html"><![CDATA[<h1 id="Git基础"><a href="#Git基础" class="headerlink" title="Git基础"></a>Git基础</h1><h2 id="1、Git简介"><a href="#1、Git简介" class="headerlink" title="1、Git简介"></a>1、Git简介</h2><h3 id="（1）什么是Git？"><a href="#（1）什么是Git？" class="headerlink" title="（1）什么是Git？"></a>（1）什么是Git？</h3><ul><li>Git是迄今为止最先进的分布式版本控制系统</li></ul><h3 id="（2）Git安装"><a href="#（2）Git安装" class="headerlink" title="（2）Git安装"></a>（2）Git安装</h3><ul><li><a href="https://git-scm.com/book/en/v2/Getting-Started-Installing-Git" target="_blank" rel="noopener">安装教程</a></li></ul><h3 id="（3）Git设置"><a href="#（3）Git设置" class="headerlink" title="（3）Git设置"></a>（3）Git设置</h3><ol><li>checking your settings</li></ol><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git config --list  # 查看git的所有配置<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="（4）GitLab和GitHub一起使用"><a href="#（4）GitLab和GitHub一起使用" class="headerlink" title="（4）GitLab和GitHub一起使用"></a>（4）GitLab和GitHub一起使用</h3><ul><li><p>通常公司是使用GitLab，而个人是使用GitHub。那么问题来了：在一台电脑上同时使用GitLab和GitHub应该如何配置？</p><p>操作步骤如下：</p></li></ul><ol><li>生成公钥、密钥</li></ol><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># GitLabssh-keygen -t rsa -C "注册的GitLab邮箱"  # 公钥、密钥名输入gitlab_id_rsa，其他一律回车# GitHubssh-keygen -t rsa -C "注册的GitHub邮箱"  # 公钥、密钥名输入github_id_rsa，其他一律回车<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>备注：</strong></p><ol><li>上述代码完成后会在<code>~/.ssh/</code>目录生成以下文件：github_id_rsa、github_id_rsa.pub、gitlab_id_rsa、gitlab_id_rsa.pub</li><li>将github_id_rsa.pub的内容配置到GitHub网站的sshkey中，将gitlab_id_rsa.pub的内容配置到GitLab网站的sshkey中</li><li>在<code>~/.ssh/</code>目录下创建config文件，告诉git不同平台使用不同key</li></ol><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">cd ~/.ssh  # cd 到key目录vi config  # 创建并编辑config<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># config内容如下# gitlabHost gitlab.yourcompany.comHostName gitlab.yourcompany.comUser gitPort yourportPreferredAuthentications publickeyIdentityFile ~/.ssh/gitlab_id_rsa# githubHost github.comHostName github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/github_id_rsa<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>备注：</strong></p><ul><li>Host是别名，建议与HostName名字一致！</li><li>把工作用的GitLab的<code>git config</code>配置成global</li></ul><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">cd ~/workspace/gitlab  # gitlab的工作仓库git initgit config --global user.name 'personal'git config --global user.email 'personal@company.com'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>把个人用的GitHub的<code>git config</code>配置成local</li></ul><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">cd ~/workspace/github  # github的工作仓库git initgit config --local user.name 'yourname'git config --local user.email 'youremail'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>user.eamil</code>建议使用网站提供的<strong>加密邮箱</strong>，例如GitHub的加密邮箱可以从GitHub网站的个人setting中的Emails栏目中找到。如下：</li></ul><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">*@users.noreply.github.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2、创建版本库"><a href="#2、创建版本库" class="headerlink" title="2、创建版本库"></a>2、创建版本库</h2><h3 id="（1）将已有文件夹变为版本库"><a href="#（1）将已有文件夹变为版本库" class="headerlink" title="（1）将已有文件夹变为版本库"></a>（1）将已有文件夹变为版本库</h3><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">cd /home/user/my_project  # 切换到想要初始化的文件夹git init  # 初始化为版本库，文件夹会出现.git的隐藏文件夹git remote add origin ssh://git@github.com:myhaa/How-To-Ask-Questions-The-Smart-Way.gitgit add .  # 添加文件夹中所有文件到暂存区git commit -m "your commit description"  # 提交暂存区所有文件到版本库并保存提交记录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="（2）从远处仓库（GitLab-GitHub）克隆"><a href="#（2）从远处仓库（GitLab-GitHub）克隆" class="headerlink" title="（2）从远处仓库（GitLab\GitHub）克隆"></a>（2）从远处仓库（GitLab\GitHub）克隆</h3><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">cd /home/user/my_project  # 切换到想要存放版本库的文件夹git clone https://github.com/myhaa/How-To-Ask-Questions-The-Smart-Way.git  # clone https地址git clone ssh://git@github.com:myhaa/How-To-Ask-Questions-The-Smart-Way.git  # clone ssh地址cd How-To-Ask-Questions-The-Smart-Way  # 进入clone的版本库文件夹<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、操作版本库"><a href="#3、操作版本库" class="headerlink" title="3、操作版本库"></a>3、操作版本库</h2><h3 id="（1）版本库中文件的两种状态"><a href="#（1）版本库中文件的两种状态" class="headerlink" title="（1）版本库中文件的两种状态"></a>（1）版本库中文件的两种状态</h3><ol><li>未追踪状态（<em>untracked</em>）：从未<strong>add+commit</strong>的文件（Untracked files:）</li><li>追踪状态（<em>tracked</em>）：曾经<strong>add+commit</strong>过的文件<ul><li>未修改（unmodified）：在版本库中</li><li>已修改（modified）：Changes not staged for commit:</li><li>暂存（staged）：Changes to be committed:</li></ul></li><li>详情如下图（图来自：<a href="https://git-scm.com/book/en/v2/Git-Basics-Recording-Changes-to-the-Repository" target="_blank" rel="noopener">https://git-scm.com/book/en/v2/Git-Basics-Recording-Changes-to-the-Repository</a>）</li></ol><p><img src="/2019/11/12/git/lifecycle.png" alt="图1：版本库中的文件状态"></p><h3 id="（2）Tracking-New-Files-untracked"><a href="#（2）Tracking-New-Files-untracked" class="headerlink" title="（2）Tracking New Files(untracked)"></a>（2）Tracking New Files(untracked)</h3><ol><li>查看版本库状态发现README文件是<code>Untracked file</code>。</li></ol><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">$ git statusOn branch masterYour branch is up-to-date with 'origin/master'.Untracked files:  (use "git add <file>..." to include in what will be committed)    READMEnothing added to commit but untracked files present (use "git add" to track)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>将README添加到暂存区并提交到版本库</li></ol><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git add README  # 添加到暂存区（staged）发现README状态为（Changes to be committed: new file）git commit -m "add README"  # 提交到版本库<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="（3）Staging-Modified-Files-tracked"><a href="#（3）Staging-Modified-Files-tracked" class="headerlink" title="（3）Staging Modified Files(tracked)"></a>（3）Staging Modified Files(tracked)</h3><ol><li>修改刚刚提交到版本库的README文件</li></ol><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">vi README  # 用vim修改README文件git status  # 查看文件状态发现README的状态为（Changes not staged for commit: modified）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li>将README添加到暂存区并提交到版本库</li></ol><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git add README  # 添加到暂存区（staged）git commit -m "update README"  # 提交到版本库<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="（4）Viewing-Your-Staged-and-Unstaged-Changes"><a href="#（4）Viewing-Your-Staged-and-Unstaged-Changes" class="headerlink" title="（4）Viewing Your Staged and Unstaged Changes"></a>（4）Viewing Your Staged and Unstaged Changes</h3><ol><li>比较<code>Changes not staged for commit:</code>下的文件与本地最新版本库的差别：</li></ol><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git diff<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>比较<code>Changes to be committed:</code>下的文件与本地最新版本库的差别：</li></ol><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git diff --stagedgit diff --cached<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li>比较<code>Changes not staged for commit:</code>和<code>Changes to be committed:</code>下同名文件的差别</li></ol><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git diff<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="（5）配置忽略文件（Ignoring-Files）"><a href="#（5）配置忽略文件（Ignoring-Files）" class="headerlink" title="（5）配置忽略文件（Ignoring Files）"></a>（5）配置忽略文件（Ignoring Files）</h3><ul><li><p>通常会有一类文件是你不希望Git自动添加或显示为未跟踪的文件，例如日志文件或构建系统生成的文件。 这种情况下可以创建忽略文件<code>.gitignore</code>来避免。 </p></li><li><p>这是一个示例.gitignore文件：</p></li></ul><pre class="line-numbers language-lang-txt"><code class="language-lang-txt"># ignore all .a files*.a# but do track lib.a, even though you're ignoring .a files above!lib.a# only ignore the TODO file in the current directory, not subdir/TODO/TODO# ignore all files in any directory named buildbuild/# ignore doc/notes.txt, but not doc/server/arch.txtdoc/*.txt# ignore all .pdf files in the doc/ directory and any of its subdirectoriesdoc/**/*.pdf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="（6）Removing-and-Moving-files"><a href="#（6）Removing-and-Moving-files" class="headerlink" title="（6）Removing and Moving files"></a>（6）Removing and Moving files</h3><ol><li>short status</li></ol><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git status -s<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>skipping the staging area</li></ol><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git commit -a -m 'added new benchmarks'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>removing files</li></ol><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># 第一种情况：手动删除或使用rm命令rm PROJECTS.mdgit add PROJECTS.mdgit commit "rm PROJECTS.md"# 第二种情况：使用git rm命令删除git rm PROJECTS.mdgit commit "git rm PROJECTS.md"# 第三种情况：删除Changes to be committed:或者Changes not staged for commit:下显示的文件git rm -f PROJECTS.mdgit commit "git rm -f PROJECTS.md"# 第四种情况：您可能想要做的是将文件保留在工作树中，但将其从暂存区中删除。换句话说，您可能希望将文件保留在硬盘上，但不再需要Git对其进行跟踪。git rm --cached PROJECTS.mdgit commit "git rm --cached PROJECTS.md"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>moving files</li></ol><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git mv file_from file_to  # 重命名file_from为file_togit commit -m "rename file_from"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="（7）查看版本库提交历史"><a href="#（7）查看版本库提交历史" class="headerlink" title="（7）查看版本库提交历史"></a>（7）查看版本库提交历史</h3><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git log  # 查看历史git log -p -2  # 查看最新2个commit的历史（包含git diff结果）git log --stat  # 查看提交历史的一些简短统计信息git log --pretty=oneline  # 每个commit用一行输出git log --pretty=format:"%h - %an, %ar : %s"  # 按指定格式输出git log --pretty=format:"%h %s" --graph  # 图形化git log --since=2.weeks  # 过去2周的提交历史git log --pretty="%h - %s" --author='Junio C Hamano' --since="2008-10-01" --before="2008-11-01" --no-merges -- t/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>注意：</strong>更多详情请见<a href="https://git-scm.com/book/en/v2/Git-Basics-Viewing-the-Commit-History" target="_blank" rel="noopener">git log</a></li></ul><h3 id="（8）回退操作（undoing-things）"><a href="#（8）回退操作（undoing-things）" class="headerlink" title="（8）回退操作（undoing things）"></a>（8）回退操作（undoing things）</h3><ol><li>当你commit后发现此次commit的message出现错误或者忘记add一些文件时：</li></ol><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git commit --amend  # 修改commit信息，ctrl+o保存，回车，ctrl+x退出<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>unstaging a staged file(Changes to be committed:)</li></ol><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git reset HEAD CONTRIBUTING.md  # 将暂存区的某一个文件退回到工作区<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>unmodifying a modified file(Changes not staged for commit:)</li></ol><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git checkout -- CONTRIBUTING.md  # 撤销对某文件的修改<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>注意：</strong>回退操作异常危险，谨慎使用！！！</li></ul><h3 id="（9）远程仓库操作"><a href="#（9）远程仓库操作" class="headerlink" title="（9）远程仓库操作"></a>（9）远程仓库操作</h3><ol><li>showing your remotes</li></ol><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git remotegit remote -v  # 详细信息git remote show origin  # 详细信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol><li>添加远程仓库</li></ol><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git remote add <shortname> <url>  # 通用代码git remote add pb https://github.com/paulboone/ticgit  # pb 是给该远程仓库设定的别名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li>从远程获取最新版本到本地但不自动merge</li></ol><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git fetch <remote>  # 通用代码git fetch origingit fetch pb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol><li>从远程获取最新版本到本地并自动merge</li></ol><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git pull <remote>  # 通用代码git pull origingit pull pb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol><li>将本地库推送远程仓库</li></ol><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git push <remote> <branch>  # 通用代码git push origin master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li>将远程仓库重命名</li></ol><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git remote rename pb paul  # 将pb重命名为paul<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>移除某个远程仓库</li></ol><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git remote remove paul  # 移除paul这个远程仓库<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="（10）标签操作"><a href="#（10）标签操作" class="headerlink" title="（10）标签操作"></a>（10）标签操作</h3><ol><li>列出所有标签</li></ol><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git taggit tag -l "v1.8.5*"  # 列出浅醉是v1.8.5的标签<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li>创建带注释的标签（Annotated Tags）</li></ol><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git tag -a v1.4 -m "my version 1.4"git show v1.4  # 显示这个标签对应的commit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li>创建轻量级标签（Lightweight Tags）</li></ol><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git tag v1.4-lwgit show v1.4-lw  # 只有commit信息，没有tag信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li>补标签</li></ol><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git log --pretty=oneline  # 想为某次commit补上标签git tag -a v1.2 9fceb02  # 9fceb02 是commit-id<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li>分享标签到远程</li></ol><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git push origin v1.5  # push某一个git push origin --tags  # push全部tags<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li>删除标签</li></ol><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># 第一种方法git tag -d v1.4-lwgit push origin :refs/tags/v1.4-lw# 第二种方法git push origin --delete <tagname><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Git进阶-分支"><a href="#Git进阶-分支" class="headerlink" title="Git进阶-分支"></a>Git进阶-分支</h1><h2 id="1、-分支简介"><a href="#1、-分支简介" class="headerlink" title="1、 分支简介"></a>1、 分支简介</h2><h3 id="（1）什么是分支？"><a href="#（1）什么是分支？" class="headerlink" title="（1）什么是分支？"></a>（1）什么是分支？</h3><ul><li>如下图，master是默认分支，testing是其他分支。</li><li>分支的存在是让你可以把master作为正式环境，把testing作为开发环境，当开发环境的代码需要上线时就将其合并到正式环境master。</li></ul><p><img src="/2019/11/12/git/branch.png" alt="图2：分支"></p><h3 id="（2）默认分支"><a href="#（2）默认分支" class="headerlink" title="（2）默认分支"></a>（2）默认分支</h3><ul><li>master</li></ul><h3 id="（3）分支详细说明"><a href="#（3）分支详细说明" class="headerlink" title="（3）分支详细说明"></a>（3）分支详细说明</h3><ul><li><a href="https://git-scm.com/book/en/v2/Git-Branching-Branches-in-a-Nutshell" target="_blank" rel="noopener">参考官网</a></li></ul><h2 id="2、本地分支操作"><a href="#2、本地分支操作" class="headerlink" title="2、本地分支操作"></a>2、本地分支操作</h2><h3 id="（1）创建分支"><a href="#（1）创建分支" class="headerlink" title="（1）创建分支"></a>（1）创建分支</h3><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git branch test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="（2）切换到该分支"><a href="#（2）切换到该分支" class="headerlink" title="（2）切换到该分支"></a>（2）切换到该分支</h3><ul><li>当分支还存在文件没有add+commit的时候，是没法进行分支切换的。</li></ul><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git checkout test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="（3）创建并切换分支一步到位"><a href="#（3）创建并切换分支一步到位" class="headerlink" title="（3）创建并切换分支一步到位"></a>（3）创建并切换分支一步到位</h3><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git checkout -b test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="（4）查看分支"><a href="#（4）查看分支" class="headerlink" title="（4）查看分支"></a>（4）查看分支</h3><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git branch<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="（5）合并分支"><a href="#（5）合并分支" class="headerlink" title="（5）合并分支"></a>（5）合并分支</h3><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git merge test  # 在master分支上将test分支合并过来git merge master  # 在test分支上将master分支合并过来<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="（6）分支冲突解决"><a href="#（6）分支冲突解决" class="headerlink" title="（6）分支冲突解决"></a>（6）分支冲突解决</h3><ul><li>当两个分支的同一文件都被修改提交时，这时合并两个分支就会出现冲突，那么解决冲突的办法就是手动修改两个文件，使其一致。</li></ul><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git mergetool  # 查看合并冲突<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="（7）删除分支"><a href="#（7）删除分支" class="headerlink" title="（7）删除分支"></a>（7）删除分支</h3><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git branch -d test  # 在master分支上删除test分支<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="（8）查看被合并过的分支"><a href="#（8）查看被合并过的分支" class="headerlink" title="（8）查看被合并过的分支"></a>（8）查看被合并过的分支</h3><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git branch --merged<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="（9）查看未被合并过的分支"><a href="#（9）查看未被合并过的分支" class="headerlink" title="（9）查看未被合并过的分支"></a>（9）查看未被合并过的分支</h3><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git branch --no-merged<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3、远程分支操作"><a href="#3、远程分支操作" class="headerlink" title="3、远程分支操作"></a>3、远程分支操作</h2><h3 id="（1）克隆远程仓库"><a href="#（1）克隆远程仓库" class="headerlink" title="（1）克隆远程仓库"></a>（1）克隆远程仓库</h3><p><img src="/2019/11/12/git/remote_branch.png" alt="图3：克隆后的远程仓库和本地仓库"></p><ul><li>图片来源于<a href="https://git-scm.com/book/en/v2/Git-Branching-Remote-Branches" target="_blank" rel="noopener">官网</a></li></ul><h3 id="（2）当远程仓库被修改后"><a href="#（2）当远程仓库被修改后" class="headerlink" title="（2）当远程仓库被修改后"></a>（2）当远程仓库被修改后</h3><p><img src="/2019/11/12/git/remote_branch1.png" alt="图4：被别人修改后的远程仓库和本地仓库"></p><ul><li>图片来源于<a href="https://git-scm.com/book/en/v2/Git-Branching-Remote-Branches" target="_blank" rel="noopener">官网</a></li></ul><h3 id="（3）git-fetch-origin后的远程仓库和本地仓库"><a href="#（3）git-fetch-origin后的远程仓库和本地仓库" class="headerlink" title="（3）git fetch origin后的远程仓库和本地仓库"></a>（3）git fetch origin后的远程仓库和本地仓库</h3><p><img src="/2019/11/12/git/remote_branch2.png" alt="图5：fetch过后的仓库"></p><ul><li>图片来源于<a href="https://git-scm.com/book/en/v2/Git-Branching-Remote-Branches" target="_blank" rel="noopener">官网</a></li></ul><h3 id="（4）多个远程仓库"><a href="#（4）多个远程仓库" class="headerlink" title="（4）多个远程仓库"></a>（4）多个远程仓库</h3><p><img src="/2019/11/12/git/remote_branch3.png" alt="图6：多个远程仓库"></p><ul><li>图片来源于<a href="https://git-scm.com/book/en/v2/Git-Branching-Remote-Branches" target="_blank" rel="noopener">官网</a></li></ul><h3 id="（5）push分支到远程"><a href="#（5）push分支到远程" class="headerlink" title="（5）push分支到远程"></a>（5）push分支到远程</h3><ul><li>只推送你想跟别人共享的分支deploy</li></ul><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git push origin deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="（6）在本地仓库建立一个新分支并与远程仓库对应"><a href="#（6）在本地仓库建立一个新分支并与远程仓库对应" class="headerlink" title="（6）在本地仓库建立一个新分支并与远程仓库对应"></a>（6）在本地仓库建立一个新分支并与远程仓库对应</h3><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git checkout -b serverfix origin/serverfixgit checkout -b sf origin/serverfixgit checkout --track origin/serverfix<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="（7）查看本地分支跟踪的是哪个远程分支及具体信息"><a href="#（7）查看本地分支跟踪的是哪个远程分支及具体信息" class="headerlink" title="（7）查看本地分支跟踪的是哪个远程分支及具体信息"></a>（7）查看本地分支跟踪的是哪个远程分支及具体信息</h3><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># 如果想查看远程最新信息则先用fetch命令# git fetch --all  git branch -vv<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="（8）删除远程分支"><a href="#（8）删除远程分支" class="headerlink" title="（8）删除远程分支"></a>（8）删除远程分支</h3><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git push origin --delete serverfix<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>注意：</strong>Basically all this does is remove the pointer from the server. The Git server will generally keep the data there for a while until a garbage collection runs, so if it was accidentally deleted, it’s often easy to recover.</p><h2 id="4、Rebasing"><a href="#4、Rebasing" class="headerlink" title="4、Rebasing"></a>4、Rebasing</h2><h3 id="（1）什么是Rebasing？"><a href="#（1）什么是Rebasing？" class="headerlink" title="（1）什么是Rebasing？"></a>（1）什么是Rebasing？</h3><ul><li>In Git, there are two main ways to integrate changes from one branch into another: the <code>merge</code> and the <code>rebase</code>. </li></ul><h3 id="（2）merge"><a href="#（2）merge" class="headerlink" title="（2）merge"></a>（2）merge</h3><p><img src="/2019/11/12/git/merge.png" alt="图7：merge"></p><h3 id="（3）Rebasing"><a href="#（3）Rebasing" class="headerlink" title="（3）Rebasing"></a>（3）Rebasing</h3><p><img src="/2019/11/12/git/rebasing.png" alt="图8：rebasing"></p><ul><li>如上图，rebasing相当于是把c4这个commit_id抹去，这样会导致这个提交信息被清除，<strong>有利也有弊</strong>。</li></ul><p><strong>注意：</strong></p><ul><li>Do not rebase commits that exist outside your repository and people may have based work on them.</li><li>即不要rebase别人的提交信息，导致混淆产生。</li></ul><h3 id="（4）merge-vs-rebasing"><a href="#（4）merge-vs-rebasing" class="headerlink" title="（4）merge vs rebasing"></a>（4）merge vs rebasing</h3><ul><li>个人还是觉得merge好，但是如果合并历史太多，可以酌情使用rebasing</li></ul><h1 id="Git进阶-Git-Flow"><a href="#Git进阶-Git-Flow" class="headerlink" title="Git进阶-Git Flow"></a>Git进阶-Git Flow</h1><h2 id="Git-Flow简介"><a href="#Git-Flow简介" class="headerlink" title="Git Flow简介"></a>Git Flow简介</h2><h3 id="Git-Flow是什么？"><a href="#Git-Flow是什么？" class="headerlink" title="Git Flow是什么？"></a>Git Flow是什么？</h3><ul><li>团队合作开发时，主分支、开发分支、功能分支、bug分支等等必不可少。那么问题来了，<strong>多人多分支的情况应该如何制定一个工作流程才不产生冲突呢？</strong>答案是：<ol><li>Git Flow</li><li>GitHub Flow</li><li>GitLab Flow</li></ol></li><li>Git Flow让我们更方便的管理一个项目</li></ul><h3 id="Git-Flow安装"><a href="#Git-Flow安装" class="headerlink" title="Git Flow安装"></a>Git Flow安装</h3><ul><li><p>For Windows users, <a href="https://github.com/petervanderdoes/gitflow-avh/wiki/Installing-on-Windows#git-for-windows" target="_blank" rel="noopener">Git for Windows</a> is the recommended method.</p><h2 id="Git-for-Windows"><a href="#Git-for-Windows" class="headerlink" title="Git for Windows"></a>Git for Windows</h2><p>Follow the instructions on the <a href="https://git-for-windows.github.io/" target="_blank" rel="noopener">Git for Windows homepage</a> to install Git for Windows. As of Git for Windows 2.6.4, GitFlow (AVH edition) is included, so you’re all done.</p></li></ul><h2 id="Git-Flow操作"><a href="#Git-Flow操作" class="headerlink" title="Git Flow操作"></a>Git Flow操作</h2><h3 id="寻求帮助"><a href="#寻求帮助" class="headerlink" title="寻求帮助"></a>寻求帮助</h3><pre class="line-numbers language-lang-gitbash"><code class="language-lang-gitbash">git flow help  # 查看命令帮助<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="在仓库中设置git-flow"><a href="#在仓库中设置git-flow" class="headerlink" title="在仓库中设置git-flow"></a>在仓库中设置git-flow</h3><pre class="line-numbers language-lang-gitbash"><code class="language-lang-gitbash">git flow init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>注意：</strong></p><ol><li>把项目切换到git-flow时，就用git-flow命令操作</li><li>普通的git命令和git-flow命令互不冲突</li><li>git-flow不会改变仓库</li><li>使用<code>git flow init</code>命令时，实际上只是在<strong>当前分支配置了一些命名规则</strong></li></ol><h3 id="分支的模式"><a href="#分支的模式" class="headerlink" title="分支的模式"></a>分支的模式</h3><h4 id="长期分支"><a href="#长期分支" class="headerlink" title="长期分支"></a>长期分支</h4><p>git-flow会预设两个主分支在仓库中，也就是说要同时维护两个分支</p><ul><li>master：正式环境代码，不能在这个分支上工作</li><li>develop： 开发分支，以该分支为基础分支来进行功能开发等等</li></ul><h4 id="短期分支"><a href="#短期分支" class="headerlink" title="短期分支"></a>短期分支</h4><p>短期分支只是临时存在，当开发完成则可以删除该分支</p><ul><li>feature：功能开发分支</li><li>hotfix：bug修复分支</li><li>release：版本发布分支</li></ul><p><img src="/2019/11/12/git/git_flow_branch.png" alt="图：git-flow分支模式"></p><h3 id="功能开发分支-feature"><a href="#功能开发分支-feature" class="headerlink" title="功能开发分支-feature"></a>功能开发分支-feature</h3><p>feature分支基于develop分支</p><pre class="line-numbers language-lang-gitbash"><code class="language-lang-gitbash">git flow feature start concat  # 新增留言功能<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>git flow feature start new_feature</code>命令会在develop分支上创建一个new_feature分支，然后就可以在该分支上进行功能开发</li><li>当完成功能开发后，合并与删除分支命令如下</li></ul><pre class="line-numbers language-lang-gitbash"><code class="language-lang-gitbash">git flow feature finish concat  # 完成功能开发<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>git flow feature finsih concat</code>命令会把concat分支开发的内容整合到develop分支中，并把concat分支删除</li></ul><h3 id="版本管理-release"><a href="#版本管理-release" class="headerlink" title="版本管理-release"></a>版本管理-release</h3><p>release分支基于develop分支</p><p>当develop分支的代码已经成熟时，就可以把<strong>这部分工作生成一个要发布的版本</strong>，使用如下命令生成版本号以及版本管理</p><pre class="line-numbers language-lang-gitbash"><code class="language-lang-gitbash">git flow release start 1.1.1  # 版本号1.1.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>上述命令产生release分支后，再对该分支的一些文件记录版本号则可以使用以下命令进行版本发布</li></ul><pre class="line-numbers language-lang-gitbash"><code class="language-lang-gitbash">git flow release finish 1.1.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>git flow release finish 1.1.1</code>命令会做如下操作<ol><li>拉取远程仓库，确保本地仓库是最新</li><li>release分支的内容会合并到master和develop分支上</li><li>删除release分支，并回到develop分支</li></ol></li></ul><h3 id="bug修复-hotfix"><a href="#bug修复-hotfix" class="headerlink" title="bug修复-hotfix"></a>bug修复-hotfix</h3><h4 id="创建hotfix"><a href="#创建hotfix" class="headerlink" title="创建hotfix"></a>创建hotfix</h4><p>hotfix分支是基于master分支的，对已发布的代码修复bug</p><pre class="line-numbers language-lang-gitbash"><code class="language-lang-gitbash">git flow hotfix start bug1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="完成hotfix分支"><a href="#完成hotfix分支" class="headerlink" title="完成hotfix分支"></a>完成hotfix分支</h4><pre class="line-numbers language-lang-gitbash"><code class="language-lang-gitbash">git flow hotfix finish bug1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>git flow hotfix finish bug1</code>内部操作如下<ol><li>完成的改动会合并到master和develop分支上</li><li>这个hotfix程序将被标记</li><li>hotfix分支被删除，然后回到develop分支</li><li><strong>然后利用release分支操作发布版本</strong></li></ol></li></ul><h1 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h1><ul><li><a href="https://git-scm.com/book/en/v2" target="_blank" rel="noopener">官方教程</a></li><li><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">廖大神</a></li></ul><h1 id="疑难解答"><a href="#疑难解答" class="headerlink" title="疑难解答"></a>疑难解答</h1><h2 id="清除历史提交中的敏感信息"><a href="#清除历史提交中的敏感信息" class="headerlink" title="清除历史提交中的敏感信息"></a>清除历史提交中的敏感信息</h2><h3 id="问题介绍"><a href="#问题介绍" class="headerlink" title="问题介绍"></a>问题介绍</h3><ul><li>某次提交把私人信息（密码或私钥等）提交到了远程仓库，该怎么办？</li></ul><h3 id="处理方式"><a href="#处理方式" class="headerlink" title="处理方式"></a>处理方式</h3><h4 id="第一种情况"><a href="#第一种情况" class="headerlink" title="第一种情况"></a>第一种情况</h4><ul><li>提交的敏感信息<strong>还没有推送到远程仓库</strong></li></ul><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># 修改代码git commit --amend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="第二种情况"><a href="#第二种情况" class="headerlink" title="第二种情况"></a>第二种情况</h4><ul><li>提交的敏感信息<strong>已经推送到远程仓库</strong></li></ul><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git filter-branch --force --index-filter 'git rm --cached --ignore-unmatch your_want_to_rm_file_name' --prune-empty --tag-name-filter cat -- --allgit add .git commit -m "rm some files"git push origin --force --all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><a href="https://stackoverflow.com/questions/872565/remove-sensitive-files-and-their-commits-from-git-history" target="_blank" rel="noopener">参考链接</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程与开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop笔记</title>
      <link href="/2019/11/12/hadoop/"/>
      <url>/2019/11/12/hadoop/</url>
      
        <content type="html"><![CDATA[<h1 id="Hadoop介绍"><a href="#Hadoop介绍" class="headerlink" title="Hadoop介绍"></a>Hadoop介绍</h1><h2 id="第一部分-简介"><a href="#第一部分-简介" class="headerlink" title="第一部分-简介"></a>第一部分-简介</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>Hadoop是apache下的一个开源分布式计算平台</li><li>基于Java开发，跨平台特性好（其他编程语言也可以使用），可以部署再廉价的计算机集群中</li><li>核心是HDFS（分布式文件系统）和MapReduce</li></ul><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>高可靠性：冗余副本和容错机制</li><li>高效性：把成百上千的服务器集中起来做分布式处理</li><li>高可扩展性：几个到上千个节点</li><li>高容错性：冗余副本和容错机制</li><li>成本低：整个机器集群可以是很多低端机</li><li>运行在Linux平台上：原生是Linux</li><li>支持多种编程语言：基于Java开发，但还可以多种语言开发</li></ul><h2 id="第二部分-结构"><a href="#第二部分-结构" class="headerlink" title="第二部分-结构"></a>第二部分-结构</h2><h3 id="企业应用架构"><a href="#企业应用架构" class="headerlink" title="企业应用架构"></a>企业应用架构</h3><p><img src="/2019/11/12/hadoop/hadoop_structure.png" alt="图：Hadoop在企业应用结构"></p><h3 id="各种版本"><a href="#各种版本" class="headerlink" title="各种版本"></a>各种版本</h3><p><img src="/2019/11/12/hadoop/hadoop_version.png" alt="图：Hadoop版本"></p><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p><img src="/2019/11/12/hadoop/hadoop_project_structure.jpg" alt="图：Hadoop项目结构"></p><ul><li>分布式存储系统-HDFS：怎么用成百上千的机器去存储文件，详情请见<a href="/2019/11/27/hdfs/" title="HDFS笔记">HDFS笔记</a></li><li>分布式计算框架-YARN：负责计算资源调度，内存、CPU、带宽等等</li><li>离线计算-MapReduce：分布式并行编程模型，离线计算、批处理，基于磁盘，详情请见</li><li>DAG计算-Tez：运行在YARN之上的下一代Hadoop查询处理框架，将很多的MapReduce作业进行分析优化以后构建成一个有向无环图（DAG），保证获得最好的处理效率，详情请见</li><li>内存计算-Spark：类似MapReduce的通用并行框架，基于内存计算，性能比MapReduce高，详情请见<a href="/2019/12/12/spark/" title="Spark笔记">Spark笔记</a></li><li>Hive：Hadoop上的数据仓库，把大量的历史数据保存到数据仓库中，建立各种维度，专门用于企业决策分析，支持SQL语句，会将SQL语句转化为MapReduce作业去执行，详情请见<a href="/2019/10/12/hive/" title="Hive笔记">Hive笔记</a></li><li>Pig：基于Hadoop的大规模数据分析平台，提供类似SQL的查询语言Pig Latin，流数据处理，轻量级分析，用一两行语句就可以跟复杂的MapReduce语句得到一样的结果，详情请见</li><li>作业流调度系统-Oozie：把很多个工作环节进行调度，详情请见</li><li>分布式协调服务-ZooKeeper：提供分布式协调一致性服务，分布式锁，集群管理等操作，详情请见</li><li>分布式数据库-HBase：Hadoop上的非关系型分布式数据库，基于列的存储，随机读写，支持实时应用，详情请见<a href="/2020/06/11/hbase/" title="HBase笔记">HBase笔记</a></li><li>日志收集-Flume：高可用、高可靠、分布式的海量日志采集、聚合和传输的系统，详情请见</li><li>数据库TEL工具-Sqoop：用于在Hadoop与传统数据库之间的数据传递，完成数据导入导出，详情请见</li><li>安装部署工具-Ambari：快速部署工具，支持Hadoop集群的供应、管理和监控，详情请见</li></ul><h2 id="第三部分-本机安装"><a href="#第三部分-本机安装" class="headerlink" title="第三部分-本机安装"></a>第三部分-本机安装</h2><h3 id="apache-Hadoop安装与使用"><a href="#apache-Hadoop安装与使用" class="headerlink" title="apache Hadoop安装与使用"></a>apache Hadoop安装与使用</h3><ul><li><a href="http://dblab.xmu.edu.cn/blog/285/" target="_blank" rel="noopener">大数据技术原理与应用提供的安装教程</a></li></ul><h3 id="Hadoop三种shell命令的区别"><a href="#Hadoop三种shell命令的区别" class="headerlink" title="Hadoop三种shell命令的区别"></a>Hadoop三种shell命令的区别</h3><ul><li>hadoop fs 适用于任何不同的文件系统</li><li>hadoop dfs 只能适用于HDFS文件系统</li><li>hdfs dfs 只能适用于HDFS文件系统</li></ul><h2 id="第四部分-集群部署"><a href="#第四部分-集群部署" class="headerlink" title="第四部分-集群部署"></a>第四部分-集群部署</h2><h3 id="集群节点类型及硬件配置"><a href="#集群节点类型及硬件配置" class="headerlink" title="集群节点类型及硬件配置"></a>集群节点类型及硬件配置</h3><p><img src="/2019/11/12/hadoop/hdfs_architecture.png" alt="图：HDFS结构"></p><ul><li>NameNode：负责协调集群中的数据存储，获得数据的地址信息，哪块在哪个机器这样子（HDFS节点）</li><li>DataNode：存储被拆分的数据块（HDFS节点）</li><li>JobTracker：协调数据计算任务（MapReduce节点）</li><li>TaskTracker：负责执行由JobTracker指派的任务（MapReduce节点）</li><li>SecondaryNameNode（冷备份）：帮助NameNode收集文件系统运行的状态信息（HDFS节点）</li></ul><p>集群规模可大可小，可以一步一步往上加机器。</p><p>在集群中，大部分的机器是作为DataNode和TaskTracker工作的，所以DataNode和TaskTracker的硬件规则可以采用以下方案：</p><ul><li>4个磁盘驱动器（单盘1-2T），支持JBOD（just a bunch of disks，磁盘簇）</li><li>2个4核CPU，至少2-2.5GHz</li><li>16-24GB内存</li><li>千兆以太网</li></ul><p>NameNode提供整个HDFS文件系统的命名空间管理、块管理等所有服务，所以需要更多的RAM，并且需要优化RAM的内存通道带宽，可以采用以下方案：</p><ul><li>8-12个磁盘驱动器（单盘1-2T）</li><li>2个4核/8核CPU</li><li>16-72GB内存</li><li>千兆/万兆以太网</li></ul><p>SecondaryNameNode在小型集群可以和NameNode共用一台机器，较大的集群可以采用与NameNode一样的硬件</p><h3 id="集群网络拓扑"><a href="#集群网络拓扑" class="headerlink" title="集群网络拓扑"></a>集群网络拓扑</h3><p><img src="/2019/11/12/hadoop/network_tuo.png" alt="图：网络拓扑"></p><h3 id="集群建立与安装"><a href="#集群建立与安装" class="headerlink" title="集群建立与安装"></a>集群建立与安装</h3><ul><li>自动化部署：Docker等</li></ul><h3 id="集群基准测试"><a href="#集群基准测试" class="headerlink" title="集群基准测试"></a>集群基准测试</h3><ul><li>Hadoop自带一些基准测试程序</li></ul><h3 id="在云计算环境中实用Hadoop"><a href="#在云计算环境中实用Hadoop" class="headerlink" title="在云计算环境中实用Hadoop"></a>在云计算环境中实用Hadoop</h3><p>企业不需要自己部署集群，直接在云上部署</p><ul><li>可以在Amazon EC2中运行Hadoop</li></ul><h1 id="Hadoop进阶"><a href="#Hadoop进阶" class="headerlink" title="Hadoop进阶"></a>Hadoop进阶</h1><h1 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h1><ul><li><a href="https://study.163.com/course/courseMain.htm?courseId=1002887002" target="_blank" rel="noopener">大数据技术原理与应用</a></li></ul><h1 id="疑难解答"><a href="#疑难解答" class="headerlink" title="疑难解答"></a>疑难解答</h1>]]></content>
      
      
      <categories>
          
          <category> AI/数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据科学 </tag>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo创建个人博客</title>
      <link href="/2019/11/12/hexo-blog/"/>
      <url>/2019/11/12/hexo-blog/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Hexo介绍"><a href="#一、Hexo介绍" class="headerlink" title="一、Hexo介绍"></a>一、Hexo介绍</h1><h2 id="1、官网"><a href="#1、官网" class="headerlink" title="1、官网"></a>1、官网</h2><p><a href="https://hexo.io/zh-cn/index.html" target="_blank" rel="noopener">Hexo</a></p><h2 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h2><h3 id="（1）Node-js（Windows）"><a href="#（1）Node-js（Windows）" class="headerlink" title="（1）Node.js（Windows）"></a>（1）Node.js（Windows）</h3><ol><li><p><a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">官网</a>下载对应版本</p></li><li><p>安装选择全部默认（也可以自己设定安装位置）</p></li><li><p>安装完，键盘上<code>Win+R</code>打开命令行，输入以下命令出现版本号即安装成功</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">node -vnpm -v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h3 id="（2）Git（Windows）"><a href="#（2）Git（Windows）" class="headerlink" title="（2）Git（Windows）"></a>（2）Git（Windows）</h3><ol><li><p><a href="https://git-scm.com/" target="_blank" rel="noopener">官网</a>下载对应版本</p></li><li><p>安装选择全部默认（也可以自己设定安装位置）</p></li><li><p>最后一步也可以选择<code>Use Git from the Windows Command Prompt</code>，这样就可以命令行打开<code>git</code></p></li><li><p>安装完，命令行输入以下命令出现版本号即安装成功</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git --version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="（3）Hexo（Windows）"><a href="#（3）Hexo（Windows）" class="headerlink" title="（3）Hexo（Windows）"></a>（3）Hexo（Windows）</h3><ol><li><p>在Windows上选定一个目录作为博客目录，在该目录下右键点击<code>Git Bash Here</code>，接下来使用git控制台进行Hexo的安装</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">npm i hexo-cli -ghexo -v  # 验证安装是否成功<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h1 id="二、GitHub"><a href="#二、GitHub" class="headerlink" title="二、GitHub"></a>二、GitHub</h1><h2 id="1、官网-1"><a href="#1、官网-1" class="headerlink" title="1、官网"></a>1、官网</h2><p><a href="https://github.com/" target="_blank" rel="noopener">GitHub</a></p><h2 id="2、注册"><a href="#2、注册" class="headerlink" title="2、注册"></a>2、注册</h2><p>官网跟着指引注册就OK</p><h2 id="3、创建博客仓库"><a href="#3、创建博客仓库" class="headerlink" title="3、创建博客仓库"></a>3、创建博客仓库</h2><h3 id="（1）如图操作"><a href="#（1）如图操作" class="headerlink" title="（1）如图操作"></a>（1）如图操作</h3><p><img src="/2019/11/12/hexo-blog/create1.png" alt="图1"></p><p><img src="/2019/11/12/hexo-blog/create2.png" alt="图2"></p><h3 id="（2）注意事项"><a href="#（2）注意事项" class="headerlink" title="（2）注意事项"></a>（2）注意事项</h3><ol><li>第二张图中的第一步yourname一定要跟Owner的名字一样，且一定要加<code>.github.io</code>后缀（至于为什么，我也不得而知）</li></ol><h2 id="4、给仓库选择主题"><a href="#4、给仓库选择主题" class="headerlink" title="4、给仓库选择主题"></a>4、给仓库选择主题</h2><h3 id="（1）如图操作-1"><a href="#（1）如图操作-1" class="headerlink" title="（1）如图操作"></a>（1）如图操作</h3><p><img src="/2019/11/12/hexo-blog/create3.png" alt="图3"></p><p><img src="/2019/11/12/hexo-blog/create4.png" alt="图4"></p><h1 id="三、写博客并发布到GitHub"><a href="#三、写博客并发布到GitHub" class="headerlink" title="三、写博客并发布到GitHub"></a>三、写博客并发布到GitHub</h1><h2 id="1、本地网站配置"><a href="#1、本地网站配置" class="headerlink" title="1、本地网站配置"></a>1、本地网站配置</h2><h3 id="（1）命令如下（在博客目录下）"><a href="#（1）命令如下（在博客目录下）" class="headerlink" title="（1）命令如下（在博客目录下）"></a>（1）命令如下（在博客目录下）</h3><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">hexo init  # 初始化该目录npm install  # 安装必备的组件hexo g  # 生成静态网页hexo s  # 打开本地服务器并复制地址到chrome打开ctrl c  # 关闭本地服务器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="（2）chrome打开本地网站地址"><a href="#（2）chrome打开本地网站地址" class="headerlink" title="（2）chrome打开本地网站地址"></a>（2）chrome打开本地网站地址</h3><ol><li><a href="http://localhost:4000/" target="_blank" rel="noopener"><a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></a></li></ol><h2 id="2、-写新文章"><a href="#2、-写新文章" class="headerlink" title="2、 写新文章"></a>2、 写新文章</h2><h3 id="（1）命令如下（在博客目录下）-1"><a href="#（1）命令如下（在博客目录下）-1" class="headerlink" title="（1）命令如下（在博客目录下）"></a>（1）命令如下（在博客目录下）</h3><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">npm i hexo-deployer-git  # 安装拓展hexo new post "new md file"  # 新建一篇文章# 修改./source/_posts下的md文件hexo ghexo sctrl c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、连接GitHub"><a href="#3、连接GitHub" class="headerlink" title="3、连接GitHub"></a>3、连接GitHub</h2><h3 id="（1）如何配置连接"><a href="#（1）如何配置连接" class="headerlink" title="（1）如何配置连接"></a>（1）如何配置连接</h3><ol><li>详情请见另一篇文章：<a href="/2019/11/12/git/" title="Git">Git</a></li></ol><h3 id="（2）修改配置"><a href="#（2）修改配置" class="headerlink" title="（2）修改配置"></a>（2）修改配置</h3><ol><li><p>命令（在博客目录下）</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">vi _config.ymla  # 修改# 如下图修改最后几行Esc  # 退出修改:wq!  # 保存<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>如图</p></li></ol><p><img src="/2019/11/12/hexo-blog/create5.png" alt="图5"></p><ol><li>注意：修改图中标红的地方就OK，换成你自己的name</li></ol><h3 id="（3）配置全局git-name-and-email"><a href="#（3）配置全局git-name-and-email" class="headerlink" title="（3）配置全局git name and email"></a>（3）配置全局git name and email</h3><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git config --global user.name "your github name"git config --global user.email "your github private email"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​    <strong>注意：</strong><code>your github private email</code>怎么配置请看<a href="/2019/11/12/git/" title="Git">Git</a></p><h3 id="（4）发布到GitHub"><a href="#（4）发布到GitHub" class="headerlink" title="（4）发布到GitHub"></a>（4）发布到GitHub</h3><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">hexo d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="（5）同时拥有gitlab-and-github账号时"><a href="#（5）同时拥有gitlab-and-github账号时" class="headerlink" title="（5）同时拥有gitlab and github账号时"></a>（5）同时拥有gitlab and github账号时</h3><ol><li><p>发布完后，将全局git name and email改为gitlab账号</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git config --global user.name "your gitlab name"git config --global user.email "your gitlab private email"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>进入<code>.deploy_git</code>配置局部账号即github账号</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">cd .deploy_git  # 根目录下进入.deploy_git# 配置git config --local user.name "your github name"git config --local user.email "your github private email"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>这样配置后，hexo d就是用github账号push，对gitlab push就是用gitlab账号</p></li></ol><h2 id="4、新的文章"><a href="#4、新的文章" class="headerlink" title="4、新的文章"></a>4、新的文章</h2><h3 id="（1）添加新md"><a href="#（1）添加新md" class="headerlink" title="（1）添加新md"></a>（1）添加新md</h3><ol><li><p>在./source/_posts下添加新的md文件</p></li><li><p>使用命令push</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">hexo ghexo d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h3 id="（2）插入图片"><a href="#（2）插入图片" class="headerlink" title="（2）插入图片"></a>（2）插入图片</h3><ol><li><p>安装插件</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">npm install https://github.com/CodeFalling/hexo-asset-image --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><ol><li><p>修改<code>_config_yml</code>配置</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">post_asset_folder: true  # 将false改为true<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>在<code>./source/_posts</code>中新建一个md文件时，同时创建一个与md文件同名的文件夹，该文件夹用来存放该md文件所需图片</p></li><li>接着在md文件中以<code>![](/md文件名/1.png)</code>的格式插入图片</li><li>详细教程请见<a href="http://etrd.org/2017/01/23/hexo中完美插入本地图片/" target="_blank" rel="noopener">ETRD博客</a></li></ol><h3 id="（3）插入markdown"><a href="#（3）插入markdown" class="headerlink" title="（3）插入markdown"></a>（3）插入markdown</h3><ol><li><p>Hexo的<a href="https://hexo.io/zh-cn/docs/tag-plugins.html" target="_blank" rel="noopener">标签插件</a></p></li><li><p>引用站内文章</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">{% post_path filename %}{% post_link filename [title] [escape] %}{% post_link hexo-3-8-released %} # 链接使用文章的标题<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>在使用此标签时可以忽略文章文件所在的路径或者文章的永久链接信息、如语言、日期。</p><p>例如，在文章中使用 <code></code> 时，只需有一个名为 <code>how-to-bake-a-cake.md</code> 的文章文件即可。即使这个文件位于站点文件夹的 <code>source/posts/2015-02-my-family-holiday</code> 目录下、或者文章的永久链接是 <code>2018/en/how-to-bake-a-cake</code>，都没有影响。</p><p>默认链接文字是文章的标题，你也可以自定义要显示的文本。此时不应该使用 Markdown 语法 <code>[]()</code>。</p><p>默认对文章的标题和自定义标题里的特殊字符进行转义。可以使用<code>escape</code>选项，禁止对特殊字符进行转义。</p></li><li><p><a href="https://www.jibing57.com/2017/10/30/how-to-use-post-link-on-hexo/" target="_blank" rel="noopener">参考链接</a></p></li></ol><h2 id="5、更换主题"><a href="#5、更换主题" class="headerlink" title="5、更换主题"></a>5、更换主题</h2><ul><li><a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank" rel="noopener">hexo-theme-matery</a></li></ul><h3 id="（1）设置文章头-一劳永逸"><a href="#（1）设置文章头-一劳永逸" class="headerlink" title="（1）设置文章头-一劳永逸"></a>（1）设置文章头-一劳永逸</h3><ul><li>修改<code>/scaffolds/post.md</code>代码如下：</li></ul><pre class="line-numbers language-lang-markdown"><code class="language-lang-markdown">---title: {{ title }}date: {{ date }}author: Myhaaimg:top: falsecover: falsecoverImg:password:toc: truemathjax: falsesummary: categories: tags:  - ---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="（2）修改subtitle"><a href="#（2）修改subtitle" class="headerlink" title="（2）修改subtitle"></a>（2）修改subtitle</h3><p><img src="/2019/11/12/hexo-blog/xiugaisubtitle.png" alt="图：修改subtitle"></p><p><strong>注意：</strong>第一步修改应该是在<code>bg-cover-content.ejs</code>中</p><h3 id="（3）修改dream"><a href="#（3）修改dream" class="headerlink" title="（3）修改dream"></a>（3）修改dream</h3><p><img src="/2019/11/12/hexo-blog/xiugaidream.png" alt="图：修改dream"></p><h2 id="6、让HEXO搭建的博客支持Latex"><a href="#6、让HEXO搭建的博客支持Latex" class="headerlink" title="6、让HEXO搭建的博客支持Latex"></a>6、让HEXO搭建的博客支持Latex</h2><p><a href="https://cps.ninja/2019/03/16/hexo-with-latex/" target="_blank" rel="noopener">参考</a></p><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>安装 <a href="https://github.com/hexojs/hexo-math" target="_blank" rel="noopener">hexo-math</a> 插件，该插件（plugin）可支持使用 <a href="https://www.mathjax.org/" target="_blank" rel="noopener">MathJax</a> 或 <a href="https://katex.org/" target="_blank" rel="noopener">KaTeX</a> 来实现 LaTeX 排版系统，进而在网页上渲染出数学表达式（本文以 MathJax 为例）。</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">## 打开终端，进入 hexo 博客所在文件夹$ cd ~/blog## 安装 hexo ； --save 参数会让 npm 在安装 hexo-math 之后自动将它写入 package.json 文件里，以便之后多电脑同步时使用$ npm install hexo-math --save<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将 Hexo 默认的 markdown 渲染引擎 <a href="https://github.com/hexojs/hexo-renderer-marked" target="_blank" rel="noopener">hexo-renderer-marked</a> 更换为 <a href="https://github.com/sun11/hexo-renderer-kramed" target="_blank" rel="noopener">hexo-renderer-kramed</a> ，引擎是在默认的渲染引擎的基础上修改了一些 bug 而已。此处不更换也没问题，本文以更换为例。</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">## 卸载默认 markdown 渲染引擎 hexo-renderer-marked；若不卸载，会和新的引擎发生冲突（conflict）$ npm uninstall hexo-renderer-marked --save## 安装新引擎 hexo-renderer-kramed $ npm install hexo-renderer-kramed --save<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="修改-kramed-配置，解决语义冲突"><a href="#修改-kramed-配置，解决语义冲突" class="headerlink" title="修改 kramed 配置，解决语义冲突"></a>修改 kramed 配置，解决语义冲突</h3><p>由于 LaTeX 与 Markdown 语法存在冲突（例如在 markdown 中，<em>斜体</em>可以用 <code>*</code> 或者 <code>_</code> 表示，而 LaTeX 也会用到 <code>_</code> ），所以我们要对 kramed 默认的语法规则进行修改，否则之后会出现很多奇怪的排版样式。</p><p>打开 <code>~/blog/node_modules\kramed\lib\rules\inline.js</code> 文件（Hexo 博客所在文件夹的根目录下的 <code>node_modules</code> 文件夹），把第 11 行的 <code>escape</code> 变量的值修改为：</p><pre class="line-numbers language-lang-javascript"><code class="language-lang-javascript">escape: /^\\([`*\[\]()#$+\-.!_>])/,<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同时把第 20 行的 <code>em</code> 变量修改为：</p><pre class="line-numbers language-lang-javascript"><code class="language-lang-javascript">em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="设置-config-yml-开启-MathJax-渲染引擎（-重要-）"><a href="#设置-config-yml-开启-MathJax-渲染引擎（-重要-）" class="headerlink" title="设置 _config.yml 开启 MathJax 渲染引擎（==重要==）"></a>设置 _config.yml 开启 MathJax 渲染引擎（==重要==）</h3><p>在 <code>~/blog/_config.yml</code> 文件（注意，是 Hexo 博客文件夹<strong>根目录</strong>中的 <code>/_config.yml</code> 而不是主题目录下的 <code>/themes/next/_config.yml</code>）中增加 MathJax 的支持，并手动设置下面的 src（这一步很重要，使用默认的 src 会导致数学表达式渲染显示失败。这里的关键是 src 中的 <code>?config=TeX-MML-AM_CHTML</code> 这个字段）</p><pre class="line-numbers language-lang-yml"><code class="language-lang-yml">......# MathJaxmath:  engine: 'mathjax'  mathjax:    src: https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML   ......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程与开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推荐算法笔记</title>
      <link href="/2019/10/17/recommendation-algorithm/"/>
      <url>/2019/10/17/recommendation-algorithm/</url>
      
        <content type="html"><![CDATA[<h1 id="一、CF-Collaborative-Filtering"><a href="#一、CF-Collaborative-Filtering" class="headerlink" title="一、CF(Collaborative-Filtering)"></a>一、CF(Collaborative-Filtering)</h1><p>主要思想：</p><p>协同过滤推荐方法的主要思想是：利用已有用户群过去的行为或意见预测当前用户最可能喜欢哪些东西或对哪些东西感兴趣。</p><h2 id="1、基于用户的协同过滤"><a href="#1、基于用户的协同过滤" class="headerlink" title="1、基于用户的协同过滤"></a>1、基于用户的协同过滤</h2><p>潜在假设：</p><ul><li>如果用户过去有相似的偏好，那么他们未来也会有相似的偏好；</li><li>用户偏好不会随时间而变化</li></ul><p>主要思想：</p><ul><li>首先，给定一个评分数据集和当前用户的ID作为输入，找出与当前用户过去有相似偏好的其他用户；</li><li>然后，对当前用户没有评价过的物品，利用最近邻对物品的评分计算预测值。</li></ul><p>（1）协同推荐的评分数据库（例子1）</p><div class="table-container"><table><thead><tr><th></th><th>物品1</th><th>物品2</th><th>物品3</th></tr></thead><tbody><tr><td>用户1</td><td>5</td><td>4</td><td>？</td></tr><tr><td>用户2</td><td>3</td><td>4</td><td>5</td></tr><tr><td>用户3</td><td>4</td><td>5</td><td>3</td></tr></tbody></table></div><p>（2）算法步骤</p><ul><li>利用用户已有的物品评分<code>rate</code>计算用户之间的相似度$sim(a, b)$，相似度计算方法可以是<strong><code>pearson</code>相关系数、改进余弦相似度、<code>spearman</code>秩相关系数、均方差等</strong>。（计算相似度是用两个用户拥有共同行为物品的评分来计算）</li><li>针对要预测的每个用户，选择与其相似度排名最靠前的<code>k</code>个用户对指定物品的评分做加权计算来得到该用户对该物品的评分。</li></ul><p>（3）面临的挑战</p><ul><li>用户量和物品量很大时，算法性能不高</li><li>当需要扫描大量潜在近邻时，很难做到实时计算预测值</li></ul><h2 id="2、基于物品的协同过滤"><a href="#2、基于物品的协同过滤" class="headerlink" title="2、基于物品的协同过滤"></a>2、基于物品的协同过滤</h2><p>主要思想：</p><ul><li>利用物品间的相似度来计算预测值</li></ul><h1 id="二、FM-Factorization-Machine"><a href="#二、FM-Factorization-Machine" class="headerlink" title="二、FM(Factorization Machine)"></a>二、FM(Factorization Machine)</h1><h1 id="三、FFM-Field-Factorization-Machine"><a href="#三、FFM-Field-Factorization-Machine" class="headerlink" title="三、FFM(Field Factorization Machine)"></a>三、FFM(Field Factorization Machine)</h1><h1 id="四、DEEP-amp-WIDE"><a href="#四、DEEP-amp-WIDE" class="headerlink" title="四、DEEP &amp; WIDE"></a>四、DEEP &amp; WIDE</h1>]]></content>
      
      
      <categories>
          
          <category> AI/数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据科学 </tag>
            
            <tag> 推荐算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python笔记</title>
      <link href="/2019/10/15/python/"/>
      <url>/2019/10/15/python/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Python基础"><a href="#一、Python基础" class="headerlink" title="一、Python基础"></a>一、Python基础</h1><h1 id="二、Python进阶"><a href="#二、Python进阶" class="headerlink" title="二、Python进阶"></a>二、Python进阶</h1><h1 id="三、参考书籍"><a href="#三、参考书籍" class="headerlink" title="三、参考书籍"></a>三、参考书籍</h1><h1 id="四、疑难解答"><a href="#四、疑难解答" class="headerlink" title="四、疑难解答"></a>四、疑难解答</h1><h2 id="1、编码问题"><a href="#1、编码问题" class="headerlink" title="1、编码问题"></a>1、编码问题</h2><h3 id="Python2编码问题"><a href="#Python2编码问题" class="headerlink" title="Python2编码问题"></a><code>Python2</code>编码问题</h3><ul><li><a href="https://foofish.net/why-Python-encoding-is-tricky.html" target="_blank" rel="noopener">参考</a></li></ul><h3 id="Python3编码问题"><a href="#Python3编码问题" class="headerlink" title="Python3编码问题"></a><code>Python3</code>编码问题</h3><ul><li>在<code>Python3</code>版本中，把<code>&#39;xxx&#39;</code>和<code>u&#39;xxx&#39;</code>统一成<code>Unicode</code>编码，即写不写前缀<code>u</code>都是一样的。</li><li>在<code>Python3</code>版本中，所有的字符串都是使用<code>Unicode</code>编码的字符串序列。</li><li><a href="https://foofish.net/how-Python3-handle-charset-encoding.html" target="_blank" rel="noopener">参考</a></li></ul><h2 id="2、日期操作"><a href="#2、日期操作" class="headerlink" title="2、日期操作"></a>2、日期操作</h2><ul><li><a href="https://www.runoob.com/python/python-date-time.html" target="_blank" rel="noopener">参考菜鸟教程</a></li></ul><h3 id="产生一段时间的日期"><a href="#产生一段时间的日期" class="headerlink" title="产生一段时间的日期"></a>产生一段时间的日期</h3><pre class="line-numbers language-lang-python"><code class="language-lang-python">from datetime import datetime, date, timedeltaimport pandas as pddate_id_list = [datetime.strftime(x, '%Y%m%d') for x in list(pd.date_range(start='20190701', end='20190928'))]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="获取指定日期的前-后N天"><a href="#获取指定日期的前-后N天" class="headerlink" title="获取指定日期的前-后N天"></a>获取指定日期的前-后N天</h3><pre class="line-numbers language-lang-python"><code class="language-lang-python">import datetimen = 1tomorrow = datetime.datetime(2015, 10, 28) + datetime.timedelta(days=1)    # 2015-10-29 00:00:00tomorrow_format = tomorrow.strftime('%Y%m%d')    # '20151029'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、mrjob运行参数详情"><a href="#3、mrjob运行参数详情" class="headerlink" title="3、mrjob运行参数详情"></a>3、mrjob运行参数详情</h2><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">python xxx.py -r hadoop --local-tmp-dir 'xxx' --hadoop-tmp-dir 'hdfs:xxx' --file 'xxx.txt' --jobconf mapred.map.tasks=20 --jobconf mapred.reduce.tasks=2 input.txt -o output_dir<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>参考官方文档：</strong><a href="https://mrjob.readthedocs.io/en/latest/" target="_blank" rel="noopener">mrjob</a></p><h2 id="4、list中排列组合"><a href="#4、list中排列组合" class="headerlink" title="4、list中排列组合"></a>4、list中排列组合</h2><pre class="line-numbers language-lang-python"><code class="language-lang-python">from itertools import combinationscombine_2 = list(combinations([1,2,3,4], 2))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="5、文件操作"><a href="#5、文件操作" class="headerlink" title="5、文件操作"></a>5、文件操作</h2><h3 id="获取指定目录下指定文件"><a href="#获取指定目录下指定文件" class="headerlink" title="获取指定目录下指定文件"></a>获取指定目录下指定文件</h3><pre class="line-numbers language-lang-python"><code class="language-lang-python">import osL = []for root, dirs, files in os.walk(os.getcwd()):    for x in files:        if os.path.splitext(x)[1] == '.txt':            L.append(os.path.join(root, x))file_path = L[0]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="pandas读取excel文件"><a href="#pandas读取excel文件" class="headerlink" title="pandas读取excel文件"></a>pandas读取excel文件</h3><pre class="line-numbers language-lang-python"><code class="language-lang-python">roc_data = pd.read_excel(file_path, sheet_name='20200323_10000')roc_data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="6、命令行参数sys-argv-1-解析"><a href="#6、命令行参数sys-argv-1-解析" class="headerlink" title="6、命令行参数sys.argv[1:]解析"></a>6、命令行参数<code>sys.argv[1:]</code>解析</h2><ul><li><a href="https://www.cnblogs.com/itech/archive/2010/12/31/1919017.html" target="_blank" rel="noopener">python类库31—命令行解析</a></li></ul><h3 id="手动解析"><a href="#手动解析" class="headerlink" title="手动解析"></a>手动解析</h3><h3 id="getopt解析"><a href="#getopt解析" class="headerlink" title="getopt解析"></a>getopt解析</h3><h3 id="optionparser解析【推荐】"><a href="#optionparser解析【推荐】" class="headerlink" title="optionparser解析【推荐】"></a>optionparser解析【推荐】</h3><h2 id="7、字典排序"><a href="#7、字典排序" class="headerlink" title="7、字典排序"></a>7、字典排序</h2><pre class="line-numbers language-lang-python"><code class="language-lang-python">result = {}sorted(result.items(), key=lambda x: x[1], reverse=True)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="8、python自动登录Linux等服务"><a href="#8、python自动登录Linux等服务" class="headerlink" title="8、python自动登录Linux等服务"></a>8、python自动登录Linux等服务</h2><p><a href="https://pexpect.readthedocs.io/en/stable/overview.html" target="_blank" rel="noopener">参考</a></p><pre class="line-numbers language-lang-python"><code class="language-lang-python">import pexpectchild = pexpect.spawn('ftp ftp.openbsd.org')child.expect('Name .*: ')child.sendline('anonymous')child.expect('Password:')child.sendline('noah@example.com')child.expect('ftp> ')child.sendline('lcd /tmp')child.expect('ftp> ')child.sendline('cd pub/OpenBSD')child.expect('ftp> ')child.sendline('get README')child.expect('ftp> ')child.sendline('bye')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9、-生成requirements-txt"><a href="#9、-生成requirements-txt" class="headerlink" title="9、 生成requirements.txt"></a>9、 生成requirements.txt</h2><h3 id="第一种方法：太多太杂，对整个虚拟环境的"><a href="#第一种方法：太多太杂，对整个虚拟环境的" class="headerlink" title="第一种方法：太多太杂，对整个虚拟环境的"></a>第一种方法：太多太杂，对整个虚拟环境的</h3><pre class="line-numbers language-lang-python"><code class="language-lang-python"># 生成pip freeze > requirements.txt# 安装pip install -r requirements.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="第二种方法：需要pip安装模块，但是可以对指定目录进行生成"><a href="#第二种方法：需要pip安装模块，但是可以对指定目录进行生成" class="headerlink" title="第二种方法：需要pip安装模块，但是可以对指定目录进行生成"></a>第二种方法：需要pip安装模块，但是可以对指定目录进行生成</h3><pre><code># pip 安装模块pip3 install pipreqs# 对指定目录进行生成requirements.txtcd 到指定目录pipreqs ./ --encoding=utf8# 这样在指定目录就会有requirements.txt的依赖文件</code></pre><h2 id="10、python取mysql中文乱码"><a href="#10、python取mysql中文乱码" class="headerlink" title="10、python取mysql中文乱码"></a>10、python取mysql中文乱码</h2><ol><li>mysql代码中将中文字段用<code>hex</code>函数转换</li><li>python代码中用<code>bytes.fromhex(取出的字段).decode(&#39;utf-8&#39;)</code>来转换</li></ol><h2 id="11、更新所有模块"><a href="#11、更新所有模块" class="headerlink" title="11、更新所有模块"></a>11、更新所有模块</h2><ul><li><a href="https://pypi.org/project/pip-review/" target="_blank" rel="noopener">参考</a></li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">pip3 install pip-reviewpip-review --interactive<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程与开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux笔记</title>
      <link href="/2019/10/14/linux/"/>
      <url>/2019/10/14/linux/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Linux基础"><a href="#一、Linux基础" class="headerlink" title="一、Linux基础"></a>一、Linux基础</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="rsync"><a href="#rsync" class="headerlink" title="rsync"></a>rsync</h3><ul><li><a href="https://man.linuxde.net/rsync" target="_blank" rel="noopener">参考</a></li></ul><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">rsync [OPTION]... SRC DESTrsync [OPTION]... SRC [USER@]host:DESTrsync [OPTION]... [USER@]HOST:SRC DESTrsync [OPTION]... [USER@]HOST::SRC DESTrsync [OPTION]... SRC [USER@]HOST::DESTrsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC [DEST]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对应于以上六种命令格式，rsync有六种不同的工作模式：</p><ol><li>拷贝本地文件。当SRC和DES路径信息都不包含有单个冒号”:”分隔符时就启动这种工作模式。如：<code>rsync -a /data /backup</code></li><li>使用一个远程shell程序(如<a href="http://man.linuxde.net/rsh" target="_blank" rel="noopener">rsh</a>、<a href="http://man.linuxde.net/ssh" target="_blank" rel="noopener">ssh</a>)来实现将本地机器的内容拷贝到远程机器。当DST路径地址包含单个冒号”:”分隔符时启动该模式。如：<code>rsync -avz *.c foo:src</code></li><li>使用一个远程shell程序(如rsh、ssh)来实现将远程机器的内容拷贝到本地机器。当SRC地址路径包含单个冒号”:”分隔符时启动该模式。如：<code>rsync -avz foo:src/bar /data</code></li><li>从远程rsync服务器中拷贝文件到本地机。当SRC路径信息包含”::”分隔符时启动该模式。如：<code>rsync -av root@192.168.78.192::www /databack</code></li><li>从本地机器拷贝文件到远程rsync服务器中。当DST路径信息包含”::”分隔符时启动该模式。如：<code>rsync -av /databack root@192.168.78.192::www</code></li><li>列远程机的文件列表。这类似于rsync传输，不过只要在命令中省略掉本地机信息即可。如：<code>rsync -v rsync://192.168.78.192/www</code></li></ol><h4 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">-v, --verbose 详细模式输出。-q, --quiet 精简输出模式。-c, --checksum 打开校验开关，强制对文件传输进行校验。-a, --archive 归档模式，表示以递归方式传输文件，并保持所有文件属性，等于-rlptgoD。-r, --recursive 对子目录以递归模式处理。-R, --relative 使用相对路径信息。-b, --backup 创建备份，也就是对于目的已经存在有同样的文件名时，将老的文件重新命名为~filename。可以使用--suffix选项来指定不同的备份文件前缀。--backup-dir 将备份文件(如~filename)存放在在目录下。-suffix=SUFFIX 定义备份文件前缀。-u, --update 仅仅进行更新，也就是跳过所有已经存在于DST，并且文件时间晚于要备份的文件，不覆盖更新的文件。-l, --links 保留软链结。-L, --copy-links 想对待常规文件一样处理软链结。--copy-unsafe-links 仅仅拷贝指向SRC路径目录树以外的链结。--safe-links 忽略指向SRC路径目录树以外的链结。-H, --hard-links 保留硬链结。-p, --perms 保持文件权限。-o, --owner 保持文件属主信息。-g, --group 保持文件属组信息。-D, --devices 保持设备文件信息。-t, --times 保持文件时间信息。-S, --sparse 对稀疏文件进行特殊处理以节省DST的空间。-n, --dry-run现实哪些文件将被传输。-w, --whole-file 拷贝文件，不进行增量检测。-x, --one-file-system 不要跨越文件系统边界。-B, --block-size=SIZE 检验算法使用的块尺寸，默认是700字节。-e, --rsh=command 指定使用rsh、ssh方式进行数据同步。--rsync-path=PATH 指定远程服务器上的rsync命令所在路径信息。-C, --cvs-exclude 使用和CVS一样的方法自动忽略文件，用来排除那些不希望传输的文件。--existing 仅仅更新那些已经存在于DST的文件，而不备份那些新创建的文件。--delete 删除那些DST中SRC没有的文件。--delete-excluded 同样删除接收端那些被该选项指定排除的文件。--delete-after 传输结束以后再删除。--ignore-errors 及时出现IO错误也进行删除。--max-delete=NUM 最多删除NUM个文件。--partial 保留那些因故没有完全传输的文件，以是加快随后的再次传输。--force 强制删除目录，即使不为空。--numeric-ids 不将数字的用户和组id匹配为用户名和组名。--timeout=time ip超时时间，单位为秒。-I, --ignore-times 不跳过那些有同样的时间和长度的文件。--size-only 当决定是否要备份文件时，仅仅察看文件大小而不考虑文件时间。--modify-window=NUM 决定文件是否时间相同时使用的时间戳窗口，默认为0。-T --temp-dir=DIR 在DIR中创建临时文件。--compare-dest=DIR 同样比较DIR中的文件来决定是否需要备份。-P 等同于 --partial。--progress 显示备份过程。-z, --compress 对备份的文件在传输时进行压缩处理。--exclude=PATTERN 指定排除不需要传输的文件模式。--include=PATTERN 指定不排除而需要传输的文件模式。--exclude-from=FILE 排除FILE中指定模式的文件。--include-from=FILE 不排除FILE指定模式匹配的文件。--version 打印版本信息。--address 绑定到特定的地址。--config=FILE 指定其他的配置文件，不使用默认的rsyncd.conf文件。--port=PORT 指定其他的rsync服务端口。--blocking-io 对远程shell使用阻塞IO。-stats 给出某些文件的传输状态。--progress 在传输时现实传输过程。--log-format=formAT 指定日志文件格式。--password-file=FILE 从FILE中得到密码。--bwlimit=KBPS 限制I/O带宽，KBytes per second。-h, --help 显示帮助信息。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="二、Linux进阶"><a href="#二、Linux进阶" class="headerlink" title="二、Linux进阶"></a>二、Linux进阶</h1><h1 id="三、参考书籍"><a href="#三、参考书籍" class="headerlink" title="三、参考书籍"></a>三、参考书籍</h1><h1 id="四、疑难解答"><a href="#四、疑难解答" class="headerlink" title="四、疑难解答"></a>四、疑难解答</h1><h2 id="1、修改文件或目录的权限"><a href="#1、修改文件或目录的权限" class="headerlink" title="1、修改文件或目录的权限"></a>1、修改文件或目录的权限</h2><p>（1）语法</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">chmod [-cfvR] [--help] [--version] mode file...<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（2）参数说明</p><p><strong>mode :</strong> 权限设定字串，格式如下 :</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">[ugoa...][[+-=][rwxX]...][,...]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>其中：</strong></p><ul><li>u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。</li><li>+ 表示增加权限、- 表示取消权限、= 表示唯一设定权限。</li><li>r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。</li></ul><p>（3）其他参数说明：</p><ul><li>-c : 若该文件权限确实已经更改，才显示其更改动作</li><li>-f : 若该文件权限无法被更改也不要显示错误讯息</li><li>-v : 显示权限变更的详细资料</li><li>-R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)</li><li>—help : 显示辅助说明</li><li>—version : 显示版本</li></ul><p>（4）实例</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># 给个人目录的其他用户删除写权限 hadoop fs -chmod -R o-w /user/name/dir<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="2、vim-文本搜索"><a href="#2、vim-文本搜索" class="headerlink" title="2、vim 文本搜索"></a>2、vim 文本搜索</h2><h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><ul><li>在Linux环境中，一个大文本中搜索指定字符串应该怎么操作？</li></ul><h3 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h3><pre class="line-numbers language-lang-linux"><code class="language-lang-linux">vi my.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>键盘按<code>Esc</code></li><li>输入<code>/search_string</code></li><li>键盘按<code>n</code>或者<code>N</code>来进行向前或向后搜索</li></ul><h2 id="3、日期循环"><a href="#3、日期循环" class="headerlink" title="3、日期循环"></a>3、日期循环</h2><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">#! /bin/bashstart=20200312end=20200322while [ ${start} -le ${end} ]do  echo ${start}  start=`date -d "1 day ${start}" +%Y%m%d`    # 日期自增done<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>参考<a href="https://sjq597.github.io/2015/11/03/Shell-按日期循环执行/" target="_blank" rel="noopener">日期循环</a></li></ul><h2 id="4、将代码输出重定向到log文件-不覆盖的形式"><a href="#4、将代码输出重定向到log文件-不覆盖的形式" class="headerlink" title="4、将代码输出重定向到log文件-不覆盖的形式"></a>4、将代码输出重定向到log文件-不覆盖的形式</h2><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">0 11 * * * /usr/bin/python3 /home/meiyunhe/adsp_new/orientation.py >> /home/meiyunhe/adsp_new/logs1_ori.txt 2>&1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程与开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记</title>
      <link href="/2019/10/13/java/"/>
      <url>/2019/10/13/java/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Java基础"><a href="#一、Java基础" class="headerlink" title="一、Java基础"></a>一、Java基础</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><ul><li><p><code>JDK</code>：Java Development Kit</p><p>如果只有Java源码，要编译成Java字节码，就需要JDK，因为JDK除了包含JRE，还提供了编译器JavaC、调试器JDB等开发工具</p></li><li><p><code>JRE</code>：Java Runtime Environment</p><p>JRE就是运行Java字节码的虚拟机</p></li></ul><ul><li><p><code>IDE</code>：Integrated Development Environment </p><p>流行的有：Eclipse、IntelliJ Idea</p></li></ul><h3 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h3><ul><li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1280507291631649" target="_blank" rel="noopener">安装链接</a></li></ul><h3 id="安装IDE"><a href="#安装IDE" class="headerlink" title="安装IDE"></a>安装IDE</h3><ul><li><a href="https://www.jetbrains.com/idea/" target="_blank" rel="noopener">IntelliJ Idea</a></li></ul><h2 id="程序基础"><a href="#程序基础" class="headerlink" title="程序基础"></a>程序基础</h2><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>（1）一个完整的Java程序。</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">/** * 可以用来自动创建文档的注释 */public class Hello {    public static void main(String[] args) {        // 向屏幕输出文本:        final double PI = 3.14; // PI是一个常量        System.out.println("Hello, world!");        /* 多行注释开始        注释内容        注释结束 */    }} // class定义结束<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）结构解释</p><ul><li>一个程序的基本单位是<code>class</code>。类名要求必须以英文字母开头，后接字母，数字和下划线的组合，习惯以大写字母开头。</li><li><code>public</code>是访问修饰符，表示该class是公开的。</li><li><code>main</code>是方法名，返回值是<code>void</code>。</li><li>每一行语句后面都要加分号<code>;</code>。</li><li>一个文件顶多一个public类，且类名与文件名一致。</li><li><code>final</code>是常量修饰符。</li></ul><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><p>（1）变量定义、赋值示例程序。</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Main {    public static void main(String[] args) {        int n = 100; // 定义变量n，同时赋值为100        System.out.println("n = " + n); // 打印n的值        n = 200; // 变量n赋值为200        System.out.println("n = " + n); // 打印n的值        int x = n; // 变量x赋值为n（n的值为200，因此赋值后x的值也是200）        System.out.println("x = " + x); // 打印x的值        x = x + 100; // 变量x赋值为x+100（x的值为200，因此赋值后x的值是200+100=300）        System.out.println("x = " + x); // 打印x的值        System.out.println("n = " + n); // 再次打印n的值，n应该是200还是300？200   }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）基本类型：变量是“持有”某个数值</p><ul><li><p>整数</p><p>byte(8bit)、short(16bit)、int(32bit)、long(64bit)</p></li><li><p>浮点数</p><p>float(32bit)、double(64bit)</p></li><li><p>字符</p><p>char(16bit)</p></li><li><p>布尔</p></li></ul><p>（3）引用类型：变量是“指向”某个对象</p><ol><li><p>字符串</p><p>String</p></li></ol><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><p><strong>注意</strong>：由于存在范围限制，如果计算结果超出了范围，就会产生溢出，而溢出<em>不会出错</em>，却会得到一个奇怪的结果</p><p>（1）整数运算</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Main {    public static void main(String[] args) {        int i = (100 + 200) * (99 - 88); // 3300        int n = 7 * (5 + (i - 9)); // 23072        n ++;        n --;        System.out.println(i);        System.out.println(n);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong>：<code>++n</code>表示先加1再引用n，<code>n++</code>表示先引用n再加1。</p><ul><li>整数运算的结果永远是精确的；</li><li>运算结果会自动提升；例如，<code>short</code>和<code>int</code>计算，结果总是<code>int</code>，原因是<code>short</code>首先自动被转型为<code>int</code>；</li><li>可以强制转型，但超出范围的强制转型会得到错误的结果；例如，将<code>int</code>强制转型为<code>short</code>；</li><li><p>应该选择合适范围的整型（<code>int</code>或<code>long</code>），没有必要为了节省内存而使用<code>byte</code>和<code>short</code>进行整数运算。</p></li><li><p>运算优先级从高到低：</p><ul><li><code>()</code></li><li><code>!</code> <code>~</code> <code>++</code> <code>--</code></li><li><code>*</code> <code>/</code> <code>%</code></li><li><code>+</code> <code>-</code></li><li><code>&lt;&lt;</code> <code>&gt;&gt;</code> <code>&gt;&gt;&gt;</code></li><li><code>&amp;</code> ：与运算，是位运算</li><li><code>|</code> ：或运算</li><li><code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code></li></ul></li></ul><p>（2）浮点数运算</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 浮点数误差public class Main {    public static void main(String[] args) {        double x = 1.0 / 10;        double y = 1 - 9.0 / 10;        // 观察x和y是否相等:        System.out.println(x);        System.out.println(y);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>浮点数常常无法精确表示，并且浮点数的运算结果可能有误差；</li><li>比较两个浮点数通常比较它们的绝对值之差是否小于一个特定值；</li><li>整型和浮点型运算时，整型会自动提升为浮点型；</li><li>可以将浮点型强制转为整型，但超出范围后将始终返回整型的最大值。</li><li>浮点数运算和整数运算相比，只能进行加减乘除这些数值计算，不能做位运算和移位运算。</li></ul><p>（3）布尔运算</p><ul><li><p>关系运算符优先级从高到低：</p><ul><li><code>!</code></li><li><code>&gt;</code>，<code>&gt;=</code>，<code>&lt;</code>，<code>&lt;=</code></li><li><code>==</code>，<code>!=</code></li><li><code>&amp;&amp;</code></li><li><code>||</code></li></ul></li><li><p>短路运算：</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Main {    public static void main(String[] args) {        boolean b = 5 < 3;        boolean result = b && (5 / 0 > 0);        System.out.println(result);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>因为<code>false &amp;&amp; x</code>的结果总是<code>false</code>，无论<code>x</code>是<code>true</code>还是<code>false</code>，因此，与运算在确定第一个值为<code>false</code>后，不再继续计算，而是直接返回<code>false</code>。</li><li>如果没有短路运算，<code>&amp;&amp;</code>后面的表达式会由于除数为<code>0</code>而报错，但实际上该语句并未报错，原因在于与运算是短路运算符，提前计算出了结果<code>false</code>。</li></ul></li><li><p>三元运算符</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Main {    public static void main(String[] args) {        int n = -100;        int x = n >= 0 ? n : -n;        System.out.println(x);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="字符和字符串"><a href="#字符和字符串" class="headerlink" title="字符和字符串"></a>字符和字符串</h3><ul><li><p>Java的字符类型<code>char</code>是基本类型，字符串类型<code>String</code>是引用类型；</p></li><li><p>基本类型的变量是“持有”某个数值，引用类型的变量是“指向”某个对象；</p></li><li><p>引用类型的变量可以是空值<code>null</code>；</p></li><li><p>要区分空值<code>null</code>和空字符串<code>&quot;&quot;</code>。</p></li><li><p>可以使用<code>+</code>连接任意字符串和其他数据类型：</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Main {    public static void main(String[] args) {        int age = 25;        String s = "age is " + age;        System.out.println(s);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>字符串不可变：</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Main {    public static void main(String[] args) {        String s = "hello";        String t = s;        s = "world";        System.out.println(t); // t是"hello"还是"world"? "hello"    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="数组类型和操作"><a href="#数组类型和操作" class="headerlink" title="数组类型和操作"></a>数组类型和操作</h3><ul><li><p>数组类型，数组是引用类型</p><p><strong>注意</strong>：这里的<code>s</code>指向了<code>name[1]</code>之后，即将<code>s</code>指向了<code>&quot;XYZ&quot;</code>，这个是不变的字符串常量</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Main {    public static void main(String[] args) {        String[] names = {"ABC", "XYZ", "zoo"};        String s = names[1];        names[1] = "cat";        System.out.println(s); // s是"XYZ"还是"cat"?  "XYZ"     }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>数组元素可以是值类型（如int）或引用类型（如String），但数组本身是引用类型；</li><li>数组是同一数据类型的集合，数组一旦创建后，大小就不可变；</li><li>可以通过索引访问数组元素，但索引超出范围将报错；</li></ul></li><li><p>数组操作</p><ul><li><p>遍历数组</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">for (int n : ns)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">for (int i=0; i<ns.length; i++)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">import Java.util.Arrays;int[] ns = { 1, 1, 2, 3, 5, 8 };System.out.println(Arrays.toString(ns));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>数组排序</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">import Java.util.Arrays;int[] ns = { 28, 12, 89, 73, 65};Arrays.sort(ns); //正序<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>多维数组</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">import Java.util.Arrays;int[][] ns = {            { 1, 2, 3, 4 },            { 5, 6, 7, 8 },            { 9, 10, 11, 12 }        };System.out.println(Arrays.deepToString(ns));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h3><ul><li><p>输出：<code>System.out.println(&quot;END&quot;);</code></p></li><li><p>格式化输出：<code>System.out.printf(&quot;%.4f\n&quot;, d);</code></p></li><li><p>占位符及说明</p><p>| 占位符 | 说明                             |<br>| :——- | :———————————————- |<br>| %d     | 格式化输出整数                   |<br>| %x     | 格式化输出十六进制整数           |<br>| %f     | 格式化输出浮点数                 |<br>| %e     | 格式化输出科学计数法表示的浮点数 |<br>| %s     | 格式化字符串                     |</p></li><li><p>输入：</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">import Java.util.Scanner;public class Main {    public static void main(String[] args) {        Scanner scanner = new Scanner(System.in); // 创建Scanner对象        System.out.print("Input your name: "); // 打印提示        String name = scanner.nextLine(); // 读取一行输入并获取字符串        System.out.print("Input your age: "); // 打印提示        int age = scanner.nextInt(); // 读取一行输入并获取整数        System.out.printf("Hi, %s, you are %d\n", name, age); // 格式化输出    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="IF判断"><a href="#IF判断" class="headerlink" title="IF判断"></a>IF判断</h3><ul><li><p><code>if</code>基本语法：</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">if (条件) {    // 条件满足时执行} else if (条件) {    // } else {    //}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>判断浮点数相等时利用差值小于某个临界值来判断：<code>Math.abs(a-b)&lt;0.00001</code></li><li>判断引用类型的变量内容是否相等，必须使用<code>equals()</code>方法：<code>s1.equals(s2)</code></li></ul></li></ul><h3 id="SWITCH多重选择"><a href="#SWITCH多重选择" class="headerlink" title="SWITCH多重选择"></a>SWITCH多重选择</h3><ul><li><p><code>switch</code>语句可以做多重选择，然后执行匹配的<code>case</code>语句后续代码；<code>switch</code>的计算结果必须是整型、字符串或枚举类型；注意千万不要漏写<code>break</code>，建议打开<code>fall-through</code>警告；总是写上<code>default</code>，建议打开<code>missing default</code>警告；<strong>从Java 13开始，<code>switch</code>语句升级为表达式，不再需要<code>break</code>，并且允许使用<code>yield</code>返回值。</strong></p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Main {    public static void main(String[] args) {        int option = 1;        switch (option) {        case 1:            System.out.println("Selected 1");            break;        case 2:            System.out.println("Selected 2");            break;        default:            System.out.println("Selected 3");            break;        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="WHILE循环"><a href="#WHILE循环" class="headerlink" title="WHILE循环"></a>WHILE循环</h3><ul><li><p><code>while</code>基本语法：</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">while (条件表达式) {    循环语句}// 继续执行后续代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>do while</code>基本语法：</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">do {    执行循环语句} while (条件表达式);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="FOR循环"><a href="#FOR循环" class="headerlink" title="FOR循环"></a>FOR循环</h3><ul><li><p><code>for</code>循环基本语法：</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">for (初始条件; 循环检测条件; 循环后更新计数器) {    // 执行语句}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="BREAK-AND-CONTINUE"><a href="#BREAK-AND-CONTINUE" class="headerlink" title="BREAK AND CONTINUE"></a>BREAK AND CONTINUE</h3><ul><li><code>break</code>：在循环过程中，可以使用<code>break</code>语句跳出当前循环</li><li><code>continue</code>：前结束本次循环，直接继续执行下次循环。</li></ul><h1 id="二、Java进阶"><a href="#二、Java进阶" class="headerlink" title="二、Java进阶"></a>二、Java进阶</h1><h2 id="面向对象编程基础"><a href="#面向对象编程基础" class="headerlink" title="面向对象编程基础"></a>面向对象编程基础</h2><h3 id="什么是面向对象？"><a href="#什么是面向对象？" class="headerlink" title="什么是面向对象？"></a>什么是面向对象？</h3><ul><li><p>简单来说，人就是一个<strong>对象</strong>，将人身高、年龄等特征封装到人这个对象里，定义人这个类。具体到小明、小芳这些人就被称为<strong>实例</strong>。</p></li><li><p>定义对象</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">class Person {    public String name;    public int age;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>创建实例</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">Person ming = new Person();ming.name = "Xiao Ming";<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>指向实例的变量<code>ming</code>是引用变量</li></ul></li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li><p>方法（<code>method</code>）可以让外部代码安全地访问实例字段（<code>filed</code>）；</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Main {    public static void main(String[] args) {        Person ming = new Person();        ming.setName("Xiao Ming"); // 设置name        System.out.println(ming.getName());    }}class Person {    private String name;    public String getName() {        return this.name;    }    public void setName(String name) {        this.name = name;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>方法是一组执行语句，并且可以执行任意逻辑；</p></li><li><p>方法内部遇到return时返回，void表示不返回任何值（注意和返回null不同）；</p></li><li><p>外部代码通过public方法操作实例，内部代码可以调用private方法；其中<code>this</code>变量是一个隐含变量，通过<code>this.field</code>就可以访问当前实例的字段。</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">class Person {    private String name;    private int birth;    public void setBirth(int birth) {        this.birth = birth;    }    public int getAge() {        return calcAge(2019); // 调用private方法    }    // private方法:    private int calcAge(int currentYear) {        return currentYear - this.birth;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>理解方法的参数绑定。</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 基本类型参数绑定public class Main {    public static void main(String[] args) {        Person p = new Person();        int n = 15; // n的值为15        p.setAge(n); // 传入n的值        System.out.println(p.getAge()); // 15        n = 20; // n的值改为20        System.out.println(p.getAge()); // 15还是20?  15    }}class Person {    private int age;    public int getAge() {        return this.age;    }    public void setAge(int age) {        this.age = age;    }}// 引用类型参数绑定public class Main {    public static void main(String[] args) {        Person p = new Person();        String[] fullname = new String[] { "Homer", "Simpson" };        p.setName(fullname); // 传入fullname数组        System.out.println(p.getName()); // "Homer Simpson"        fullname[0] = "Bart"; // fullname数组的第一个元素修改为"Bart"        System.out.println(p.getName()); // "Homer Simpson"还是"Bart Simpson"?  Bart Simpson    }}class Person {    private String[] name;    public String getName() {        return this.name[0] + " " + this.name[1];    }    public void setName(String[] name) {        this.name = name;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>基本类型参数的传递，是调用方值的复制。双方各自的后续修改，互不影响。</li><li>引用类型参数的传递，调用方的变量，和接收方的参数变量，指向的是同一个对象。双方任意一方对这个对象的修改，都会影响对方（因为指向同一个对象嘛）。</li></ul></li></ul><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><p>由于构造方法是如此特殊，所以构造方法的名称就是类名。构造方法的参数没有限制，在方法内部，也可以编写任意语句。但是，和普通方法相比，构造方法没有返回值（也没有<code>void</code>），调用构造方法，必须用<code>new</code>操作符。</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Main {    public static void main(String[] args) {        Person p = new Person("Xiao Ming", 15);        System.out.println(p.getName());        System.out.println(p.getAge());    }}class Person {    private String name;    private int age;    // 构造方法    public Person(String name, int age) {        this.name = name;        this.age = age;    }    public String getName() {        return this.name;    }    public int getAge() {        return this.age;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>如果一个类没有定义构造方法，编译器会自动为我们生成一个默认构造方法，它没有参数，也没有执行语句</p></li><li><p>如果既要能使用带参数的构造方法，又想保留不带参数的构造方法，那么只能把两个构造方法都定义出来：</p></li><li><p>既对字段进行初始化，又在构造方法中对字段进行初始化：</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">class Person {    private String name = "Unamed";    private int age = 10;    public Person(String name, int age) {        this.name = name;        this.age = age;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>多构造方法</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">class Person {    private String name;    private int age;    public Person(String name, int age) {        this.name = name;        this.age = age;    }    public Person(String name) {        this.name = name;        this.age = 12;    }    public Person() {    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>在通过<code>new</code>操作符调用的时候，编译器通过构造方法的参数数量、位置和类型自动区分</p></li><li><p>一个构造方法可以调用其他构造方法，这样做的目的是便于代码复用。调用其他构造方法的语法是<code>this(…)</code></p><pre class="line-numbers language-lang-java"><code class="language-lang-java">class Person {    private String name;    private int age;    public Person(String name, int age) {        this.name = name;        this.age = age;    }    public Person(String name) {        this(name, 18); // 调用另一个构造方法Person(String, int)    }    public Person() {        this("Unnamed"); // 调用另一个构造方法Person(String)    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><ul><li><p>这种方法名相同，但各自的参数不同，称为方法重载（<code>Overload</code>）。</p><p><strong>注意</strong>：方法重载的返回值类型通常都是相同的。</p></li><li><p>重载方法应该完成类似的功能，参考<code>String</code>的<code>indexOf()</code>；</p></li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li><p>继承是面向对象编程中非常强大的一种机制，它首先可以复用代码。当我们让<code>Student</code>从<code>Person</code>继承时，<code>Student</code>就获得了<code>Person</code>的所有功能，我们只需要为<code>Student</code>编写新增的功能。</p><p>Java使用<code>extends</code>关键字来实现继承：</p><p><strong>注意</strong>：一定要加<code>super</code>调用父类的构造方法</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Main {    public static void main(String[] args) {        Student s = new Student("Xiao Ming", 12, 89);    }}class Person {    protected String name;    protected int age;    public Person(String name, int age) {        this.name = name;        this.age = age;    }}// 继承Personclass Student extends Person {    protected int score;    public Student(String name, int age, int score) {        super(name, age); // 调用父类的构造方法Person(String, int)        this.score = score;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="Java核心类"><a href="#Java核心类" class="headerlink" title="Java核心类"></a>Java核心类</h2><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h1 id="三、参考书籍"><a href="#三、参考书籍" class="headerlink" title="三、参考书籍"></a>三、参考书籍</h1><ul><li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744" target="_blank" rel="noopener">廖大神</a></li></ul><h1 id="四、疑难解答"><a href="#四、疑难解答" class="headerlink" title="四、疑难解答"></a>四、疑难解答</h1><h2 id="1、使用IntelliJ-IDEA-配置Maven"><a href="#1、使用IntelliJ-IDEA-配置Maven" class="headerlink" title="1、使用IntelliJ IDEA 配置Maven"></a>1、使用IntelliJ IDEA 配置Maven</h2><ul><li><a href="https://blog.csdn.net/qq_32588349/article/details/51461182" target="_blank" rel="noopener">参考</a></li></ul><h2 id="2、Intellij-IDEA-打包jar的多种方式"><a href="#2、Intellij-IDEA-打包jar的多种方式" class="headerlink" title="2、Intellij IDEA 打包jar的多种方式"></a>2、Intellij IDEA 打包jar的多种方式</h2><ul><li><a href="https://blog.csdn.net/Thousa_Ho/article/details/72799871" target="_blank" rel="noopener">参考</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程与开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive笔记</title>
      <link href="/2019/10/12/hive/"/>
      <url>/2019/10/12/hive/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Hive基础"><a href="#一、Hive基础" class="headerlink" title="一、Hive基础"></a>一、Hive基础</h1><h2 id="1、Hive数据类型"><a href="#1、Hive数据类型" class="headerlink" title="1、Hive数据类型"></a>1、Hive数据类型</h2><p>（1）原始类型</p><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">描述</th><th style="text-align:center">示例</th></tr></thead><tbody><tr><td style="text-align:center"><code>Boolean</code></td><td style="text-align:center"><code>true</code>、<code>false</code></td><td style="text-align:center"><code>TRUE</code></td></tr><tr><td style="text-align:center"><code>TINYINT</code></td><td style="text-align:center">-128~127</td><td style="text-align:center"><code>1Y</code></td></tr><tr><td style="text-align:center"><code>SMALLINT</code></td><td style="text-align:center">-32768~32767</td><td style="text-align:center"><code>1S</code></td></tr><tr><td style="text-align:center"><code>INT</code></td><td style="text-align:center">4个字节的带符号整数</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center"><code>BIGINT</code></td><td style="text-align:center">8字节带符号整数</td><td style="text-align:center"><code>1L</code></td></tr><tr><td style="text-align:center"><code>FLOAT</code></td><td style="text-align:center">4字节单精度浮点数</td><td style="text-align:center">1.0</td></tr><tr><td style="text-align:center"><code>DOUBLE</code></td><td style="text-align:center">8字节双精度浮点数</td><td style="text-align:center">1.0</td></tr><tr><td style="text-align:center"><code>DECIMAL</code></td><td style="text-align:center">任意精度的带符号小数</td><td style="text-align:center">1.0</td></tr><tr><td style="text-align:center"><code>STRING</code></td><td style="text-align:center">字符串</td><td style="text-align:center"><code>‘ABC’</code></td></tr><tr><td style="text-align:center"><code>VARCHAR</code></td><td style="text-align:center">长字符串</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><code>CHAR</code></td><td style="text-align:center">固定长度字符串</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><code>BINARY</code></td><td style="text-align:center">字节数组</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><code>TIMESTAMP</code></td><td style="text-align:center">时间戳，纳秒精度</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><code>DATE</code></td><td style="text-align:center">日期</td><td style="text-align:center"><code>2019-10-08</code></td></tr></tbody></table></div><p>（2）复杂类型</p><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">描述</th><th style="text-align:center">示例</th></tr></thead><tbody><tr><td style="text-align:center"><code>ARRAY</code></td><td style="text-align:center">有序的的同类型的集合</td><td style="text-align:center"><code>array(1,2)</code></td></tr><tr><td style="text-align:center"><code>MAP</code></td><td style="text-align:center">key-value<br>key必须为原始类型，value可以任意类型</td><td style="text-align:center"><code>map(‘a’,1,’b’,2)</code></td></tr><tr><td style="text-align:center"><code>UNION</code></td><td style="text-align:center">在有限取值范围内的一个值</td><td style="text-align:center"><code>create_union(1,’a’,63)</code></td></tr><tr><td style="text-align:center"><code>STRUCT</code></td><td style="text-align:center">字段集合,类型可以不同</td><td style="text-align:center"><code>struct(‘1’,1,1.0)</code></td></tr></tbody></table></div><h2 id="2、Hive数据库操作"><a href="#2、Hive数据库操作" class="headerlink" title="2、Hive数据库操作"></a>2、Hive数据库操作</h2><p>（1）创建数据库</p><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">-- 命令CREATE DATABASE|SCHEMA [IF NOT EXISTS] <database name>;-- 例子CREATE DATABASE IF NOT EXISTS database_name;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）删除数据库</p><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">-- 命令DROP DATABASE StatementDROP (DATABASE|SCHEMA) [IF EXISTS] database_name [RESTRICT|CASCADE];-- 例子DROP DATABASE IF EXISTS userdb;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、Hive表操作"><a href="#3、Hive表操作" class="headerlink" title="3、Hive表操作"></a>3、Hive表操作</h2><p>（1）创建表</p><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">-- 命令CREATE [TEMPORARY] [EXTERNAL] TABLE [IF NOT EXISTS] [db_name.] table_name[(col_name data_type [COMMENT col_comment], ...)][COMMENT table_comment][ROW FORMAT row_format][STORED AS file_format]-- 例子CREATE TABLE IF NOT EXISTS employee(eid int,  name String, salary String,  destination String)COMMENT ‘Employee details’ROW FORMAT DELIMITEDFIELDS TERMINATED BY ‘\t’LINES TERMINATED BY ‘\n’STORED AS TEXTFILE;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）修改表</p><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">-- 重命名表ALTER TABLE name RENAME TO new_nameALTER TABLE employee RENAME TO emp;-- 添加列ALTER TABLE name ADD COLUMNS (col_spec[, col_spec ...])ALTER TABLE employee ADD COLUMNS (    dept STRING COMMENT 'Department name');-- 删除列ALTER TABLE name DROP [COLUMN] column_name-- 更改列属性ALTER TABLE name CHANGE column_name new_name new_typeALTER TABLE employee CHANGE salary salary Double;-- 替换列ALTER TABLE name REPLACE COLUMNS (col_spec[, col_spec ...])ALTER TABLE employee REPLACE COLUMNS (    eid INT empid Int,    ename STRING name String);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（3）删除表</p><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">DROP TABLE [IF EXISTS] table_name;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4、Hive表数据操作"><a href="#4、Hive表数据操作" class="headerlink" title="4、Hive表数据操作"></a>4、Hive表数据操作</h2><p>（1）插入数据</p><ul><li><code>LOAD DATA</code>：从<code>HDFS</code>中加载数据会直接<code>move</code>！</li></ul><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">--命令LOAD DATA [LOCAL] INPATH 'filepath' [OVERWRITE] INTO TABLE tablename [PARTITION (partcol1=val1, partcol2=val2 ...)]--例子LOAD DATA LOCAL INPATH '/home/user/sample.txt' OVERWRITE INTO TABLE employee;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>INSERT INTO</code></li></ul><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">insert into table account select id, age, name from account_tmp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><code>INSERT OVERWRITE</code></li></ul><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">insert overwrite table account2 select id, age, name from account_tmp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong><em>注意</em></strong>：</p><p><code>insert overwrite</code>会覆盖已经存在的数据，假如原始表使用<code>overwrite</code>上述的数据，先现将原始表的数据<code>remove</code>，再插入新数据。</p><p><code>insert into</code>只是简单的插入，不考虑原始表的数据，直接追加到表中。</p><p>（2）修改数据</p><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">UPDATE tablename SET column = value [, column = value ...] [WHERE expression]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（3）删除数据</p><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">DELETE FROM tablename [WHERE expression]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="5、Hive分区操作"><a href="#5、Hive分区操作" class="headerlink" title="5、Hive分区操作"></a>5、Hive分区操作</h2><p>（1）添加分区</p><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">-- 命令ALTER TABLE table_name ADD [IF NOT EXISTS] PARTITION (p_column = p_col_value, p_column = p_col_value, ...)[LOCATION 'location1'] (p2_column = p2_col_value, p2_column = p2_col_value, ...) [LOCATION 'location2'] ...;-- 例子ALTER TABLE employee ADD PARTITION (year=’2013’) location '/2012/part2012';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）重命名分区</p><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">-- 命令ALTER TABLE table_name PARTITION partition_spec RENAME TO PARTITION partition_spec;-- 例子ALTER TABLE employee PARTITION (year=’1203’) RENAME TO PARTITION (Yoj=’1203’);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（3）删除分区</p><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">-- 命令ALTER TABLE table_name DROP [IF EXISTS] PARTITION partition_spec, PARTITION partition_spec,...;-- 例子ALTER TABLE employee DROP [IF EXISTS] PARTITION (year=’1203’);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6、Hive内置运算符"><a href="#6、Hive内置运算符" class="headerlink" title="6、Hive内置运算符"></a>6、Hive内置运算符</h2><p>（1）关系运算符</p><div class="table-container"><table><thead><tr><th>运算符</th><th>操作</th><th>描述</th></tr></thead><tbody><tr><td>A = B</td><td>所有基本类型</td><td></td></tr><tr><td>A != B</td><td>所有基本类型</td><td></td></tr><tr><td>A &lt; B</td><td>所有基本类型</td><td></td></tr><tr><td>A &lt;= B</td><td>所有基本类型</td><td></td></tr><tr><td>A &gt; B</td><td>所有基本类型</td><td></td></tr><tr><td>A &gt;= B</td><td>所有基本类型</td><td></td></tr><tr><td>A IS NULL</td><td>所有类型</td><td></td></tr><tr><td>A IS NOT NULL</td><td>所有类型</td><td></td></tr><tr><td>A LIKE B</td><td>字符串</td><td>TRUE，如果字符串模式A匹配到B，<br>否则FALSE。</td></tr><tr><td>A RLIKE B</td><td>字符串</td><td>TRUE：A任何子字符串匹配Java正则表达式B；</td></tr><tr><td>A REGEXP B</td><td>字符串</td><td>等同于RLIKE.</td></tr></tbody></table></div><p>（2）算术运算符</p><div class="table-container"><table><thead><tr><th>运算符</th><th>操作</th><th>描述</th></tr></thead><tbody><tr><td>A + B</td><td>所有数字类型</td><td></td></tr><tr><td>A - B</td><td>所有数字类型</td><td></td></tr><tr><td>A * B</td><td>所有数字类型</td><td></td></tr><tr><td>A / B</td><td>所有数字类型</td><td></td></tr><tr><td>A % B</td><td>所有数字类型</td><td></td></tr><tr><td>A &amp; B</td><td>所有数字类型</td><td>A和B的按位与结果</td></tr><tr><td>A \</td><td>B</td><td>所有数字类型</td><td>A和B的按位或结果</td></tr><tr><td>A ^ B</td><td>所有数字类型</td><td>A和B的按位异或结果</td></tr><tr><td>~ A</td><td>所有数字类型</td><td>A按位非的结果</td></tr></tbody></table></div><p>（3）逻辑运算符</p><div class="table-container"><table><thead><tr><th>运算符</th><th>操作</th><th>描述</th></tr></thead><tbody><tr><td>A AND B</td><td>Boolean</td><td>与</td></tr><tr><td>A &amp;&amp; B</td><td>Boolean</td><td></td></tr><tr><td>A OR B</td><td>Boolean</td><td>或</td></tr><tr><td>A \</td><td>\</td><td>B</td><td>Boolean</td><td></td></tr><tr><td>NOT A</td><td>Boolean</td><td>非</td></tr><tr><td>! A</td><td>Boolean</td></tr></tbody></table></div><p>（4）复杂运算符</p><div class="table-container"><table><thead><tr><th>运算符</th><th>操作</th><th>描述</th></tr></thead><tbody><tr><td>A[n]</td><td>A是一个数组，n是一个int</td><td>它返回数组A的第n+1个元素，第一个元素的索引0。</td></tr><tr><td>M[Key]</td><td>M 是一个 Map<K, v> 并 key 的类型为K</K,></td><td>它返回对应于映射中关键字的值。</td></tr><tr><td>S.x</td><td>S 是一个结构</td><td>它返回S的s字段</td></tr></tbody></table></div><h2 id="7、Hive内置函数"><a href="#7、Hive内置函数" class="headerlink" title="7、Hive内置函数"></a>7、Hive内置函数</h2><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">-- 返回BIGINT最近的double值。round(double a)-- 返回最大BIGINT值等于或小于double。floor(double a)-- 它返回最小BIGINT值等于或大于double。ceil(double a)-- 它返回一个随机数，从行改变到行。rand()rand(int seed)-- 它返回从A后串联B产生的字符串concat(string A, string B, ...)-- 它返回一个起始位置start到A结束的子字符串substr(string A, int start)-- 返回从给定长度length的从起始位置start开始的字符串。substr(string A, int start, int length)-- 它返回转换所有字符为大写的字符串。upper(string A)ucase(string A)-- 它返回转换所有字符为小写的字符串。lower(string A)lcase(string A)-- 它返回字符串从A两端修剪空格的结果trim(string A)-- 它返回从A左边开始修整空格产生的字符串(左手侧)ltrim(string A)-- 它返回从A右边开始修整空格产生的字符串(右侧)rtrim(string A)-- 它返回将A中的子字符串B替换为C的全新字符串regexp_replace(string A, string B, string C)-- 它返回在映射类型或数组类型的元素的数量。size(Map<K.V>)size(Array<T>)-- 将字段expr的数据类型转换为type。如果转换不成功，返回的是NULL。cast(<expr> as <type>)-- 将10位的时间戳值unixtime转为日期函数from_unixtime(int unixtime, 'yyyy-MM-dd HH:mm:ss')-- 返回一个字符串时间戳的日期部分：to_date("1970-01-01 00:00:00") = "1970-01-01"to_date(string timestamp, 'yyyy-MM-dd')-- 返回指定日期的unix时间戳unix_timestamp(string date, 'yyyy-MM-dd HH:mm:ss')  -- date的形式必须为’yyyy-MM-dd HH:mm:ss’的形式unix_timestamp()  -- 返回当前时间的unix时间戳-- 返回时间字段中的年月日year(string date, 'yyMMdd')  -- 年month(string date, 'yyMMdd')  -- 月day(string date, 'yyMMdd')  -- 日-- 返回时间字段是本年的第多少周weekofyear(string date, 'yyMMdd')-- 返回enddate与begindate之间的时间差的天数datediff(string enddate,string begindate)select datediff(‘2016-06-01’,’2016-05-01’) from Hive_sum limit 1;-- 返回date增加days天后的日期date_add(string date,int days)-- 返回date减少days天后的日期date_sub(string date,int days)-- 提取从基于指定的JSON路径的JSON字符串JSON对象，并返回提取的JSON字符串的JSON对象。get_json_object(string json_string, string path)-- 返回检索行的总数。count(*)count(expr)-- 返回该组或该组中的列的不同值的分组和所有元素的总和。sum(col)sum(DISTINCT col)-- 返回上述组或该组中的列的不同值的元素的平均值。avg(col)avg(DISTINCT col)-- 返回该组中的列的最大最小值。min(col)max(col)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="8、Hive视图和索引"><a href="#8、Hive视图和索引" class="headerlink" title="8、Hive视图和索引"></a>8、Hive视图和索引</h2><p>（1）创建视图</p><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">-- 命令CREATE VIEW [IF NOT EXISTS] view_name [(column_name [COMMENT column_comment], ...) ][COMMENT table_comment]AS SELECT ...-- 例子CREATE VIEW emp_30000 ASSELECT * FROM employeeWHERE salary>30000;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）删除视图</p><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">DROP VIEW view_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（3）创建索引</p><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">-- 命令CREATE INDEX index_nameON TABLE base_table_name (col_name, ...)AS 'index.handler.class.name'[WITH DEFERRED REBUILD][IDXPROPERTIES (property_name=property_value, ...)][IN TABLE index_table_name][PARTITIONED BY (col_name, ...)][   [ ROW FORMAT ...] STORED AS ...   | STORED BY ...][LOCATION hdfs_path][TBLPROPERTIES (...)]-- 例子：使用字段 Id, Name, Salary, Designation, 和 Dept创建一个名为index_salary的索引，对employee 表的salary列索引。CREATE INDEX inedx_salary ON TABLE employee(salary)AS 'org.apache.hadoop.Hive.ql.index.compact.CompactIndexHandler';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（4）删除索引</p><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">DROP INDEX <index_name> ON <table_name><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="二、Hive进阶"><a href="#二、Hive进阶" class="headerlink" title="二、Hive进阶"></a>二、Hive进阶</h1><h2 id="1、Hive-SELECT-数据"><a href="#1、Hive-SELECT-数据" class="headerlink" title="1、Hive SELECT 数据"></a>1、Hive SELECT 数据</h2><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">SELECT [ALL | DISTINCT] select_expr, select_expr, ... FROM table_reference [WHERE where_condition] [GROUP BY col_list] [HAVING having_condition] [CLUSTER BY col_list | [DISTRIBUTE BY col_list] [SORT BY col_list]] [ORDER BY col_list][LIMIT number];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2、命令执行顺序"><a href="#2、命令执行顺序" class="headerlink" title="2、命令执行顺序"></a>2、命令执行顺序</h2><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">-- 大致顺序from... where.... select... group by... having ... order by...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>备注：</strong>Hive语句和mysql都可以通过explain查看执行计划，使用explain + Hive语句</p><h1 id="三、Hive原理"><a href="#三、Hive原理" class="headerlink" title="三、Hive原理"></a>三、Hive原理</h1><h2 id="数据仓库概念"><a href="#数据仓库概念" class="headerlink" title="数据仓库概念"></a>数据仓库概念</h2><ul><li>Hive是数据仓库</li><li><strong>数据仓库跟数据库的区别：</strong><ol><li>数据库：传统的关系型数据库的主要应用，主要是基本的、日常的事务处理，例如银行交易。</li><li>数据仓库：数据仓库系统的应用主要是OLAP（On-Line Analytical Processing），支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。</li></ol></li></ul><p><img src="/2019/10/12/hive/hive_data_warehouse.png" alt="图：数据仓库结构"></p><h2 id="Hive简介"><a href="#Hive简介" class="headerlink" title="Hive简介"></a>Hive简介</h2><ul><li>Hadoop顶层的数据仓库工具</li><li>支持大数据存储与分析</li><li>依赖HDFS存储数据</li><li>依赖MapReduce处理数据</li><li>有类似SQL的查询语言-HiveQL</li><li>用户通过HiveQL运行MapReduce任务</li><li>Hive适用于<strong>BI报表</strong>，Pig适合ETL过程，HBase提供数据的实时访问</li></ul><h2 id="Hive与传统Sql对比"><a href="#Hive与传统Sql对比" class="headerlink" title="Hive与传统Sql对比"></a>Hive与传统Sql对比</h2><div class="table-container"><table><thead><tr><th>对比项目</th><th>Hive</th><th>传统Sql</th></tr></thead><tbody><tr><td>数据插入</td><td>支持批量导入</td><td>支持单条和批量</td></tr><tr><td>数据更新</td><td>不支持</td><td>支持</td></tr><tr><td>索引</td><td>支持</td><td>支持</td></tr><tr><td>分区</td><td>支持</td><td>支持</td></tr><tr><td>执行延迟</td><td>高</td><td>低</td></tr><tr><td>扩展性</td><td>好</td><td>有限</td></tr></tbody></table></div><h2 id="Hive系统架构"><a href="#Hive系统架构" class="headerlink" title="Hive系统架构"></a>Hive系统架构</h2><h3 id="用户接口模块"><a href="#用户接口模块" class="headerlink" title="用户接口模块"></a>用户接口模块</h3><h4 id="CLI"><a href="#CLI" class="headerlink" title="CLI"></a>CLI</h4><ul><li>Shell命令行</li><li>Karmasphere</li></ul><h4 id="HWI"><a href="#HWI" class="headerlink" title="HWI"></a>HWI</h4><ul><li>web接口</li><li>Hue</li></ul><h4 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h4><ul><li>Qubole</li><li>Hive 的Java，与使用传统数据库JDBC的方式类似</li></ul><h4 id="ODBC"><a href="#ODBC" class="headerlink" title="ODBC"></a>ODBC</h4><ul><li>Hive 的Java，与使用传统数据库JDBC的方式类似</li></ul><h4 id="Thrift-Server"><a href="#Thrift-Server" class="headerlink" title="Thrift Server"></a>Thrift Server</h4><ul><li>RPC调用</li></ul><h3 id="驱动模块"><a href="#驱动模块" class="headerlink" title="驱动模块"></a>驱动模块</h3><ul><li>编译器</li><li>优化器</li><li>执行器</li><li>解释器、编译器、优化器完成 HQL 查询语句从词法分析、语法分析、编译、优化以及查询计划（plan）的生成。</li><li>生成的查询计划存储在 HDFS 中，并在随后有 MapReduce 调用执行</li></ul><h3 id="元数据存储"><a href="#元数据存储" class="headerlink" title="元数据存储"></a>元数据存储</h3><ul><li>元数据存储模块（metastore）是一个独立的关系型数据库，目前只支持 mysql、derby。</li><li>Hive 中的元数据包括表的名字，表的列和分区及其属性，表的属性（是否为外部表等），表的数据所在目录等</li></ul><h2 id="Hive工作原理"><a href="#Hive工作原理" class="headerlink" title="Hive工作原理"></a>Hive工作原理</h2><h3 id="HQL转换成MapReduce作业的过程"><a href="#HQL转换成MapReduce作业的过程" class="headerlink" title="HQL转换成MapReduce作业的过程"></a>HQL转换成MapReduce作业的过程</h3><ul><li><a href="http://www.aboutyun.com/thread-20461-1-1.html" target="_blank" rel="noopener">HQL解析原理</a></li></ul><p><img src="/2019/10/12/hive/hive_to_mapreduce.png" alt="图：hive_to_mapreduce"></p><p><strong>注意：</strong></p><ul><li>当启动MR程序时，Hive本身不会生成MR算法程序，需要通过一个“Job执行计划”的XML文件驱动来执行内置的Mapper和Reducer模块</li><li>Hive通过和JobTracker通信来初始化MR任务</li></ul><h3 id="Hive-HA基本原理"><a href="#Hive-HA基本原理" class="headerlink" title="Hive HA基本原理"></a>Hive HA基本原理</h3><p><img src="/2019/10/12/hive/hiveHA.png" alt="图：hiveHA"></p><h1 id="四、impala"><a href="#四、impala" class="headerlink" title="四、impala"></a>四、impala</h1><ul><li>impala是由Cloudera公司开发的新型查询系统，提供SQL语义。</li><li>它的运行<strong>需要依赖Hive的元数据</strong>，能够查询PB级数据，在性能上比Hive高出3~30倍</li><li>impala不需要将查询语句转为MR程序运行，<strong>而是使用传统的分布式查询引擎直接到HDFS上查询数据</strong></li><li>详情请见</li></ul><h1 id="五、参考书籍"><a href="#五、参考书籍" class="headerlink" title="五、参考书籍"></a>五、参考书籍</h1><ul><li><a href="https://www.yiibai.com/Hive/" target="_blank" rel="noopener">易百教程</a></li><li><a href="https://study.163.com/course/courseMain.htm?courseId=1002887002" target="_blank" rel="noopener">大数据技术原理与应用</a></li></ul><h1 id="六、疑难解答"><a href="#六、疑难解答" class="headerlink" title="六、疑难解答"></a>六、疑难解答</h1><h2 id="1、Hive-在指定位置添加字段"><a href="#1、Hive-在指定位置添加字段" class="headerlink" title="1、Hive 在指定位置添加字段"></a>1、Hive 在指定位置添加字段</h2><ul><li><p>首先添加字段</p><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">alter table table_name add columns (c_time string comment '当前时间');<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>其次更改字段的顺序</p><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">alter table table_name change c_time c_time string after address;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h2 id="2、Hive创建表时指定文件格式"><a href="#2、Hive创建表时指定文件格式" class="headerlink" title="2、Hive创建表时指定文件格式"></a>2、Hive创建表时指定文件格式</h2><ul><li><p><strong>TEXTFIEL</strong></p><p>默认格式，数据不做压缩，磁盘开销大，数据解析开销大。<br>可结合Gzip、Bzip2使用（系统自动检查，执行查询时自动解压），但使用这种方式，Hive不会对数据进行切分，从而无法对数据进行并行操作。</p><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">-- 固定格式create table test1(str STRING)  STORED AS TEXTFILE;-- 自定义格式create table test1(str STRING)  STORED ASINPUTFORMAT 'org.apache.hadoop.mapred.TextInputFormat'OUTPUTFORMAT 'org.apache.hadoop.Hive.ql.io.HiveIgnoreKeyTextOutputFormat'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>SEQUENCEFILE</strong></p><p>SequenceFile是Hadoop API提供的一种二进制文件支持，其具有使用方便、可分割、可压缩的特点。<br>SequenceFile支持三种压缩选择：NONE, RECORD, BLOCK。 Record压缩率低，一般建议使用BLOCK压缩。</p><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">-- 固定格式create table test1(str STRING)  STORED AS SEQUENCEFILE;-- 自定义格式create table test1(str STRING)  STORED ASINPUTFORMAT 'org.apache.hadoop.mapred.SequenceFileInputFormat'OUTPUTFORMAT 'org.apache.hadoop.Hive.ql.io.HiveSequenceFileOutputFormat'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>RCFILE</strong></p><p>RCFILE是一种行列存储相结合的存储方式。首先，其将数据按行分块，保证同一个record在一个块上，避免读一个记录需要读取多个block。其次，块数据列式存储，有利于数据压缩和快速的列存取。</p><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">-- 固定格式create table test1(str STRING)  STORED AS RCFILE;-- 自定义格式create table test1(str STRING)  STORED ASINPUTFORMAT 'org.apache.hadoop.Hive.ql.io.RCFileInputFormat'OUTPUTFORMAT 'org.apache.hadoop.Hive.ql.io.RCFileOutputFormat'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="3、Hive同时拆分多列为多行"><a href="#3、Hive同时拆分多列为多行" class="headerlink" title="3、Hive同时拆分多列为多行"></a>3、Hive同时拆分多列为多行</h2><ul><li><a href="https://stackoverflow.com/questions/37585638/Hive-split-delimited-columns-over-multiple-rows-select-based-on-position?rq=1" target="_blank" rel="noopener">问题链接</a></li></ul><p><strong>问题：</strong></p><p>I’m Looking for a way to split the column based on comma delimited data. Below is my dataset</p><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">id  col1  col21   5,6   7,8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>I want to get the result</p><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">id col1 col21  5    71  6    8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>答案：</strong></p><p>You can use <code>posexplode()</code> to create position index columns for your split arrays. Then, select only those rows where the position indices are equal.</p><pre><code>SELECT id, col3, col4  FROM test  lateral VIEW posexplode(split(col1,&#39;\002&#39;)) col1 AS pos3, col3  lateral VIEW posexplode(split(col2,&#39;\002&#39;)) col2 AS pos4, col4  WHERE pos3 = pos4;</code></pre><p>Output:</p><pre><code>id col3 col41  5    71  6    8</code></pre><h2 id="4、-Hive或spark中执行sql字符常量包含-时会报错"><a href="#4、-Hive或spark中执行sql字符常量包含-时会报错" class="headerlink" title="4、 Hive或spark中执行sql字符常量包含;时会报错"></a>4、 Hive或spark中执行sql字符常量包含<code>;</code>时会报错</h2><p>比如</p><blockquote><p>select instr(‘abc;abc’, ‘;’);</p></blockquote><p>报错</p><blockquote><p>NoViableAltException(-1@[147:1: selectExpression : ( expression | tableAllColumns );])</p></blockquote><p><strong>修改：</strong>需要将<code>;</code>改为<code>ascii</code></p><blockquote><p>select instr(‘abc\073abc’, ‘\073’);</p></blockquote><h2 id="5、如何在-Apache-Hive-中解析-Json-数组"><a href="#5、如何在-Apache-Hive-中解析-Json-数组" class="headerlink" title="5、如何在 Apache Hive 中解析 Json 数组"></a>5、如何在 Apache Hive 中解析 Json 数组</h2><h3 id="问题1：从json字符串中解析一个字段-get-json-object"><a href="#问题1：从json字符串中解析一个字段-get-json-object" class="headerlink" title="问题1：从json字符串中解析一个字段-get_json_object"></a>问题1：从<strong>json字符串</strong>中解析一个字段-get_json_object</h3><pre class="line-numbers language-lang-hive"><code class="language-lang-hive">hive>  SELECT get_json_object('{"website":"www.iteblog.com","name":"过往记忆"}', '$.website');OKwww.iteblog.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="问题2：从json字符串中解析多个字段-json-tuple"><a href="#问题2：从json字符串中解析多个字段-json-tuple" class="headerlink" title="问题2：从json字符串中解析多个字段-json_tuple"></a>问题2：从<strong>json字符串</strong>中解析多个字段-json_tuple</h3><pre class="line-numbers language-lang-hive"><code class="language-lang-hive">hive> SELECT json_tuple('{"website":"www.iteblog.com","name":"过往记忆"}', 'website', 'name');OKwww.iteblog.com 过往记忆<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="问题3：从json数组中解析某一个字段-get-json-object"><a href="#问题3：从json数组中解析某一个字段-get-json-object" class="headerlink" title="问题3：从json数组中解析某一个字段-get_json_object"></a>问题3：从<strong>json数组</strong>中解析某一个字段-get_json_object</h3><pre class="line-numbers language-lang-hive"><code class="language-lang-hive">hive> SELECT get_json_object('[{"website":"www.iteblog.com","name":"过往记忆"}, {"website":"carbondata.iteblog.com","name":"carbondata 中文文档"}]', '$[0].website');OKwww.iteblog.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>注意：</strong>这里与参考链接<a href="https://www.iteblog.com/archives/2362.html" target="_blank" rel="noopener">如何在 Apache Hive 中解析 Json 数组</a>中不同的是，因为我用的是<code>sparkSql</code>，所以我用的是<code>$[0].website</code>，而参考链接使用的<code>$.[0].website</code>，我按照<strong>参考链接给的方法在Hive也select不出答案（可能是hive版本不同吧）</strong></p><h3 id="问题4：从json数组中解析多个字段-先explode再get-json-object或json-tuple"><a href="#问题4：从json数组中解析多个字段-先explode再get-json-object或json-tuple" class="headerlink" title="问题4：从json数组中解析多个字段-先explode再get_json_object或json_tuple"></a>问题4：从<strong>json数组</strong>中解析多个字段-先explode再get_json_object或json_tuple</h3><ul><li>explode将<strong>json数组</strong>用一行拆分成多行</li><li>然后再对其进行<strong>json字符串</strong>解析</li></ul><p>详情请参考<a href="https://www.iteblog.com/archives/2362.html" target="_blank" rel="noopener">如何在 Apache Hive 中解析 Json 数组</a></p><h2 id="6、删除表但是没删除hdfs数据，重建表并关联hdfs数据"><a href="#6、删除表但是没删除hdfs数据，重建表并关联hdfs数据" class="headerlink" title="6、删除表但是没删除hdfs数据，重建表并关联hdfs数据"></a>6、删除表但是没删除hdfs数据，重建表并关联hdfs数据</h2><p><a href="https://stackoverflow.com/questions/40043986/hdinsight-hive-msck-repair-table-table-name-throwing-error" target="_blank" rel="noopener">参考1</a></p><p><a href="https://blog.csdn.net/BabyFish13/article/details/79169496" target="_blank" rel="noopener">参考2</a></p><h2 id="7、HIVE将表划分测试集与训练集的方法"><a href="#7、HIVE将表划分测试集与训练集的方法" class="headerlink" title="7、HIVE将表划分测试集与训练集的方法"></a>7、HIVE将表划分测试集与训练集的方法</h2><ul><li><p><a href="https://www.thinbug.com/q/23548892" target="_blank" rel="noopener">将Hive表拆分为测试集和训练集</a></p></li><li><p><a href="https://www.iteblog.com/archives/1996.html" target="_blank" rel="noopener">https://www.iteblog.com/archives/1996.html</a></p></li></ul><pre class="line-numbers language-lang-hiveql"><code class="language-lang-hiveql">from ( select *, (rand() * 100 <= x) as is_test_set from my_table) tinsert overwrite directory '/test_set' select * where is_test_set = trueinsert overwrite directory '/training_set' select * where is_test_set = false;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="8、HIVE日期操作"><a href="#8、HIVE日期操作" class="headerlink" title="8、HIVE日期操作"></a>8、HIVE日期操作</h2><h3 id="获取时间戳"><a href="#获取时间戳" class="headerlink" title="获取时间戳"></a>获取时间戳</h3><pre class="line-numbers language-lang-hive"><code class="language-lang-hive">select unix_timestamp('2015-04-30 13:51:20');select unix_timestamp('2015-04-30');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="转格式"><a href="#转格式" class="headerlink" title="转格式"></a>转格式</h3><pre class="line-numbers language-lang-hive"><code class="language-lang-hive">select from_unixtime(1323308943,'yyyyMMdd');select from_unixtime(unix_timestamp('2015-04-30', 'yyyy-MM-dd'), 'yyyyMMdd');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="9、HIVE中distinct和group-by的区别"><a href="#9、HIVE中distinct和group-by的区别" class="headerlink" title="9、HIVE中distinct和group by的区别"></a>9、HIVE中<code>distinct</code>和<code>group by</code>的区别</h2><pre class="line-numbers language-lang-markdown"><code class="language-lang-markdown">前者是去重，后者是分组reduce作业个数不同，distinct会在一个reduce中去重<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="10、count-和-count-1-和count-列名-区别"><a href="#10、count-和-count-1-和count-列名-区别" class="headerlink" title="10、count(*) 和 count(1)和count(列名)区别"></a>10、count(*) 和 count(1)和count(列名)区别</h2><pre class="line-numbers language-lang-markdown"><code class="language-lang-markdown">* 执行效果上 ：  count(\*)包括了所有的列，相当于行数，在统计结果的时候， 不会忽略列值为NULL  count(1)包括了忽略所有列，用1代表代码行，在统计结果的时候， 不会忽略列值为NULL  count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数， 即某个字段值为NULL时，不统计。* 执行效率上：  列名为主键，count(列名)会比count(1)快  列名不为主键，count(1)会比count(列名)快  如果表多个列并且没有主键，则 count(1)的执行效率优于 count(\*) 如果有主键，则 select count(主键)的执行效率是最优的  如果表只有一个字段，则 select count(\*) 最优。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> AI/数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据科学 </tag>
            
            <tag> Hadoop </tag>
            
            <tag> 数据仓库 </tag>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算广告笔记</title>
      <link href="/2019/10/12/computational-advertising/"/>
      <url>/2019/10/12/computational-advertising/</url>
      
        <content type="html"><![CDATA[<h1 id="一、名词解释"><a href="#一、名词解释" class="headerlink" title="一、名词解释"></a>一、名词解释</h1><p><img src="/2019/10/12/computational-advertising/rtb_china.jpg" alt="图：rtb_china"></p><h2 id="广告主"><a href="#广告主" class="headerlink" title="广告主"></a>广告主</h2><p>有广告需求的客户公司，也称为需求方</p><h2 id="媒体"><a href="#媒体" class="headerlink" title="媒体"></a>媒体</h2><p>可以是网站或者<code>app</code>，即有多余的广告位可以出售，也称为供给方</p><h2 id="RTB：（Real-Time-Bidding，实时竞价）"><a href="#RTB：（Real-Time-Bidding，实时竞价）" class="headerlink" title="RTB：（Real Time Bidding，实时竞价）"></a>RTB：（<code>Real Time Bidding</code>，实时竞价）</h2><p>综合利用算法、大数据技术在网站或移动应用上对在线的流量实时评估价值，然后出价的竞价技术</p><h2 id="DSP（需求方平台）"><a href="#DSP（需求方平台）" class="headerlink" title="DSP（需求方平台）"></a>DSP（需求方平台）</h2><p>为各广告主或者代理商提供实时竞价投放平台，可以在该平台上管理广告活动及其投放策略，并且通过技术和算法优化投放效果，从中获得收益</p><h2 id="SSP（供应方平台）"><a href="#SSP（供应方平台）" class="headerlink" title="SSP（供应方平台）"></a>SSP（供应方平台）</h2><p>为各媒体提供一致、集成的广告位库存管理环境</p><h2 id="DMP（数据管理平台）"><a href="#DMP（数据管理平台）" class="headerlink" title="DMP（数据管理平台）"></a>DMP（数据管理平台）</h2><p>整合各方数据并提供数据分析，数据管理、数据调用等，用来指导广告主进行广告优化和投放决策</p><h2 id="ADX（Ad-Exchange，广告交易平台）"><a href="#ADX（Ad-Exchange，广告交易平台）" class="headerlink" title="ADX（Ad Exchange，广告交易平台）"></a>ADX（Ad Exchange，广告交易平台）</h2><p>同时接入了大量的<code>DSP</code>和<code>SSP</code>，给双方提供一个“交易场所”，将<code>SSP</code>方的广告展示需求以拍卖的方式卖给<code>DSP</code>方。可以类比于股票交易中的证券大厅角色</p><h2 id="CTR（点击率）"><a href="#CTR（点击率）" class="headerlink" title="CTR（点击率）"></a>CTR（点击率）</h2><p>广告点击与广告展现的比例，这是广告主、各大<code>DSP</code>厂商都非常重视的一个数字，从技术角度看，这一数字可以影响到广告的排序、出价等环节，从业务来看，这是运营人员的考核指标之一</p><ul><li><strong>CTR=点击量/展现量 *100%</strong></li></ul><h2 id="CVR（转化率）"><a href="#CVR（转化率）" class="headerlink" title="CVR（转化率）"></a>CVR（转化率）</h2><p>转化（主要由广告主定义，可以是一次下单或是一次下载<code>app</code>等）次数与到达次数的比例</p><ul><li><strong>CVR= 转化量/点击量 *100%</strong></li></ul><h2 id="eCPM（千次展示期望收入）"><a href="#eCPM（千次展示期望收入）" class="headerlink" title="eCPM（千次展示期望收入）"></a>eCPM（千次展示期望收入）</h2><p>点击率 * 点击价值，这个数字在计算广告中是核心指标，涉及到对召回广告的排序策略，以及最终出价策略</p><h2 id="CPM（Cost-per-mile）"><a href="#CPM（Cost-per-mile）" class="headerlink" title="CPM（Cost per mile）"></a>CPM（Cost per mile）</h2><p>每千次展现收费，最常见的广告模式，即不考虑点击次数、转化次数，只要广告在网站上被展现给一千个人看到就收费，是大型网站变现的最有效的方式。对广告主来说，适合于注重推广品牌的广告，力求最快最广的触及大众</p><ul><li><strong>CPM=广告费/展现量 *1000</strong></li></ul><h2 id="CPC（Cost-per-click）"><a href="#CPC（Cost-per-click）" class="headerlink" title="CPC（Cost per click）"></a>CPC（Cost per click）</h2><p>每次点击收费，无论广告被展现了多少次，只要没有产生点击就不收费。对于广告主来说选择 <code>CPC</code> 模式可以有助于提升点击量、发现潜在用户，进而可以真正做到精准营销；对于广大<code>DSP</code>厂商来说，这种收费模式也是获取利润的最有效来源之一</p><ul><li><strong>CPC=广告费/点击量</strong></li></ul><h2 id="CPA（Cost-per-action）"><a href="#CPA（Cost-per-action）" class="headerlink" title="CPA（Cost per action）"></a>CPA（Cost per action）</h2><p>每次动作收费，此处的动作一般定义为转化，可以是注册、咨询、交易、下载、留言等等，按照转化的数量来收费。对于广告主来说，这是性价比较高的一种收费方式，但是对于DPS和媒体方来说，想要把这种收费做好，却是有相当的难度。因此，目前也只有大厂或者技术实力深厚的<code>DSP</code>厂商才有能力接这种单子</p><ul><li><strong>CPA=广告费/转化量</strong></li></ul><h2 id="LTV（Life-Time-Value）"><a href="#LTV（Life-Time-Value）" class="headerlink" title="LTV（Life Time Value）"></a>LTV（Life Time Value）</h2><p>客户终生价值。是公司从用户所有的互动中所得到的全部经济收益的总和</p><ul><li>LTV的计算涉及到顾客保持率、顾客消费率、变动成本、获得成本、贴现率等信息的正确取得。</li><li>顾客保留率（retention rate，RR）= 本年度的顾客总数 / 上年度的顾客总数；</li><li>顾客消费率（spending rate，SR）= 顾客总消费额 / 顾客总数；</li><li>变动成本（variable cost，VC）= 产品成本 + 服务<a href="https://www.52by.com/article_tag/guanli" target="_blank" rel="noopener">管理</a>费用 + 信用卡成本等；</li><li>获得成本（acquisition cost，AC）= 本年度广告、<a href="https://www.52by.com/article_tag/cuxiao" target="_blank" rel="noopener">促销</a>费用 / 本年度顾客总数；</li><li>净利润（gross profit，GP）= 总收入 – 总成本；</li><li>贴现率（discount rate，DR）= [1 +（风险系数*银行利率）]n ；</li><li>利润净现值（net present value profit，NPV）= GP / DR ；</li><li>累积NPV = 特定时间内每年NPV 的总和；</li><li><strong>顾客终身价值（LTV）= 累积NPV / 顾客总数</strong></li></ul><h2 id="采购交易平台-Trading-desk"><a href="#采购交易平台-Trading-desk" class="headerlink" title="采购交易平台(Trading desk)"></a>采购交易平台(Trading desk)</h2><p>程序化独立媒体交易平台，功能类似于 DSP，通过对接多个 DSP来进行广告的优化投放，它能够将各类购买方式统一管理和预算分配，对品牌广告的有效管理甄别垃圾媒体。</p><h2 id="程序化创意平台-programmatic-creative"><a href="#程序化创意平台-programmatic-creative" class="headerlink" title="程序化创意平台(programmatic creative)"></a>程序化创意平台(programmatic creative)</h2><p>动态实时创意优化平台，它帮助广告主评估和优化广告创意，能更好的在提升在实时竞价广告投放中的效果。</p><h2 id="广告验证-ad-verification"><a href="#广告验证-ad-verification" class="headerlink" title="广告验证(ad verification)"></a>广告验证(ad verification)</h2><p>安全有效的购买广告的手段，被许多广告代理视作广告策略中必不可少的一个组成部分。</p><h1 id="二、竞价流程"><a href="#二、竞价流程" class="headerlink" title="二、竞价流程"></a>二、竞价流程</h1><p><img src="/2019/10/12/computational-advertising/bid_process.jpg" alt="图：bid_process"></p><p><img src="/2019/10/12/computational-advertising/bid_process1.png" alt="图：bid_process-简单版"></p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol><li>用户通过浏览器访问网站</li><li>浏览器发送广告请求给网站服务器，即媒体</li><li>媒体将该曝光展示通过SSP发送给Adx</li><li>Adx组织一次竞价，将本次的竞价请求通知给与之对接的所有DSP方，并传输用户ID、用户IP以及广告位信息等等</li><li>各家DSP监听服务收到Adx发来的竞价请求后，根据发送来的当前用户的信息、上下文信息、代理的广告主信息对照投放需求，并与自家的DMP数据管理平台或用户数据库来评估该请求，并通过DSP的竞价引擎判断是否参与竞价，若参与则给出竞标价格</li><li>Adx收到所有出价响应或截止时间后（通常规定是100ms）根据出价排序，通知出价最高的DSP胜出，同时将胜者的竞价信息告知SSP</li><li>胜者DSP会收到Adx发送的竞价消息（WinNotice），表示该次展现已经竞价成功。DSP此时将广告物料传送至SSP，SSP 发送广告曝光请求给广告服务器</li><li>广告服务器将广告投送到用户浏览的页面</li></ol><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>有两点需要说明：</p><ol><li>以上流程需在100毫秒之内完成，也就是一眨眼的功夫都不到，这样才能让访问网站的用户马上看到广告。</li><li>虽然竞价最后的胜者是出价最高的DSP，但其实际支付的价格是出价第二高的报价再加上一个最小值，这就是著名的广义二阶拍卖(GSP)。这种定价模式的好处主要是为了避免各家DSP在多次竞价中，下一次的出价只需比上一次的胜出价格高一点点即可，从而导致出价越来越低。在GSP模式下，每个胜者只需要支付次高出价的金额，这样各家DSP也就没有动力相互压价。GSP是一种稳定的竞价方式，可操作性很强，现阶段几乎所有的互联网广告平台都使用这一种竞价方式。</li></ol><h1 id="三、技术细节"><a href="#三、技术细节" class="headerlink" title="三、技术细节"></a>三、技术细节</h1><h2 id="典型广告系统架构"><a href="#典型广告系统架构" class="headerlink" title="典型广告系统架构"></a>典型广告系统架构</h2><p><img src="/2019/10/12/computational-advertising/structure.jpg" alt="图：structure"></p><p><strong>（1）受众定向平台：</strong>利用数据挖掘、机器学习等技术进行受众定向、点击率预估等工作。具体可以细分为以下几个模块：</p><ul><li><strong>会话日志生成（Session log generation）</strong>：从各个数据平台收集日志，并最终根据用户ID为主键汇集成一份统一存储格式的日志，为后续的数据分析、算法构建提供数据来源。</li><li><strong>行为定向（Audience targeting）</strong>：从会话日志中提取数据，利用数据挖掘、机器学习等算法建模，刻画出用户的行为模式、兴趣点等，最终为用户打上结构化标签，以供广告定向投放使用。</li><li><strong>点击率建模（Click modeling）</strong>：从会话日志中提取预定义的特征，训练点击率模型，加载到缓存中供线上投放系统决策时使用。</li><li><strong>商业智能模块（Business Intelligence）</strong>：包括ETL（Extract-Transform-Load）过程、Dashboard、cube。BI系统可以为决策者提供直观且即时的数据分析，而算法对决策者来说相当于黑盒，因此，设计一个良好的BI系统可以为决策提供有力的帮助。</li></ul><p><strong>（2）高并发的投送系统</strong>：即在线的广告投放机（Ad server），主要任务是与各模块交互，将它们串联起来完成在线的广告投放决策。特点是高并发，要做到10 ms级别的实时决策，百亿次/天的广告投放系统。具体可细分为以下几个模块：</p><ul><li><strong>广告检索（Ad retrieval）</strong>：也称为广告召回，即根据用户属性以及页面上下文属性从广告索引（Ad index）中查找符合条件的广告候选。</li><li><strong>广告排序（Ad ranking）</strong>：主要功能是对广告检索模块送来的广告候选集计算eCPM，并按照值的大小倒排。eCPM的计算依赖于受众定向平台离线计算好的点击率。由于最终投放出的广告都是来自于排序的结果，因此这一模块也是至关重要，成为各种算法模型和策略大展身手的地方。</li><li><strong>收益管理（Yield management）</strong>：将局部广告排序的结果进一步优化，以做到全局最优收益。</li></ul><p><strong>（3）数据高速公路：</strong>联通在线与离线。作用是准实时地将日志推送到其它平台上，一是快速地反馈到线上系统中，二是给BI人员快速看结果。它还可能收集其它平台的日志，比如搜索广告会收集搜索日志。</p><p><strong>（4）流式计算平台：</strong>主要功能是对在线数据的处理，做到准实时的挖掘和反馈，解决那些离线计算平台无法快速响应的计算问题。具体又可分为：</p><ul><li><strong>实时受众定向（Real-time targeting）</strong>和<strong>实时点击反馈（Real-time click feedback）</strong>：对用户的实时行为进行计算，如实时更新点击率模型、动态调整用户标签，进而更好的适应线上环境。</li><li><strong>计费（Billing）</strong>：该模块掌管着广告系统的“钱袋子”，运行的准确性和稳定性直接影响了系统的收益。在广告投放过程中，经常会遇到投放预算用完的情况，这时计费模块必须及时反应，采取例如通知索引系统暂时将广告下线的办法，避免带来损失。</li><li><strong>反作弊（Anti-spam）</strong>：利用算法和人工规则等实时判断流量来源中是否有作弊流量，并将这部分流量从后续的计价和统计中去掉，是广告业务非常重要的部分。</li></ul><h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><p><strong>（1）<code>Hadoop</code>：</strong>详情请见<a href="/2019/11/12/hadoop/" title="Hadoop笔记">Hadoop笔记</a></p><p><strong>（2）<code>Spark</code>：</strong>详情请见</p><p><strong>（3）<code>Lucene</code>：</strong>详情请见</p><p><strong>（4）<code>Storm</code>：</strong>详情请见<a href="/2019/12/17/storm/" title="Storm笔记">Storm笔记</a></p><p><strong>（5）<code>ZooKeeper</code>：</strong>详情请见</p><h2 id="核心算法"><a href="#核心算法" class="headerlink" title="核心算法"></a>核心算法</h2><p>详情请见<a href="https://zhuanlan.zhihu.com/p/60544294" target="_blank" rel="noopener">参考文章</a>核心算法篇</p><h1 id="四、-参考书籍-amp-论文"><a href="#四、-参考书籍-amp-论文" class="headerlink" title="四、 参考书籍&amp;论文"></a>四、 参考书籍&amp;论文</h1><ul><li>《计算广告》 刘鹏 / 王超</li><li><a href="https://zhuanlan.zhihu.com/p/60544294" target="_blank" rel="noopener">计算广告系统算法与架构综述</a></li><li><a href="https://dolantinlist.github.io/2018/05/21/RTB广告竞价系统的算法介绍/" target="_blank" rel="noopener">RTB广告竞价系统的算法介绍</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> AI/数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据科学 </tag>
            
            <tag> 计算广告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习清单</title>
      <link href="/2019/10/10/knowledge-topology/"/>
      <url>/2019/10/10/knowledge-topology/</url>
      
        <content type="html"><![CDATA[<h1 id="一、实用工具"><a href="#一、实用工具" class="headerlink" title="一、实用工具"></a>一、实用工具</h1><h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><h3 id="C-1"><a href="#C-1" class="headerlink" title="C"></a>C</h3><h3 id="C-2"><a href="#C-2" class="headerlink" title="C ++"></a>C ++</h3><h3 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h3><p>（1）教程</p><ul><li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744" target="_blank" rel="noopener">廖大神</a></li></ul><p>（2）笔记</p><h3 id="PYTHON"><a href="#PYTHON" class="headerlink" title="PYTHON"></a>PYTHON</h3><h2 id="大数据工具"><a href="#大数据工具" class="headerlink" title="大数据工具"></a>大数据工具</h2><h3 id="查询引擎"><a href="#查询引擎" class="headerlink" title="查询引擎"></a>查询引擎</h3><h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><h4 id="PIG"><a href="#PIG" class="headerlink" title="PIG"></a>PIG</h4><h4 id="HIVE"><a href="#HIVE" class="headerlink" title="HIVE"></a>HIVE</h4><h4 id="PRESTO"><a href="#PRESTO" class="headerlink" title="PRESTO"></a>PRESTO</h4><h4 id="IMPALA"><a href="#IMPALA" class="headerlink" title="IMPALA"></a>IMPALA</h4><h4 id="SPARK-SQL"><a href="#SPARK-SQL" class="headerlink" title="SPARK SQL"></a>SPARK SQL</h4><h3 id="计算工具"><a href="#计算工具" class="headerlink" title="计算工具"></a>计算工具</h3><h4 id="流式计算"><a href="#流式计算" class="headerlink" title="流式计算"></a>流式计算</h4><h5 id="APACHE-FLINK"><a href="#APACHE-FLINK" class="headerlink" title="APACHE FLINK"></a>APACHE FLINK</h5><h5 id="TWITTER-STORM"><a href="#TWITTER-STORM" class="headerlink" title="TWITTER STORM"></a>TWITTER STORM</h5><h5 id="SPARK-STREAMING"><a href="#SPARK-STREAMING" class="headerlink" title="SPARK STREAMING"></a>SPARK STREAMING</h5><h4 id="迭代计算"><a href="#迭代计算" class="headerlink" title="迭代计算"></a>迭代计算</h4><h5 id="TWISTER"><a href="#TWISTER" class="headerlink" title="TWISTER"></a>TWISTER</h5><h5 id="HALOOP"><a href="#HALOOP" class="headerlink" title="HALOOP"></a>HALOOP</h5><h5 id="APACHE-HAMA"><a href="#APACHE-HAMA" class="headerlink" title="APACHE HAMA"></a>APACHE HAMA</h5><h5 id="SPARK-GRAPHX"><a href="#SPARK-GRAPHX" class="headerlink" title="SPARK GRAPHX"></a>SPARK GRAPHX</h5><h5 id="APACHE-GIRAPH"><a href="#APACHE-GIRAPH" class="headerlink" title="APACHE GIRAPH"></a>APACHE GIRAPH</h5><h4 id="离线计算"><a href="#离线计算" class="headerlink" title="离线计算"></a>离线计算</h4><h5 id="APACHE-FLINK-1"><a href="#APACHE-FLINK-1" class="headerlink" title="APACHE FLINK"></a>APACHE FLINK</h5><h5 id="BERKELEY-SPARK"><a href="#BERKELEY-SPARK" class="headerlink" title="BERKELEY SPARK"></a>BERKELEY SPARK</h5><h5 id="HADOOP-MAPREDUCE"><a href="#HADOOP-MAPREDUCE" class="headerlink" title="HADOOP MAPREDUCE"></a>HADOOP MAPREDUCE</h5><h3 id="存储工具"><a href="#存储工具" class="headerlink" title="存储工具"></a>存储工具</h3><h4 id="KEY-VALUE存储"><a href="#KEY-VALUE存储" class="headerlink" title="KEY-VALUE存储"></a>KEY-VALUE存储</h4><h5 id="REDIS"><a href="#REDIS" class="headerlink" title="REDIS"></a>REDIS</h5><h5 id="HBASE"><a href="#HBASE" class="headerlink" title="HBASE"></a>HBASE</h5><h4 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h4><h5 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h5><h5 id="MONGODB"><a href="#MONGODB" class="headerlink" title="MONGODB"></a>MONGODB</h5><h3 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h3><h4 id="ZOOKEEPER"><a href="#ZOOKEEPER" class="headerlink" title="ZOOKEEPER"></a>ZOOKEEPER</h4><h4 id="HADOOP-YARN"><a href="#HADOOP-YARN" class="headerlink" title="HADOOP YARN"></a>HADOOP YARN</h4><h4 id="TWITTER-MESOS"><a href="#TWITTER-MESOS" class="headerlink" title="TWITTER MESOS"></a>TWITTER MESOS</h4><h3 id="日志收集系统"><a href="#日志收集系统" class="headerlink" title="日志收集系统"></a>日志收集系统</h3><h4 id="KIBANA"><a href="#KIBANA" class="headerlink" title="KIBANA"></a>KIBANA</h4><h4 id="LOGSTASH"><a href="#LOGSTASH" class="headerlink" title="LOGSTASH"></a>LOGSTASH</h4><h4 id="ELASTIC-SEARCH"><a href="#ELASTIC-SEARCH" class="headerlink" title="ELASTIC SEARCH"></a>ELASTIC SEARCH</h4><h4 id="CLOUDERA-FLUME"><a href="#CLOUDERA-FLUME" class="headerlink" title="CLOUDERA FLUME"></a>CLOUDERA FLUME</h4><h3 id="消息系统"><a href="#消息系统" class="headerlink" title="消息系统"></a>消息系统</h3><h4 id="APACHE-KAFKA"><a href="#APACHE-KAFKA" class="headerlink" title="APACHE KAFKA"></a>APACHE KAFKA</h4><h3 id="版本控制工具"><a href="#版本控制工具" class="headerlink" title="版本控制工具"></a>版本控制工具</h3><h4 id="GIT"><a href="#GIT" class="headerlink" title="GIT"></a>GIT</h4><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><h4 id="SHELL"><a href="#SHELL" class="headerlink" title="SHELL"></a>SHELL</h4><h1 id="二、算法学习"><a href="#二、算法学习" class="headerlink" title="二、算法学习"></a>二、算法学习</h1><h2 id="推荐算法"><a href="#推荐算法" class="headerlink" title="推荐算法"></a>推荐算法</h2><h3 id="协同过滤"><a href="#协同过滤" class="headerlink" title="协同过滤"></a>协同过滤</h3><h1 id="三、推荐书籍"><a href="#三、推荐书籍" class="headerlink" title="三、推荐书籍"></a>三、推荐书籍</h1>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据科学 </tag>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
