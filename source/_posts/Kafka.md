---
title: Kafka
author: Myhaa
top: false
cover: false
toc: true
mathjax: false
categories: AI/数据科学
tags:
  - 人工智能
  - 消息系统
  - Kafka
date: 2020-01-02 16:46:47
img:
coverImg:
password:
summary: 有关Kafka的笔记
---

# Kafka基础

## 简介

### Kafka是什么？

* Apache Kafka是一个分布式流平台
* Kafka作为一个集群运行在一个或多个服务器上，这些服务器可以跨越多个数据中心
* Kafka集群将记录流存储在称为主题`Topic`的类别中
* **每个记录由一个键`key`、一个值`value`和一个时间戳`timestamp`组成**

### 流平台的关键特性

* 发布和订阅记录流，类似于消息队列或企业消息传递系统
* 以容错的持久方式存储记录流
* 处理记录流（当它们发生时）

### Kafka的应用领域

* 构建实时流数据管道，在系统或应用程序之间可靠地获取数据
* 构建转换或响应数据流的实时流应用程序

### Kafka的四个核心API

![Kafka-APIs](/Kafka/kafka-apis.png)

* [Producer API](<https://kafka.apache.org/documentation.html#producerapi>)：允许应用程序将记录流发布到一个或多个Kafka主题`Topic`
* [Consumer API](<https://kafka.apache.org/documentation.html#consumerapi>)：允许应用程序订阅一个或多个主题`Topic`，并处理产生给它们的记录流。
* [Streams API](<https://kafka.apache.org/documentation.html#connectapi>)：允许应用程序充当流处理器，使用一个或多个主题`Topic`的输入流，并生成一个或多个输出主题`Topic`的输出流，从而有效地将输入流转换为输出流
* [Connector API](<https://kafka.apache.org/documentation.html#connectapi>)：允许构建和运行将Kafka主题`Topic`连接到现有应用程序或数据库的可重用生产者或消费者。例如，到关系数据库的连接器可能捕获对表的每个更改。

### 通信协议

* 在Kafka中，客户端和服务器之间的通信是通过一个简单的、高性能的、语言无关的`TCP`协议来完成的。此协议经过版本控制，并保持与旧版本的向后兼容性

## 核心概念

### 主题`[Topics]`

* 主题是被发布记录所属类别或订阅源的名词
* 一个主题可以有零个，一个或多个消费者来订阅写入该主题的数据

### 日志`[Logs]`

* 对于每个主题，Kafka集群维护一个类似下图的分区日志

![log_anatomy](/Kafka/log_anatomy.png)

* 每个分区都是有序的，不可变的记录序列，这些记录连续地附加到结构化的提交日志中
* 每个分区中的记录都分配有一个称为**偏移**的顺序ID号，该ID唯一地标识分区中的每个记录
* Kafka集群使用可配置的保留期限持久保留所有已发布记录（无论是否已使用它们），超过保留期限后，记录将被丢弃以释放空间
* Kafka的性能在数据大小方面是稳定的，所以**长时间存储数据不是问题**

* 如下图，偏移量由使用者控制：通常，使用者在读取记录时会线性地推进其偏移量，但是实际上，由于位置是由使用者控制的，因此它可以按喜欢的任何顺序使用记录。 例如，使用者可以重置到较旧的偏移量以重新处理过去的数据，或者跳到最近的记录并从“现在”开始使用。

![log_consumer](/Kafka/log_consumer.png)

* 这些特性的组合意味着Kafka消费者非常便宜，他们可以来去自如，对集群或其他消费者没有太大影响。例如，您可以使用命令行工具“跟踪”任何主题的内容，而不需要更改任何现有使用者所使用的内容
* 日志中的分区有多种用途。 首先，它们允许日志扩展到超出单个服务器所能容纳的大小。 每个单独的分区都必须适合托管它的服务器，但是一个主题可能有很多分区，因此它可以处理任意数量的数据。 其次，它们充当并行性的单元

### 分布`[Distribution]`

* 日志的分区分布在Kafka群集中的服务器上，每个服务器处理数据并要求共享分区。 
* 每个分区都在可配置数量的服务器之间复制，以实现容错功能
* 每个分区有一个充当“领导者”的服务器和零个或多个充当“追随者”的服务器
* 领导者处理该分区的所有读写请求，而追随者则被动复制领导者
* 如果领导者失败，则追随者之一将自动成为新领导者
* 每个服务器既充当某些分区的领导者，又充当其他分区的追随者，这样集群中的负载得到了很好的平衡

### 异地备份`[Geo-Replication]`

* Kafka MirrorMaker为集群提供异地备份支持
* 使用MirrorMaker，消息可以跨多个数据中心或云区域进行备份
* 您可以在主动/被动方案中使用它进行备份和恢复，或在主动/主动方案中将数据放置在离您的用户更近的位置，或支持本地数据需求

### 生产者`[Producers]`

* 生产者将数据发布到他们选择的主题
* 生产者负责选择将哪个记录分配给主题中的哪个分区
* 这可以以循环的方式来完成，只是为了平衡负载，也可以根据某种语义划分函数来完成(比如基于记录中的某个键)

### 消费者`[Consumers]`

* 消费者使用消费者组名称标记自己，并且发布到主题的每条记录都会传递到每个订阅消费者组中的一个消费者实例
* 消费者实例可以在单独的进程中或在单独的机器上
* 如果所有消费者实例具有相同的消费者组，那么记录将有效地在消费者实例上进行负载平衡
* 如果所有消费者实例都有不同的消费者组，那么每个记录将被广播到所有消费者进程

**举例如下图：**

![log_consumer](/Kafka/consumer-groups.png)

* 

# Kafka进阶

# 参考书籍

* [官网文档](<https://kafka.apache.org/documentation/>)

# 疑难解答